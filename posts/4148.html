<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>用 JavaScript 自制 GameBoy 模拟器（上） · Cytrogen 的个人博客</title><meta name="description" content="本文是一篇使用现代 JavaScript (ES6) 从零开始制作 GameBoy 模拟器的详细教程（上篇）。文章循序渐进地讲解了模拟 GameBoy 核心硬件的原理与实现，内容涵盖 Z80 CPU 的指令周期、内存管理单元（MMU）的内存映射、GPU 的显示时序和瓦片图形渲染系统。最终通过一个系统调度器将这些独立的模块集成起来，构建出一个完整、可运行的模拟器基础架构。本教程不仅提供了大量代码示例，还用通俗易懂的方式解释了底层硬件的工作原理，适合对模拟器开发、计算机体系结构或复古游戏技术感兴趣的开发者。"><link rel="icon" href="../favicon.png"><link rel="preload" href="../fonts/opensans-regular-latin.woff2" as="font" type="font/woff2" crossorigin="anonymous"><style>@font-face {
  font-family: 'Open Sans';
  src: url('../fonts/opensans-regular-latin.woff2') format('woff2');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
  size-adjust: 107%;
  ascent-override: 97%;
  descent-override: 25%;
  line-gap-override: 0%;
}
</style><link rel="stylesheet" href="../css/ares.css"><script>(function() {
  const getInitialTheme = () => {
    const saved = localStorage.getItem('theme');
    if (saved && (saved === 'light' || saved === 'dark')) {
      return saved;
    }
    
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      return 'dark';
    }
    
    return 'light';
  };
  
  const theme = getInitialTheme();
  document.documentElement.setAttribute('data-theme', theme);
  
  document.documentElement.style.colorScheme = theme;
  
  // Add anti-flicker style for dark mode
  if (theme === 'dark') {
    const style = document.createElement('style');
    style.id = 'anti-flicker-style';
    style.innerHTML = `
      #page-wrapper[data-theme="dark"] {
        background-color: #0f172a;
        color: #f1f5f9;
      }
    `;
    document.head.appendChild(style);
  }
  
  document.addEventListener('DOMContentLoaded', function() {
    const pageWrapper = document.getElementById('page-wrapper');
    if (pageWrapper) {
      pageWrapper.setAttribute('data-theme', theme);
    }
  });
})();

</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="atom.xml" title="Cytrogen 的个人博客" type="application/atom+xml">
</head><body><div id="page-wrapper"><a class="skip-link" href="#main-content">跳到主要内容</a><div class="wrap"><header><a class="logo-link" href="../index.html"><img src="../favicon.png" alt="logo"></a><nav class="site-nav"><div class="nav-main"><div class="nav-primary"><ul class="nav-list hidden-mobile"><li class="nav-item"><a class="nav-link" href="../index.html">首页</a></li></ul><div class="nav-tools"><div class="language-menu"><button class="language-toggle" type="button"><svg class="icon icon-globe" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true" focusable="false"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8zm7.5-6.923c-.67.204-1.335.82-1.887 1.855A7.97 7.97 0 0 0 5.145 4H7.5V1.077zM4.09 4a9.267 9.267 0 0 1 .64-1.539 6.7 6.7 0 0 1 .597-.933A7.025 7.025 0 0 0 2.255 4H4.09zm-.582 3.5c.03-.877.138-1.718.312-2.5H1.674a6.958 6.958 0 0 0-.656 2.5h2.49zM4.847 5a12.5 12.5 0 0 0-.338 2.5H7.5V5H4.847zM8.5 5v2.5h2.99a12.495 12.495 0 0 0-.337-2.5H8.5zM4.51 8.5a12.5 12.5 0 0 0 .337 2.5H7.5V8.5H4.51zm3.99 0V11h2.653c.187-.765.306-1.608.338-2.5H8.5zM5.145 12c.138.386.295.744.468 1.068.552 1.035 1.218 1.65 1.887 1.855V12H5.145zm.182 2.472a6.696 6.696 0 0 1-.597-.933A9.268 9.268 0 0 1 4.09 12H2.255a7.024 7.024 0 0 0 3.072 2.472zM3.82 11a13.652 13.652 0 0 1-.312-2.5h-2.49c.062.89.291 1.733.656 2.5H3.82zm6.853 3.472A7.024 7.024 0 0 0 13.745 12H11.91a9.27 9.27 0 0 1-.64 1.539 6.688 6.688 0 0 1-.597.933zM8.5 12v2.923c.67-.204 1.335-.82 1.887-1.855A7.97 7.97 0 0 0 10.855 12H8.5zm3.68-1h2.146c.365-.767.594-1.61.656-2.5h-2.49a13.65 13.65 0 0 1-.312 2.5zm2.802-3.5a6.959 6.959 0 0 0-.656-2.5H12.18c.174.782.282 1.623.312 2.5h2.49zM11.27 2.461c.247.464.462.98.64 1.539h1.835a7.024 7.024 0 0 0-3.072-2.472c.218.284.418.598.597.933zM10.855 4a7.966 7.966 0 0 0-.468-1.068C9.835 1.897 9.17 1.282 8.5 1.077V4h2.355z"></path></svg><span>中文</span></button><div class="language-dropdown"></div></div></div><div class="nav-controls"><div class="more-menu hidden-mobile"><button class="more-toggle" type="button"><span>更多</span><svg class="icon icon-chevron-down" width="12" height="12" viewBox="0 0 12 12" fill="currentColor" aria-hidden="true" focusable="false"><path d="M6 8.825c-.2 0-.4-.1-.5-.2l-3.3-3.3c-.3-.3-.3-.8 0-1.1s.8-.3 1.1 0l2.7 2.7 2.7-2.7c.3-.3.8-.3 1.1 0s.3.8 0 1.1l-3.3 3.3c-.1.1-.3.2-.5.2z"></path></svg></button><div class="more-dropdown"><ul class="dropdown-list"><li class="dropdown-item"><a class="nav-link" href="../archives">归档</a></li><li class="dropdown-item"><a class="nav-link" href="../categories">分类</a></li><li class="dropdown-item"><a class="nav-link" href="../tags">标签</a></li><li class="dropdown-item"><a class="nav-link" href="../about">关于</a></li><li class="dropdown-item"><a class="nav-link" href="../friends">友链</a></li><li class="dropdown-item"><a class="nav-link" href="../atom.xml">RSS订阅</a></li><li class="dropdown-item"><a class="dropdown-link" href="https://portfolio.cytrogen.icu" target="_blank" rel="noopener noreferrer">作品集<svg class="icon icon-external-link" width="14" height="14" viewBox="0 0 14 14" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8.636 2.364A1 1 0 0 1 10 1h3a1 1 0 0 1 1 1v3a1 1 0 0 1-2 0V3.414l-4.293 4.293a1 1 0 0 1-1.414-1.414L10.586 2H9a1 1 0 0 1-1.364-1.636zM2 3a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V9a1 1 0 1 1 2 0v3a3 3 0 0 1-3 3H2a3 3 0 0 1-3-3V4a3 3 0 0 1 3-3h3a1 1 0 1 1 0 2H2z"></path></svg></a></li><li class="dropdown-item"><a class="dropdown-link" href="https://github.com/cytrogen" target="_blank" rel="noopener noreferrer">GitHub<svg class="icon icon-external-link" width="14" height="14" viewBox="0 0 14 14" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8.636 2.364A1 1 0 0 1 10 1h3a1 1 0 0 1 1 1v3a1 1 0 0 1-2 0V3.414l-4.293 4.293a1 1 0 0 1-1.414-1.414L10.586 2H9a1 1 0 0 1-1.364-1.636zM2 3a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V9a1 1 0 1 1 2 0v3a3 3 0 0 1-3 3H2a3 3 0 0 1-3-3V4a3 3 0 0 1 3-3h3a1 1 0 1 1 0 2H2z"></path></svg></a></li></ul></div></div><div class="theme-switcher"><button class="theme-toggle" type="button" role="switch" aria-pressed="false" aria-label="切换主题"><div class="theme-icon moon-icon"><svg class="icon icon-moon" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true" focusable="false"><path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"></path></svg></div><div class="theme-icon sun-icon"><svg class="icon icon-sun" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0 1a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"></path></svg></div></button></div><details class="mobile-menu-details hidden-desktop"><summary class="hamburger-menu" aria-label="nav.menu"><svg class="icon icon-bars" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true" focusable="false"><path d="M2.5 12a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5z"></path></svg><span class="menu-text">nav.menu</span></summary><div class="mobile-menu-dropdown"><ul class="mobile-nav-list"><li class="mobile-nav-item"><a class="mobile-nav-link" href="../index.html">首页</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../archives">归档</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../categories">分类</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../tags">标签</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../about">关于</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../friends">友链</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../atom.xml">RSS订阅</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="https://portfolio.cytrogen.icu" target="_blank" rel="noopener noreferrer">作品集<svg class="icon icon-external-link" width="14" height="14" viewBox="0 0 14 14" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8.636 2.364A1 1 0 0 1 10 1h3a1 1 0 0 1 1 1v3a1 1 0 0 1-2 0V3.414l-4.293 4.293a1 1 0 0 1-1.414-1.414L10.586 2H9a1 1 0 0 1-1.364-1.636zM2 3a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V9a1 1 0 1 1 2 0v3a3 3 0 0 1-3 3H2a3 3 0 0 1-3-3V4a3 3 0 0 1 3-3h3a1 1 0 1 1 0 2H2z"></path></svg></a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="https://github.com/cytrogen" target="_blank" rel="noopener noreferrer">GitHub<svg class="icon icon-external-link" width="14" height="14" viewBox="0 0 14 14" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8.636 2.364A1 1 0 0 1 10 1h3a1 1 0 0 1 1 1v3a1 1 0 0 1-2 0V3.414l-4.293 4.293a1 1 0 0 1-1.414-1.414L10.586 2H9a1 1 0 0 1-1.364-1.636zM2 3a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V9a1 1 0 1 1 2 0v3a3 3 0 0 1-3 3H2a3 3 0 0 1-3-3V4a3 3 0 0 1 3-3h3a1 1 0 1 1 0 2H2z"></path></svg></a></li></ul></div></details></div></div></div></nav></header><main class="container" id="main-content" tabindex="-1"><div class="post"><article class="post-block"><h1 class="post-title">用 JavaScript 自制 GameBoy 模拟器（上）</h1><div class="post-info">7/1/2025</div><div class="post-content"><p>近期有些百无聊赖。因为工作，先前的个人项目全都不得不暂时搁置。为了找点乐子，我决定做一些与全栈开发不同的事情 <s>（主要是最近玩宝可梦玩的有点多）</s>。</p>
<p>这期的文章参考了 Imre Nazar 在 2010 年写的一系列关于<a target="_blank" rel="noopener" href="https://imrannazar.com/series/gameboy-emulation-in-javascript">用 JavaScript 实现 GameBoy 模拟器</a>的教程。虽然这个教程有些年头了，但还是提供了一个很好的起点和思路。自然，这期文章不会直接去 Ctrl C + V 他的实现，而是会使用更现代的 ES6 语法。</p>
<span id="more"></span>
<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>要模拟一台 GameBoy，我们至少需要模拟以下核心组件：</p>
<ul>
<li>CPU（Z80 兼容处理器），也就是“大脑”，负责执行游戏代码</li>
<li>内存管理单元（MMU），用于处理内存的读写，包括 ROM、RAM 和各种硬件寄存器</li>
<li>图形处理单元（PPU），负责渲染游戏画面</li>
<li>输入设备，处理用户按键操作</li>
<li>定时器，提供精确的时间控制</li>
<li>声音处理单元，生成游戏音效和音乐</li>
</ul>
<h1 id="1-模拟-z80-cpu"><a class="markdownIt-Anchor" href="#1-模拟-z80-cpu"></a> 1. 模拟 Z80 CPU</h1>
<p>GameBoy 的 CPU 是一个修改过的 Zilog Z80 处理器。要模拟它，就得理解它的工作方式。</p>
<p>核心概念很简单：取指 → 解码 → 执行循环。</p>
<ol>
<li>取指：从内存中获取下一条指令</li>
<li>解码：解析指令的含义</li>
<li>执行：执行指令指定的操作</li>
</ol>
<p>这个循环在 GameBoy 上电后就开始运行，直到关机。为了跟踪程序执行到哪里，CPU 会使用一个特殊的寄存器——程序计数器。每当一条指令被取出后，程序计数器就会根据指令的长度向前移动，指向下一条要执行的指令。</p>
<p>Z80 CPU 是一个 8 位芯片，意味着它一次可以处理一个字节的数据。它也能访问多达 6,5536 字节的内存空间，程序代码和普通数据都被存储在同一个内存地址空间中，而一条指令的长度可以在 1 到 3 个字节之间。</p>
<p>除了程序计数器，Z80 CPU 还有一组内存寄存器，用于存储数据和执行计算：</p>
<ul>
<li>8 位通用寄存器（A、B、C、D、E、H、L），每个可以存储一个字节（0 到 255）的值。大多数 Z80 指令都围绕着操作这些寄存器，例如将内存中的值加载到寄存器中，或者对寄存器中的值进行算术运算</li>
<li>标志寄存器（F）是一个特殊的 8 位寄存器，其中每个位都代表一个“标志”，用于存储上一次运算的结果状态</li>
<li>栈指针（SP）是一个 16 位寄存器，用于指向内存中的“栈顶”位置
<ul>
<li>栈是一种后进先出的数据结构</li>
</ul>
</li>
</ul>
<blockquote>
<p>CPU 是什么？（用大白话说）</p>
<p><strong>不要被“中央处理器”这个名字吓到。</strong></p>
<p>把 CPU 想象成一个超快的计算器工人：</p>
<ul>
<li>他有一张小纸条（寄存器），记录当前的数字</li>
<li>他有一本操作手册（指令集），告诉他怎么计算</li>
<li>他一次只能做一件事，但做得很快</li>
</ul>
<p>假设有一个指令是“把 A 和 B 加起来”，那么对于这个工人而言就是：</p>
<ol>
<li>看看 A 纸条（3）</li>
<li>看看 B 纸条（5）</li>
<li>算出结果（8）</li>
<li>写到 A 纸条上</li>
</ol>
<p><s>基本上就是一个只会加减乘除但超级勤快的员工</s></p>
</blockquote>
<p>基于以上理解，我们的 Z80 CPU 模拟器需要包含以下核心组件：</p>
<ul>
<li>内部状态，需要保存所有寄存器的当前值、执行上一条指令所花费的时间，以及 CPU 总共运行了多长时间</li>
<li>指令模拟函数</li>
<li>指令映射表</li>
<li>内存接口</li>
</ul>
<h2 id="11-cpu-骨架"><a class="markdownIt-Anchor" href="#11-cpu-骨架"></a> 1.1. CPU 骨架</h2>
<p>下面是我们 <code>GameBoyCPU</code> 类的初步骨架，包含了 CPU 的时钟系统和所有重要的寄存器：</p>
<pre><code class="language-javascript">/**
 * GameBoy Z80 CPU 类
 */
class GameBoyCPU &#123;
  constructor() &#123;
    // 时钟系统，跟踪 CPU 执行时间
    this.clock = &#123;
      m: 0, // 机器周期计数器（主时钟）
      t: 0, // 时钟周期计数器，用于精确计时
    &#125;;

    // CPU 寄存器组
    this.registers = &#123;
      // === 8位通用寄存器 ===
      a: 0, // 累加器，主要用于算术运算

      // BC寄存器对（可作为16位使用）
      b: 0,
      c: 0,

      // DE寄存器对（同上）
      d: 0,
      e: 0,

      // HL寄存器对（同上；常用作内存指针）
      h: 0, // 高位
      l: 0, // 低位

      f: 0, // 标志寄存器，存储运算结果的状态标志

      // === 16位专用寄存器 ===
      pc: 0, // 程序计数器，指向下一条要执行的指令
      sp: 0, // 栈指针，指向栈顶位置

      // === 指令执行时间记录 ===
      m: 0,
      t: 0,
    &#125;;
  &#125;
&#125;</code></pre>
<p>CPU 的时钟系统是用来精确跟踪模拟时间的，<code>m</code> 代表机器周期，<code>t</code> 代表时钟周期，两者之间存在固定关系。</p>
<h2 id="12-标志寄存器与基本指令"><a class="markdownIt-Anchor" href="#12-标志寄存器与基本指令"></a> 1.2. 标志寄存器与基本指令</h2>
<p>标志寄存器是 CPU 运算中一个非常关键的部分，它会根据上一条指令的执行结果自动设置某些位。在 GameBoy 的 Z80 CPU 中，有四个重要的标志位：</p>
<ul>
<li>零标志（<code>0x80</code>）：如果上一次运算的结果为 0，则设置此位</li>
<li>减法标志（<code>0x40</code>）：如果上一次运算是减法操作，则设置此位</li>
<li>半进位标志（<code>0x20</code>）：如果上一次运算在字节的低 4 位发生了溢出（即结果的第 3 位向第 4 位进位），则设置此位</li>
<li>进位标志（<code>0x10</code>）：如果上一次加法运算结果超过 255（8 位最大值），或者减法运算结果低于 0（发生借位），则设置此位</li>
</ul>
<blockquote>
<p>看不懂的话……</p>
<p>想象你刚做完一道数学题，你的大脑会自动记住一些“状态”：</p>
<ul>
<li>“咦，答案是 0？” → 零标志</li>
<li>“我刚才是在做减法吗？” → 减法标志</li>
<li>“有没有进位？” → 进位标志</li>
</ul>
<p>GameBoy 的 CPU 也是如此。每次计算完，它都会在标志寄存器里记下这些“感想”。</p>
<p>为什么需要这些标志？因为后面的指令可能会问：“上次计算结果是 0 吗？如果是的话，跳转到别的地方。”</p>
</blockquote>
<p>为了更好地管理这些标志位，我们首先定义一个常量对象 <code>CPU_FLAGS</code>：</p>
<pre><code class="language-javascript">/**
 * 标志位常量定义
 */
const CPU_FLAGS = &#123;
  ZERO: 0x80,
  OPERATION: 0x40,
  HALF_CARRY: 0x20,
  CARRY: 0x10,
&#125;;</code></pre>
<p>接着，我们为 <code>GameBoyCPU</code> 类添加 <code>reset</code>、<code>setFlag</code> 和 <code>getFlag</code> 方法：</p>
<ul>
<li><code>reset</code> 方法用于将 CPU 的所有寄存器和时钟状态复位到初始值，这对于模拟器启动或重新加载游戏非常有用</li>
<li><code>setFlag</code> 和 <code>getFlag</code> 则分别用于设置和检查标志位，方便我们根据运算结果来操作标志寄存器 <code>f</code></li>
</ul>
<pre><code class="language-javascript">// ... 之前的 constructor ...

/**
 * CPU 重置，将所有寄存器和时钟复位为初始状态
 */
reset() &#123;
  // 重置所有8位寄存器
  this.registers.a = 0;
  this.registers.b = 0;
  this.registers.c = 0;
  this.registers.d = 0;
  this.registers.e = 0;
  this.registers.h = 0;
  this.registers.l = 0;
  this.registers.f = 0;

  // 重置16位寄存器
  this.registers.pc = 0; // 程序从地址0开始执行
  this.registers.sp = 0;

  // 重置时钟
  this.clock.m = 0;
  this.clock.t = 0;

  console.log(&#x27;主人~ CPU 已重置到初始状态喵！&#x27;);
&#125;

/**
 * 设置标志位
 * @param &#123;number&#125; flag 要设置的标志位
 * @param &#123;boolean&#125; condition 是否设置该标志位
 */
setFlag(flag, condition) &#123;
  if（condition) &#123;
    this.registers.f |= flag; // 设置位：通过按位或操作将指定标志位设置为 1
  &#125; else &#123;
    // 否则就清除位：通过按位与操作与指定标志位的补码，将其设置为 0
    this.registers.f &amp;= ~flag;
  &#125;
&#125;

/**
 * 检查标志位是否设置
 * @param &#123;number&#125; flag 要检查的标志位
 */
getFlag(flag) &#123;
  return (this.registers.f &amp; flag) !== 0;
&#125;</code></pre>
<p>为了演示 CPU 如何执行指令并影响寄存器和标志位，我们来模拟几个基本的 Z80 指令：</p>
<ul>
<li>
<p><code>ADD A, E</code>（加法指令）：将寄存器 <code>e</code> 的值加到寄存器 <code>a</code> 中，结果存回 <code>a</code>。这个函数需要更新 <code>a</code> 寄存器的值，并根据结果设置零标志和进位标志。<br>
注意，我们将结果限制在 8 位范围内（<code>&amp;= 255</code>），并更新指令执行所花费的机器周期 <code>m</code> 和时钟周期 <code>t</code>。</p>
<pre><code class="language-javascript">/**
 * 将 E 寄存器的值加到 A 寄存器
 * 算术指令用：ADD A, E
 */
addRegisterE() &#123;
  this.registers.a += this.registers.e;

  // 清除所有标志位并准备设置新的
  this.registers.f = 0;

  // 检查零标志和进位标志
  this.setFlag(CPU_FLAGS.ZERO, !(this.registers.a &amp; 255)); // 结果为0则设置零标志
  this.setFlag(CPU_FLAGS.CARRY, this.registers.a &gt; 255);   // 结果溢出255则设置进位标志

  // 将结果限制为 8 位
  this.registers.a &amp;= 255;

  // 设置指令执行时间（1 机器周期，4 时钟周期)
  this.registers.m = 1;
  this.registers.t = 4;
&#125;</code></pre>
</li>
<li>
<p><code>CP A, B</code>（比较指令）：将寄存器 <code>a</code> 的值与寄存器 <code>b</code> 的值进行比较。这个指令实际上是执行 <code>a - b</code> 的操作，但不保存结果，只根据结果设置标志位。我们需要设置减法标志，并根据比较结果设置零标志（如果 <code>a == b</code>）和进位标志（如果 <code>a &lt; b</code>）。</p>
<pre><code class="language-javascript">/**
 * 比较 B 寄存器和 A 寄存器
 * 用于条件判断和循环控制：CP A, B
 */
compareRegisterB() &#123;
  // 创建 A 的副本并模拟 A - B
  let result = this.registers.a;
  result -= this.registers.b;

  // 设置减法标志
  this.registers.f = CPU_FLAGS.OPERATION;

  // 检查 A 是否等于 B（结果为 0）以及 A 是否小于 B（结果为负，产生借位）
  this.setFlag(CPU_FLAGS.ZERO, !(result &amp; 255)); // 结果为0则设置零标志
  this.setFlag(CPU_FLAGS.CARRY, result &lt; 0);     // 结果为负（下溢）则设置进位标志

  // 设置指令执行时间（1 机器周期，4 时钟周期)
  this.registers.m = 1;
  this.registers.t = 4;
&#125;</code></pre>
</li>
<li>
<p>NOP（无操作指令）：这个指令不做任何事情，仅仅消耗 CPU 周期，用来延时或指令对齐。</p>
<pre><code class="language-javascript">/**
 * 无操作指令，不执行任何操作只是浪费时间
 * 延时或指令对齐用：NOP
 */
noOperation() &#123;
  this.registers.m = 1;
  this.registers.t = 4;
&#125;</code></pre>
</li>
<li>
<p>最后弄个调试工具，要打印出当前所有寄存器的十六进制值、标志位的状态以及时钟技术。</p>
<pre><code class="language-javascript">/**
 * 获取当前 CPU 状态的字符串表示，用于调试
 */
getStatusString() &#123;
  const r = this.registers;
  return `CPU状态:
  寄存器: A=$&#123;r.a.toString(16).padStart(2,&#x27;0&#x27;)&#125; B=$&#123;r.b.toString(16).padStart(2,&#x27;0&#x27;)&#125; C=$&#123;r.c.toString(16).padStart(2,&#x27;0&#x27;)&#125;
          D=$&#123;r.d.toString(16).padStart(2,&#x27;0&#x27;)&#125; E=$&#123;r.e.toString(16).padStart(2,&#x27;0&#x27;)&#125; H=$&#123;r.h.toString(16).padStart(2,&#x27;0&#x27;)&#125; L=$&#123;r.l.toString(16).padStart(2,&#x27;0&#x27;)&#125;
  标志位: F=$&#123;r.f.toString(16).padStart(2,&#x27;0&#x27;)&#125; [Z:$&#123;this.getFlag(CPU_FLAGS.ZERO)?1:0&#125; N:$&#123;this.getFlag(CPU_FLAGS.OPERATION)?1:0&#125; H:$&#123;this.getFlag(CPU_FLAGS.HALF_CARRY)?1:0&#125; C:$&#123;this.getFlag(CPU_FLAGS.CARRY)?1:0&#125;]
  PC=$&#123;r.pc.toString(16).padStart(4,&#x27;0&#x27;)&#125; SP=$&#123;r.sp.toString(16).padStart(4,&#x27;0&#x27;)&#125;
  时钟: M=$&#123;this.clock.m&#125; T=$&#123;this.clock.t&#125;`;
&#125;</code></pre>
</li>
</ul>
<h2 id="13-完整指令集与执行循环"><a class="markdownIt-Anchor" href="#13-完整指令集与执行循环"></a> 1.3. 完整指令集与执行循环</h2>
<p>在前面我们实现了几个示例指令，但真正的 GameBoy CPU 需要支持完整的 Z80 指令集。现代模拟器的核心是建立一个高效的“取值 → 解码 → 执行”循环，这个循环每秒要执行数百万次。</p>
<pre><code class="language-javascript">/**
 * 指令时序常量（T 周期）
 */
const INSTRUCTION_TIMINGS = &#123;
  // 基础指令时序
  NOP: 4,              // 0x00: NOP
  LD_BC_nn: 12,        // 0x01: LD BC,nn
  LD_MEM_BC_A: 8,      // 0x02: LD (BC),A
  INC_BC: 8,           // 0x03: INC BC
  INC_B: 4,            // 0x04: INC B
  DEC_B: 4,            // 0x05: DEC B
  LD_B_n: 8,           // 0x06: LD B,n
  
  // 跳转指令
  JR_s8: 12,           // 0x18: JR s8
  JR_NZ_s8: 8,         // 0x20: JR NZ,s8 (8 if not taken, 12 if taken)
  JR_Z_s8: 8,          // 0x28: JR Z,s8
  
  // 算术指令
  ADD_A_r: 4,          // 0x80-0x87: ADD A,r
  SUB_r: 4,            // 0x90-0x97: SUB r
  AND_r: 4,            // 0xA0-0xA7: AND r
  CP_r: 4,             // 0xB8-0xBF: CP r
  
  // 其他
  HALT: 4,             // 0x76: HALT
  RET: 16,             // 0xC9: RET
&#125;;</code></pre>
<p>指令映射是现代模拟器的核心技术。我们创建了一个 256 元素的数组，每个元素对应一个操作码（opcode），直接指向对应的函数。这避免了复杂的 switch-case 语句，大幅提升执行效率：</p>
<pre><code class="language-javascript">/**
 * 构建指令映射表
 */
buildInstructionMap() &#123;
  const map = new Array(256);

  // 基础指令集
  map[0x00] = this.nop.bind(this);           // NOP
  map[0x01] = this.ld_bc_nn.bind(this);     // LD BC,nn
  map[0x02] = this.ld_mem_bc_a.bind(this);  // LD (BC),A
  map[0x03] = this.inc_bc.bind(this);       // INC BC
  map[0x04] = this.inc_b.bind(this);        // INC B
  map[0x05] = this.dec_b.bind(this);        // DEC B
  map[0x06] = this.ld_b_n.bind(this);       // LD B,n

  // 跳转指令
  map[0x18] = this.jr_s8.bind(this);        // JR s8
  map[0x20] = this.jr_nz_s8.bind(this);     // JR NZ,s8
  map[0x28] = this.jr_z_s8.bind(this);      // JR Z,s8

  // 算术指令 - ADD A,r（批量注册）
  for (let i = 0x80; i &lt;= 0x87; i++) &#123;
    map[i] = this.add_a_r.bind(this, i &amp; 0x07);
  &#125;

  // 比较指令 - CP r（批量注册）
  for (let i = 0xB8; i &lt;= 0xBF; i++) &#123;
    map[i] = this.cp_r.bind(this, i &amp; 0x07);
  &#125;

  // 填充未实现的指令
  for (let i = 0; i &lt; 256; i++) &#123;
    if (!map[i]) &#123;
      map[i] = this.unimplemented.bind(this, i);
    &#125;
  &#125;

  return map;
&#125;</code></pre>
<p>CPU 执行的核心是 <code>step()</code> 方法。每次调用它会执行一条指令，这个方法每秒会被调用数百万次：</p>
<pre><code class="language-javascript">/**
 * 执行单条指令
 */
step() &#123;
  if (this.halted || this.stopped) &#123;
    // CPU 处于暂停状态，只更新时钟
    this.registers.t = 4;
    this.registers.m = 1;
    this.updateClocks();
    return;
  &#125;

  if (!this.mmu) &#123;
    throw new Error(&#x27;CPU 未连接到 MMU&#x27;);
  &#125;

  try &#123;
    // 取指令：从 PC 指向的内存地址读取操作码
    const opcode = this.mmu.readByte(this.registers.pc);
    this.registers.pc = (this.registers.pc + 1) &amp; 0xFFFF;

    // 记录指令（用于调试）
    this.stats.lastInstruction = opcode;

    // 解码并执行：直接通过映射表调用对应函数
    this.instructionMap[opcode]();

    // 更新统计
    this.stats.instructionsExecuted++;
    this.stats.lastCycles = this.registers.t;
    this.stats.totalCycles += this.registers.t;

    // 更新时钟
    this.updateClocks();

  &#125; catch (error) &#123;
    console.error(`❌ CPU 执行错误 PC=0x$&#123;this.registers.pc.toString(16).padStart(4, &#x27;0&#x27;)&#125;:`, error);
    throw error;
  &#125;
&#125;</code></pre>
<p>为了简化指令实现，我们提供了一组辅助方法来处理常见的寄存器操作：</p>
<pre><code class="language-javascript">/**
 * 获取寄存器值（按编号）
 */
getRegisterValue(regNum) &#123;
  switch (regNum) &#123;
    case 0: return this.registers.b;
    case 1: return this.registers.c;
    case 2: return this.registers.d;
    case 3: return this.registers.e;
    case 4: return this.registers.h;
    case 5: return this.registers.l;
    case 6: return this.mmu.readByte(this.getHL()); // (HL)
    case 7: return this.registers.a;
    default: return 0;
  &#125;
&#125;

/**
 * 获取 16 位寄存器组合
 */
getBC() &#123; return (this.registers.b &lt;&lt; 8) | this.registers.c; &#125;
getDE() &#123; return (this.registers.d &lt;&lt; 8) | this.registers.e; &#125;
getHL() &#123; return (this.registers.h &lt;&lt; 8) | this.registers.l; &#125;

setBC(value) &#123;
  this.registers.b = (value &gt;&gt; 8) &amp; 0xFF;
  this.registers.c = value &amp; 0xFF;
&#125;</code></pre>
<h2 id="14-导出"><a class="markdownIt-Anchor" href="#14-导出"></a> 1.4. 导出</h2>
<p>在文件的最下方、<code>GameBoyCPU</code> 类的外部添加导出代码：</p>
<pre><code class="language-javascript">if (typeof module !== &#x27;undefined&#x27; &amp;&amp; module.exports) &#123;
  // Node.js 环境导出
  module.exports = &#123; GameBoyCPU, CPU_FLAGS, INSTRUCTION_TIMINGS &#125;;
&#125; else if (typeof window !== &#x27;undefined&#x27;) &#123;
  // 浏览器环境导出到全局对象
  window.GameBoyCPU = GameBoyCPU;
  window.CPU_FLAGS = CPU_FLAGS;
  window.INSTRUCTION_TIMINGS = INSTRUCTION_TIMINGS;
&#125;</code></pre>
<h1 id="2-模拟内存管理单元"><a class="markdownIt-Anchor" href="#2-模拟内存管理单元"></a> 2. 模拟内存管理单元</h1>
<p>我们的 GameBoy CPU 骨架虽然能够执行指令并管理内存寄存器，但是一个没有内存的 CPU 就跟一个没有书的图书馆差不多，光有管理员也没啥用。CPU 必需能够与外部内存交互，才能读取程序代码、存取数据，并与各种硬件组件通信。</p>
<p>这就是<strong>内存管理单元</strong>（MMU）的作用。MMU 负责管理 GameBoy 的整个 64KB 的地址空间，并将 CPU 的内存访问请求路由到正确的物理内存区域。</p>
<blockquote>
<p>为什么需要 MMU？（大白话+1）</p>
<p>想象你在管理一个大仓库，有多大呢？GameBoy 的 64KB 内存相当于有 65536 个格子，你的大仓库也有这 65536 个格子：</p>
<ul>
<li>有些格子放游戏程序（ROM）</li>
<li>有些格子放临时数据（RAM）</li>
<li>有些格子放图片数据（VRAM）</li>
<li>有些格子是控制按钮（I/O 寄存器）</li>
</ul>
<p>CPU 依然是那个工人。假设他想要 <code>0x8000</code> 地址的数据。</p>
<p>如果没有 MMU 的话，CPU 就得自己跑到 <code>0x8000</code> 格子、搞清楚这个格子到底存的是什么、自行处理各种复杂情况。</p>
<p>有了 MMU 的话，CPU 只需要说他要 <code>0x8000</code> 的数据，MMU 就会：</p>
<ol>
<li>“<code>0x8000</code> 是图片数据区域。”</li>
<li>“这个区域的数据在 VRAM 里。”</li>
<li>“给你！”</li>
</ol>
<p>这样看，MMU 就像是一个很靠谱的仓库管理员。</p>
</blockquote>
<h2 id="21-gameboy-内存映射"><a class="markdownIt-Anchor" href="#21-gameboy-内存映射"></a> 2.1. GameBoy 内存映射</h2>
<p>与现代计算机复杂的内存管理不同，GameBoy 的内存映射相对直观，但仍然包含了多个不同功能的区域。理解这个内存映射对于正确模拟 GameBoy 至关重要。</p>
<p>GameBoy 的 64KB 地址空间被划分为以下主要区域：</p>
<ul>
<li><code>0x0000 - 0x3FFF</code>：卡带 ROM 银行 0<br>
这是游戏卡带程序的第一个 16KB 区域，始终可访问。
<ul>
<li><code>0x0000 - 0x00FF</code>：BIOS：GameBoy 启动时，CPU 从 <code>0x0000</code> 地址开始执行 BIOS 代码。一旦 BIOS 运行完毕，这片区域就会被卡带 ROM 覆盖，不再可访问。</li>
<li><code>0x0100 - 0x014F</code>：卡带头部：这部分包含游戏的名称、制造商、ROM/RAM 大小等关键信息。</li>
</ul>
</li>
<li><code>0x4000 - 0x7FFF</code>：卡带 ROM 其他银行<br>
对于大于 32KB 的游戏，卡带会包含多个 16KB 的 ROM 银行。MMU 需要通过<strong>内存银行控制器</strong>（MBC）来切换这些银行，以便 CPU 能够访问整个游戏程序。对于 32KB 或更小的游戏，这个区域也直接是 ROM 的一部分，无需银行切换。</li>
<li><code>0x8000 - 0x9FFF</code>：视频 RAM<br>
存储用于渲染游戏背景和精灵图形数据。这部分内存对 CPU 可读写，但主要由图形处理单元（GPU）使用。</li>
<li><code>0xA000 - 0xBFFF</code>：卡带外部 RAM<br>
部分游戏卡带会包含额外的可读写内存，用于保存游戏进度或临时数据。</li>
<li><code>0xC000 - 0xDFFF</code>：工作 RAM<br>
这是 GameBoy 内部的主工作内存，CPU 可以自由读写，用于存储程序变量、栈等。</li>
<li><code>0xE000 - 0xFDFF</code>：工作 RAM 镜像<br>
由于硬件接线的设计，工作 RAM 在内存映射中有一个完全相同的镜像区域。这意味着对 <code>0xE000-0xFDFF</code> 的读写实际上是对 <code>0xC000-0xDFFF</code> 的读写。</li>
<li><code>0xFE00 - 0xFE9F</code>：精灵属性表<br>
存储屏幕上所有精灵（例如角色、敌人）的位置、大小、图形数据索引等属性信息。</li>
<li><code>0xFF00 - 0xFF7F</code>：内存映射 I/O 寄存器<br>
这个区域包含了控制 GameBoy 各个硬件子系统（如图形、声音、定时器、输入）的寄存器。CPU 通过读写这些地址来控制硬件行为。</li>
<li><code>0xFF80 - 0xFFFF</code>：零页 RAM<br>
又称“高速 RAM”，这片区域是 GameBoy 最顶部的内存，CPU 访问它们的速度最快。虽然地址很高，但因其在汇编编程中的常用性，常被称为“零页”。</li>
</ul>
<blockquote>
<p>太复杂了看不懂、一图胜千言版本：</p>
<p>GameBoy 的 64KB 内存就像一栋 8 层楼的公寓：</p>
<p>🏢 GameBoy 内存公寓（64KB）<br>
├── 8 楼（<code>0xFF00-0xFFFF</code>）控制中心（按钮、音量调节等）<br>
├── 7 楼（<code>0xFE00-0xFEFF</code>）精灵属性（角色信息）<br>
├── 6 楼（<code>0xE000-0xFDFF</code>）工作区镜像（楼下的复印件）<br>
├── 5 楼（<code>0xC000-0xDFFF</code>）工作区（临时文件柜）<br>
├── 4 楼（<code>0xA000-0xBFFF</code>）卡带存档（游戏进度）<br>
├── 3 楼（<code>0x8000-0x9FFF</code>）图片仓库（所有图像数据）<br>
├── 2 楼（<code>0x4000-0x7FFF</code>）游戏程序（第 2 部分）<br>
└── 1 楼（<code>0x0000-0x3FFF</code>）游戏程序（第 1 部分）<br>
└── 地下室（<code>0x0000-0x00FF</code>）开机程序（BIOS）</p>
<p>每次 CPU 说他想要 <code>0x8000</code> 的数据，MMU 就知道：“哦，你要 3 楼图片仓库的东西。”</p>
</blockquote>
<p>为了在代码中清晰地表示这些区域，我们定义一个 <code>MEMORY_REGIONS</code> 常量对象：</p>
<pre><code class="language-javascript">/**
 * 内存区域常量定义
 */
const MEMORY_REGIONS = &#123;
  // ROM 区域
  ROM_BANK_0_START: 0x0000,
  ROM_BANK_0_END: 0x3FFF,
  ROM_BANK_1_START: 0x4000,
  ROM_BANK_1_END: 0x7FFF,

  // BIOS 区域（在 ROM 银行 0 内）
  BIOS_START: 0x0000,
  BIOS_END: 0x00FF,
  BIOS_EXIT_POINT: 0x0100,

  // 卡带头部（在 ROM 银行 0 内）
  CARTRIDGE_HEADER_START: 0x0100,
  CARTRIDGE_HEADER_END: 0x014F,

  // 视频 RAM
  VRAM_START: 0x8000,
  VRAM_END: 0x9FFF,
  VRAM_SIZE: 0x2000, // 8KB

  // 外部 RAM
  ERAM_START: 0xA000,
  ERAM_END: 0xBFFF,
  ERAM_SIZE: 0x2000, // 8KB

  // 工作 RAM
  WRAM_START: 0xC000,
  WRAM_END: 0xDFFF,
  WRAM_SIZE: 0x2000, // 8KB

  // 工作 RAM 镜像
  WRAM_SHADOW_START: 0xE000,
  WRAM_SHADOW_END: 0xFDFF,

  // 精灵属性内存
  OAM_START: 0xFE00,
  OAM_END: 0xFE9F,
  OAM_SIZE: 0xA0, // 160 字节

  // I/O 寄存器
  IO_START: 0xFF00,
  IO_END: 0xFF7F,

  // 零页 RAM
  ZRAM_START: 0xFF80,
  ZRAM_END: 0xFFFF,
  ZRAM_SIZE: 0x80 // 128 字节
&#125;;</code></pre>
<h2 id="22-mmu-类结构与初始化"><a class="markdownIt-Anchor" href="#22-mmu-类结构与初始化"></a> 2.2. MMU 类结构与初始化</h2>
<p>我们的 <code>GameBoyMMU</code> 类会负责创建和管理这些内存区域的实际存储（用 <code>Unit8Array</code>），并提供读写内存的接口。</p>
<p>在构造函数里，首先要调用 <code>initializeMemoryRegions</code> 来分配各个内存区域的存储空间，然后调用 <code>reset</code> 方法将它们清空并设置初始状态。</p>
<pre><code class="language-javascript">/**
 * GameBoy 内存管理单元类
 */
class GameBoyMMU &#123;
  constructor() &#123;
    this.initializeMemoryRegions();
    this.reset();
  &#125;

  /**
   * 初始化所有内存区域
   */
  initializeMemoryRegions() &#123;
    // BIOS 数据（256 字节），GameBoy 启动代码
    this.bios = new Uint8Array(256);
    
    // 卡带 ROM 数据（最大 32KB 基础 ROM）
    this.rom = new Uint8Array(0x8000); // 32KB 初始空间
    
    // 视频 RAM（8KB），存储背景和精灵图形数据
    this.vram = new Uint8Array(MEMORY_REGIONS.VRAM_SIZE);
    
    // 外部 RAM（8KB），卡带上的额外可写内存
    this.eram = new Uint8Array(MEMORY_REGIONS.ERAM_SIZE);
    
    // 工作 RAM（8KB），GameBoy 内部 RAM
    this.wram = new Uint8Array(MEMORY_REGIONS.WRAM_SIZE);
    
    // 零页 RAM（128 字节），高速访问内存
    this.zram = new Uint8Array(MEMORY_REGIONS.ZRAM_SIZE);
    
    // 精灵属性内存（160 字节），存储精灵位置和属性
    this.oam = new Uint8Array(MEMORY_REGIONS.OAM_SIZE);
    
    // I/O 寄存器映射（128 字节），硬件控制寄存器
    this.ioRegisters = new Uint8Array(0x80);
  &#125;

  /**
   * 重置 MMU 到初始状态
   */
  reset() &#123;
    // BIOS 映射标志，控制是否显示 BIOS 区域
    this.biosEnabled = true;
    
    // 清空所有可写内存区域
    this.vram.fill(0);
    this.eram.fill(0);
    this.wram.fill(0);
    this.zram.fill(0);
    this.oam.fill(0);
    this.ioRegisters.fill(0);
    
    console.log(&#x27;MMU 已重置到初始状态&#x27;);
  &#125;
&#125;</code></pre>
<h2 id="23-内存读取"><a class="markdownIt-Anchor" href="#23-内存读取"></a> 2.3. 内存读取</h2>
<p>MMU 最核心的功能就是根据 CPU 请求的地址，将其路由到正确的内存区域并返回数据。<code>readByte(address)</code> 方法实现了这一逻辑：它根据 16 位地址的不同范围，返回对应 <code>Uint8Array</code> 中的字节。</p>
<p>这里需要特别注意 BIOS 区域的逻辑：当 CPU 程序计数器 <code>PC</code> 达到 <code>0x0100</code> 时，表明 BIOS 已经执行完毕，此时我们会禁用 BIOS 映射（<code>this.biosEnabled = false;</code>），让该地址范围（<code>0x0000-0x00FF</code>）切换到显示卡带 ROM。</p>
<pre><code class="language-javascript">// ... 之前写的方法 ...

/**
 * 从指定地址读取 8 位字节
 * 根据地址范围路由到相应的内存区域
 * @param &#123;number&#125; address 16 位内存地址（0x0000-0xFFFF）
 * @returns &#123;number&#125; 8 位数据值（0x00-0xFF）
 */
readByte(address) &#123;
  // 确保地址在 16 位范围内
  address &amp;= 0xFFFF;

  // 根据地址高 4 位进行初步分类，提升性能
  switch (address &amp; 0xF000) &#123;
    // 0x0000-0x0FFF: BIOS/ROM 银行 0 区域
    case 0x0000: &#123;
      // 检查是否在 BIOS 区域且 BIOS 已启用
      if (this.biosEnabled &amp;&amp; address &lt; MEMORY_REGIONS.BIOS_EXIT_POINT) &#123;
        return this.bios[address];
      &#125;

      // BIOS 退出检查：当 PC 到达 0x0100 时禁用 BIOS
      // TODO: 这里依赖于全局的 cpu 实例，后续可以考虑通过依赖注入优化
      if (address === MEMORY_REGIONS.BIOS_EXIT_POINT &amp;&amp; window.cpu?.registers?.pc === MEMORY_REGIONS.BIOS_EXIT_POINT) &#123;
        this.biosEnabled = false;
        console.log(&#x27;BIOS已退出，切换到卡带ROM&#x27;);
      &#125;

      return this.rom[address]; // 否则读取 ROM
    &#125;

    // 0x1000-0x3FFF: ROM 银行 0 的其余部分
    case 0x1000:
    case 0x2000:
    case 0x3000:
      return this.rom[address];

    // 0x4000-0x7FFF: ROM 银行 1（可切换） - 基础模拟中直接从 rom 读取
    case 0x4000:
    case 0x5000:
    case 0x6000:
    case 0x7000:
      return this.rom[address];

    // 0x8000-0x9FFF: 视频 RAM
    case 0x8000:
    case 0x9000:
      return this.vram[address &amp; 0x1FFF]; // 限制在 8KB（0x2000）范围内

    // 0xA000-0xBFFF: 外部 RAM
    case 0xA000:
    case 0xB000:
      return this.eram[address &amp; 0x1FFF]; // 限制在 8KB 范围内

    // 0xC000-0xDFFF: 工作 RAM
    case 0xC000:
    case 0xD000:
      return this.wram[address &amp; 0x1FFF]; // 限制在 8KB 范围内

    // 0xE000-0xEFFF: 工作 RAM 镜像
    case 0xE000:
      return this.wram[address &amp; 0x1FFF]; // 映射到工作 RAM

    // 0xF000-0xFFFF: 复杂区域 - 包含 RAM 镜像、OAM、I/O、零页 RAM
    case 0xF000:
      return this.readHighMemoryRegion(address); // 调用辅助函数处理高地址区域

    default:
      console.warn(`未处理的内存读取地址: 0x$&#123;address.toString(16).padStart(4, &#x27;0&#x27;)&#125;`);
      return 0xFF; // 返回未连接总线的典型值（全1）
  &#125;
&#125;

/**
 * 处理高内存区域的读取（0xF000-0xFFFF）
 * 这个区域包含多个不同的内存映射，需要进一步细分
 * @param &#123;number&#125; address 内存地址
 * @returns &#123;number&#125; 读取的数据
 */
readHighMemoryRegion(address) &#123;
  // 根据地址的中间 4 位进一步分类
  switch (address &amp; 0x0F00) &#123;
    // 0xF000-0xFDFF: 工作 RAM 镜像的剩余部分
    case 0x000: case 0x100: case 0x200: case 0x300:
    case 0x400: case 0x500: case 0x600: case 0x700:
    case 0x800: case 0x900: case 0xA00: case 0xB00:
    case 0xC00: case 0xD00:
      return this.wram[address &amp; 0x1FFF];

    // 0xFE00-0xFEFF: 精灵属性内存区域（OAM）
    case 0xE00:
      if (address &lt; 0xFEA0) &#123;
        // 有效的 OAM 区域（0xFE00-0xFE9F）
        return this.oam[address &amp; 0xFF]; // 限制在 160 字节（0xA0）范围内
      &#125; else &#123;
        // 0xFEA0-0xFEFF: 未使用区域，读取通常返回 0 或 0xFF，这里统一返回 0
        return 0;
      &#125;

    // 0xFF00-0xFFFF: I/O 寄存器和零页 RAM
    case 0xF00:
      if (address &gt;= MEMORY_REGIONS.ZRAM_START) &#123;
        // 0xFF80-0xFFFF: 零页 RAM
        return this.zram[address &amp; 0x7F]; // 限制在 128 字节（0x80）范围内
      &#125; else &#123;
        // 0xFF00-0xFF7F: I/O 寄存器
        return this.readIORegister(address); // 调用辅助函数处理 I/O 寄存器读取
      &#125;

    default:
      return 0xFF; // 未知区域返回 0xFF
  &#125;
&#125;

/**
 * 读取 I/O 寄存器
 * 这些寄存器控制 GameBoy 的各个硬件子系统。
 * TODO: 目前只是返回其在内部数组中的值，具体硬件逻辑将在后续章节实现。
 * @param &#123;number&#125; address I/O 寄存器地址（0xFF00-0xFF7F）
 * @returns &#123;number&#125; 寄存器值
 */
readIORegister(address) &#123;
  const registerIndex = address - MEMORY_REGIONS.IO_START;
  // 返回 I/O 寄存器数组中的值，如果超出范围则返回 0（或 0xFF）
  return this.ioRegisters[registerIndex] || 0;
&#125;

/**
 * 从指定地址读取 16 位字（小端序 - Little Endian）
 * GameBoy CPU 使用小端序存储多字节数据，即低位字节在前。
 * @param &#123;number&#125; address 起始地址
 * @returns &#123;number&#125; 16位值
 */
readWord(address) &#123;
  const lowByte = this.readByte(address);
  const highByte = this.readByte(address + 1);
  return lowByte | (highByte &lt;&lt; 8); // 将高位字节左移 8 位后与低位字节合并
&#125;</code></pre>
<h2 id="24-内存写入"><a class="markdownIt-Anchor" href="#24-内存写入"></a> 2.4. 内存写入</h2>
<p>内存写入的逻辑与读取类似，<code>writeByte(address, value)</code> 方法根据地址将数据写入对应的内存区域。需要注意的是，ROM 区域通常是只读的，任何写入操作都会被忽略（除了用于内存银行切换的特殊地址，这将在后面讨论）。</p>
<pre><code class="language-javascript">// ... 之前写的方法 ...

/**
 * 向指定地址写入 8 位字节
 * 根据地址范围路由到相应的内存区域
 * @param &#123;number&#125; address 16 位内存地址
 * @param &#123;number&#125; value 8 位数据值
 */
writeByte(address, value) &#123;
  // 确保地址和值在有效范围内
  address &amp;= 0xFFFF;
  value &amp;= 0xFF;

  // 根据地址高 4 位进行分类
  switch (address &amp; 0xF000) &#123;
    // 0x0000-0x7FFF: ROM 区域 - 通常只读，但可能有银行切换逻辑
    case 0x0000: case 0x1000: case 0x2000: case 0x3000:
    case 0x4000: case 0x5000: case 0x6000: case 0x7000:
      this.handleROMWrite(address, value); // 专门处理 ROM 区域的写入
      break;

    // 0x8000-0x9FFF: 视频 RAM - 可写
    case 0x8000:
    case 0x9000:
      this.vram[address &amp; 0x1FFF] = value;
      break;

    // 0xA000-0xBFFF: 外部 RAM - 可写
    case 0xA000:
    case 0xB000:
      this.eram[address &amp; 0x1FFF] = value;
      break;

    // 0xC000-0xDFFF: 工作 RAM - 可写
    case 0xC000:
    case 0xD000:
      this.wram[address &amp; 0x1FFF] = value;
      break;

    // 0xE000-0xEFFF: 工作 RAM 镜像 - 写入映射到工作 RAM
    case 0xE000:
      this.wram[address &amp; 0x1FFF] = value;
      break;

    // 0xF000-0xFFFF: 高内存区域
    case 0xF000:
      this.writeHighMemoryRegion(address, value); // 调用辅助函数处理高地址区域写入
      break;

    default:
      console.warn(`未处理的内存写入地址: 0x$&#123;address.toString(16).padStart(4, &#x27;0&#x27;)&#125;`);
  &#125;
&#125;

/**
 * 处理 ROM 区域的写入
 * ROM 通常是只读的。在基础模拟中，任何对 ROM 区域的写入都会被忽略。
 * TODO: 在未来的内存银行章节中，这里将包含处理卡带内存银行控制器的逻辑。
 * @param &#123;number&#125; address 地址
 * @param &#123;number&#125; value 值
 */
handleROMWrite(address, value) &#123;
  console.log(`ROM写入被忽略: 地址=0x$&#123;address.toString(16).padStart(4, &#x27;0&#x27;)&#125;, 值=0x$&#123;value.toString(16).padStart(2, &#x27;0&#x27;)&#125;`);
&#125;

/**
 * 处理高内存区域的写入（0xF000-0xFFFF）
 * @param &#123;number&#125; address 地址
 * @param &#123;number&#125; value 值
 */
writeHighMemoryRegion(address, value) &#123;
  switch (address &amp; 0x0F00) &#123;
    // 0xF000-0xFDFF: 工作 RAM 镜像 - 写入映射到工作 RAM
    case 0x000: case 0x100: case 0x200: case 0x300:
    case 0x400: case 0x500: case 0x600: case 0x700:
    case 0x800: case 0x900: case 0xA00: case 0xB00:
    case 0xC00: case 0xD00:
      this.wram[address &amp; 0x1FFF] = value;
      break;

    // 0xFE00-0xFEFF: 精灵属性内存（OAM）
    case 0xE00:
      if (address &lt; 0xFEA0) &#123;
        this.oam[address &amp; 0xFF] = value;
      &#125;
      // 0xFEA0-0xFEFF 区域的写入通常被忽略
      break;

    // 0xFF00-0xFFFF: I/O 寄存器和零页 RAM
    case 0xF00:
      if (address &gt;= MEMORY_REGIONS.ZRAM_START) &#123;
        // 零页 RAM
        this.zram[address &amp; 0x7F] = value;
      &#125; else &#123;
        // I/O 寄存器
        this.writeIORegister(address, value);
      &#125;
      break;
  &#125;
&#125;

/**
 * 写入 I/O 寄存器
 * @param &#123;number&#125; address I/O 寄存器地址
 * @param &#123;number&#125; value 要写入的值
 */
writeIORegister(address, value) &#123;
  const registerIndex = address - MEMORY_REGIONS.IO_START;
  this.ioRegisters[registerIndex] = value;

  // TODO: 在后续章节中，这里将处理特定 I/O 寄存器写入的副作用
  // 例如：当写入显示控制寄存器时触发屏幕更新，或写入声音寄存器时播放声音
&#125;

/**
 * 向指定地址写入 16 位字（小端序）
 * @param &#123;number&#125; address 起始地址
 * @param &#123;number&#125; value 16 位值
 */
writeWord(address, value) &#123;
  this.writeByte(address, value &amp; 0xFF);            // 写入低位字节
  this.writeByte(address + 1, (value &gt;&gt; 8) &amp; 0xFF); // 写入高位字节
&#125;</code></pre>
<h2 id="25-加载-rom-与-bios"><a class="markdownIt-Anchor" href="#25-加载-rom-与-bios"></a> 2.5. 加载 ROM 与 BIOS</h2>
<p>为了让模拟器能够运行游戏，MMU 还需要加载 BIOS 和游戏 ROM 的功能：</p>
<ul>
<li><code>loadBIOS(biosData)</code>: 加载 GameBoy 的 BIOS 文件
<ul>
<li>BIOS 是启动时运行的一小段程序，通常用于初始化硬件和显示任天堂的标志</li>
</ul>
</li>
<li><code>loadROM(romData)</code>: 加载游戏卡带的 ROM 数据。这个方法会将 ROM 数据复制到 MMU 内部的 <code>this.rom</code> 数组中</li>
<li><code>loadROMFromURL(url)</code>: 直接从给定的 URL 下载 ROM 文件并加载</li>
</ul>
<p><code>displayCartridgeInfo()</code> 方法则会从 ROM 的卡带头部读取并打印出游戏的标题、类型、ROM 大小和 RAM 大小等信息，这对于验证 ROM 是否正确加载非常有用。</p>
<pre><code class="language-javascript">// ... 之前写的方法 ...

/**
 * 加载 BIOS 数据
 * @param &#123;Uint8Array|Array&#125; biosData BIOS 数据数组（应为 256 字节）
 */
loadBIOS(biosData) &#123;
  if (biosData.length !== 256) &#123;
    throw new Error(&#x27;BIOS 数据必须正好是 256 字节&#x27;);
  &#125;

  this.bios.set(biosData); // 将传入的 BIOS 数据复制到内部存储
  this.biosEnabled = true; // 确保 BIOS 映射处于启用状态
  console.log(&#x27;BIOS 已加载&#x27;);
&#125;

/**
 * 加载 ROM 文件
 * @param &#123;Uint8Array|ArrayBuffer&#125; romData ROM 数据
 */
loadROM(romData) &#123;
  // 转换为 Uint8Array（如果传入的是 ArrayBuffer）
  const rom = romData instanceof ArrayBuffer ? new Uint8Array(romData) : romData;

  // 确保 ROM 不超过 MMU 分配的最大支持大小
  const maxSize = this.rom.length;
  if (rom.length &gt; maxSize) &#123;
    console.warn(`ROM 大小 $&#123;rom.length&#125; 字节超过最大支持大小 $&#123;maxSize&#125; 字节，将被截断`);
  &#125;

  // 复制 ROM 数据到内部存储，只复制有效部分
  const copySize = Math.min(rom.length, maxSize);
  this.rom.set(rom.slice(0, copySize));

  console.log(`ROM 已加载，大小: $&#123;copySize&#125; 字节`);

  // 显示卡带信息，验证 ROM 是否加载正确
  this.displayCartridgeInfo();
&#125;

/**
 * 显示卡带头部信息
 * 从 ROM 的特定地址读取游戏元数据
 */
displayCartridgeInfo() &#123;
  // 读取卡带标题（0x0134-0x0143）
  let title = &#x27;&#x27;;
  for (let i = 0x0134; i &lt;= 0x0143; i++) &#123;
    const char = this.rom[i];
    if (char === 0) break; // 标题以空字符结束
    title += String.fromCharCode(char);
  &#125;

  // 读取卡带类型（0x0147）
  const cartridgeType = this.rom[0x0147];

  // 读取 ROM 大小（0x0148）
  const romSizeCode = this.rom[0x0148];
  // 根据 GameBoy 规范计算 ROM 实际大小，32KB * (2^romSizeCode)
  const romSize = 32 * (1 &lt;&lt; romSizeCode); // KB

  // 读取 RAM 大小（0x0149）
  const ramSizeCode = this.rom[0x0149];
  // 根据 GameBoy 规范定义 RAM 大小映射
  const ramSizes = [0, 2, 8, 32, 128, 64]; // KB
  const ramSize = ramSizes[ramSizeCode] || 0; // 处理未知编码

  console.log(&#x27;=== 卡带信息 ===&#x27;);
  console.log(`标题: $&#123;title&#125;`);
  console.log(`卡带类型: 0x$&#123;cartridgeType.toString(16).padStart(2, &#x27;0&#x27;)&#125;`);
  console.log(`ROM 大小: $&#123;romSize&#125;KB`);
  console.log(`RAM 大小: $&#123;ramSize&#125;KB`);
&#125;

/**
 * 异步加载 ROM 文件（从 URL）
 * @param &#123;string&#125; url ROM 文件 URL
 */
async loadROMFromURL(url) &#123;
  try &#123;
    console.log(`正在加载ROM: $&#123;url&#125;`);
    const response = await fetch(url); // 发起网络请求

    if (!response.ok) &#123;
      throw new Error(`HTTP错误: $&#123;response.status&#125;`);
    &#125;

    const romData = await response.arrayBuffer(); // 获取二进制数据
    this.loadROM(romData); // 调用 loadROM 进行处理
  &#125; catch (error) &#123;
    console.error(&#x27;ROM加载失败:&#x27;, error);
    throw error; // 重新抛出错误以便外部捕获
  &#125;
&#125;

/**
 * 获取内存使用情况统计（用于调试）
 * @returns &#123;Object&#125; 内存使用统计对象
 */
getMemoryStats() &#123;
  return &#123;
    biosEnabled: this.biosEnabled,
    romLoaded: this.rom.some(byte =&gt; byte !== 0), // 检查 ROM 是否包含数据
    memoryRegions: &#123;
      bios: &#123; size: this.bios.length, used: this.bios.some(byte =&gt; byte !== 0) &#125;,
      rom: &#123; size: this.rom.length, used: this.rom.some(byte =&gt; byte !== 0) &#125;,
      vram: &#123; size: this.vram.length, used: this.vram.some(byte =&gt; byte !== 0) &#125;,
      eram: &#123; size: this.eram.length, used: this.eram.some(byte =&gt; byte !== 0) &#125;,
      wram: &#123; size: this.wram.length, used: this.wram.some(byte =&gt; byte !== 0) &#125;,
      zram: &#123; size: this.zram.length, used: this.zram.some(byte =&gt; byte !== 0) &#125;,
      oam: &#123; size: this.oam.length, used: this.oam.some(byte =&gt; byte !== 0) &#125;
    &#125;
  &#125;;
&#125;

/**
 * 获取内存转储（用于调试）
 * 以十六进制和 ASCII 形式显示内存内容
 * @param &#123;number&#125; startAddr 起始地址
 * @param &#123;number&#125; length 要转储的长度
 * @returns &#123;string&#125; 十六进制转储字符串
 */
getMemoryDump(startAddr, length = 256) &#123;
  let dump = `内存转储 (0x$&#123;startAddr.toString(16).padStart(4, &#x27;0&#x27;)&#125; - 0x$&#123;(startAddr + length - 1).toString(16).padStart(4, &#x27;0&#x27;)&#125;):\n`;

  // 每行显示 16 个字节
  for (let i = 0; i &lt; length; i += 16) &#123;
    const addr = startAddr + i;
    let line = `$&#123;addr.toString(16).padStart(4, &#x27;0&#x27;)&#125;: `; // 地址部分
    let ascii = &#x27;&#x27;; // ASCII 可视化部分

    for (let j = 0; j &lt; 16 &amp;&amp; (i + j) &lt; length; j++) &#123;
      const byte = this.readByte(addr + j);
      line += `$&#123;byte.toString(16).padStart(2, &#x27;0&#x27;)&#125; `; // 十六进制字节
      // 将可打印字符转换为 ASCII，否则显示 &#x27;.&#x27;
      ascii += (byte &gt;= 32 &amp;&amp; byte &lt;= 126) ? String.fromCharCode(byte) : &#x27;.&#x27;;
    &#125;

    line = line.padEnd(50, &#x27; &#x27;) + ascii; // 填充空格对齐
    dump += line + &#x27;\n&#x27;;
  &#125;

  return dump;
&#125;</code></pre>
<h2 id="26-mmu-与-cpu-的连接"><a class="markdownIt-Anchor" href="#26-mmu-与-cpu-的连接"></a> 2.6. MMU 与 CPU 的连接</h2>
<p>现在我们有了 <code>GameBoyCPU</code> 和 <code>GameBoyMMU</code> 两个类。CPU 需要一个方式来与 MMU 交互，才能真正实现“取指”和“读写内存”的功能。最简单的方式就是将 MMU 实例作为参数传递给 CPU，或者让 CPU 拥有一个 MMU 的引用。</p>
<p>不过也别忘了在 <code>mmu.js</code> 中导出 <code>GameBoyMMU</code> 类和常量：</p>
<pre><code class="language-javascript">if (typeof module !== &#x27;undefined&#x27; &amp;&amp; module.exports) &#123;
  // Node.js 环境导出
  module.exports = &#123; GameBoyMMU, MEMORY_REGIONS &#125;;
&#125; else if (typeof window !== &#x27;undefined&#x27;) &#123;
  // 浏览器环境导出到全局对象
  window.GameBoyMMU = GameBoyMMU;
  window.MEMORY_REGIONS = MEMORY_REGIONS;
&#125;</code></pre>
<p>然后在 <code>GameBoyCPU</code> 类中，我们可以添加一个对 MMU 的引用：</p>
<pre><code class="language-javascript">class GameBoyCPU &#123;
  constructor(mmu) &#123; // 接收 MMU 实例
    this.mmu = mmu; // 存储 MMU 引用
    // ... 其他寄存器和时钟初始化 ...
  &#125;

  // 示例：实现一个 LD A, (HL) 指令
  // 将 HL 寄存器指向的内存地址的值加载到 A 寄存器
  loadAToHL() &#123;
    const address = (this.registers.h &lt;&lt; 8) | this.registers.l; // 合并 H 和 L 得到 16 位地址
    this.registers.a = this.mmu.readByte(address); // 通过 MMU 读取内存
    this.registers.m = 2; // 假设这条指令需要 2 机器周期
    this.registers.t = 8; // 假设这条指令需要 8 时钟周期
  &#125;
  // ... 其他指令和方法 ...
&#125;</code></pre>
<p>这样，CPU 就可以通过 <code>this.mmu.readByte()</code>、<code>this.mmu.writeByte()</code> 等方法来访问内存了。</p>
<h1 id="3-gpu-时序让-gameboy-屏幕动起来"><a class="markdownIt-Anchor" href="#3-gpu-时序让-gameboy-屏幕动起来"></a> 3. GPU 时序：让 GameBoy 屏幕动起来</h1>
<p>先前我们已经构建了 GameBoy 模拟器的 CPU 骨架和 MMU，让模拟器能够加载游戏 ROM 并开始执行指令。但是一个没有图像输出的模拟器是没有灵魂的！现在我们得引入 GameBoy 的主要输出设备——<strong>图形处理单元</strong>也就是我们经常说到的 GPU 了。</p>
<p>GameBoy 的官方内部名称是“点阵式游戏机”（Dot Matrix Game），这是因为它靠着一块 160x144 像素的单色 LCD 屏幕来显示内容。为了模拟这个屏幕，我们可以在 Web 页面中使用一个 HTML5 <code>&lt;canvas&gt;</code> 元素。这个 Canvas 将作为我们的“帧缓冲区”，其中每个像素的颜色都可以被直接操作。</p>
<h2 id="31-模拟屏幕与帧缓冲区"><a class="markdownIt-Anchor" href="#31-模拟屏幕与帧缓冲区"></a> 3.1. 模拟屏幕与帧缓冲区</h2>
<p>要将 GameBoy 的图形输出呈现在网页上，最直接的方法就是创建一个与 GameBoy 屏幕尺寸相同的 Canvas。我们可以通过 Canvas 的 2D 渲染上下文来操作它的像素数据。</p>
<p>GameBoy 的显示分辨率是 160 像素宽和 140 像素高。Canvas 的像素数据通常以 RGBA（红、绿、蓝、透明度）的 4 字节序列存储。这意味着每个像素需要 4 个字节来表示其颜色。我们可以通过 <code>getImageData</code> 或 <code>createImageData</code> 方法获取或创建这个帧缓冲区。</p>
<p>首先，在 HTML 文件中添加一个 Canvas 元素：</p>
<pre><code class="language-html">&lt;canvas id=&quot;gameboy-screen&quot; width=&quot;160&quot; height=&quot;144&quot;&gt;&lt;/canvas&gt;</code></pre>
<p>在 <code>GameBoyGPU</code> 类中，我们将负责初始化这个 Canvas 并创建帧缓冲区。我们还设置了 <code>imageSmoothingEnabled = false</code> 和 <code>image-rendering: pixelated</code> 样式，以确保图像在放大时保持像素艺术的清晰度，而不是变得模糊。</p>
<pre><code class="language-javascript">// ... 其他常量定义，之后写 ...

/**
 * GameBoy GPU 类
 * 负责管理显示时序、渲染管线和帧缓冲区
 */
class GameBoyGPU &#123;
  constructor() &#123;
    this.initializeTimingState();
    this.initializeCanvas();
    this.initializeFrameBuffer();

    console.log(&#x27;GameBoy GPU 已初始化&#x27;);
  &#125;

  /**
   * 初始化 Canvas 画布
   */
  initializeCanvas() &#123;
    // 尝试获取已存在的 canvas 元素
    this.canvas = document.getElementById(&#x27;gameboy-screen&#x27;);

    // 如果不存在，创建新的 canvas 并添加到页面
    if (!this.canvas) &#123;
      this.canvas = this.createCanvas();
    &#125;

    // 获取 2D 渲染上下文
    this.context = this.canvas.getContext(&#x27;2d&#x27;);

    if (!this.context) &#123;
      throw new Error(&#x27;无法获取 Canvas 2D 渲染上下文&#x27;);
    &#125;

    // 禁用图像平滑，保持像素艺术风格
    this.context.imageSmoothingEnabled = false;

    console.log(&#x27;Canvas 画布已初始化&#x27;);
  &#125;

  /**
   * 创建新的 Canvas 元素
   * @returns &#123;HTMLCanvasElement&#125; 创建的 canvas 元素
   */
  createCanvas() &#123;
    const canvas = document.createElement(&#x27;canvas&#x27;);
    canvas.id = &#x27;gameboy-screen&#x27;;
    canvas.width = DISPLAY_CONFIG.WIDTH;
    canvas.height = DISPLAY_CONFIG.HEIGHT;
    canvas.style.border = &#x27;2px solid #333&#x27;;
    canvas.style.imageRendering = &#x27;pixelated&#x27;; // 保持像素完美缩放
    canvas.style.imageRendering = &#x27;-moz-crisp-edges&#x27;; // Firefox
    canvas.style.imageRendering = &#x27;crisp-edges&#x27;;      // Chrome/Edge
    canvas.style.backgroundColor = &#x27;#9BBC0F&#x27;; // GameBoy 绿色背景
    // 为了方便在 HTML 中演示，这里直接添加到 body
    document.body.appendChild(canvas);

    console.log(&#x27;已创建新的 Canvas 元素&#x27;);
    return canvas;
  &#125;

  /**
   * 初始化帧缓冲区
   * 使用 ImageData 对象作为屏幕的内存表示
   */
  initializeFrameBuffer() &#123;
    // 创建图像数据对象（帧缓冲区）
    this.frameBuffer = this.context.createImageData(
      DISPLAY_CONFIG.WIDTH,
      DISPLAY_CONFIG.HEIGHT
    );

    // 初始化为白色背景
    this.clearFrameBuffer();

    console.log(&#x27;帧缓冲区已初始化&#x27;);
  &#125;

  /**
   * 清空帧缓冲区（设置为白色，或 GameBoy 默认背景色）
   */
  clearFrameBuffer() &#123;
    const data = this.frameBuffer.data;

    // 设置所有像素为白色（255, 255, 255, 255）
    for (let i = 0; i &lt; DISPLAY_CONFIG.BUFFER_SIZE; i += 4) &#123;
      data[i] = 255;      // R
      data[i + 1] = 255;  // G
      data[i + 2] = 255;  // B
      data[i + 3] = 255;  // A (透明度)
    &#125;
  &#125;

  /**
   * 设置像素颜色（辅助函数）
   * @param &#123;number&#125; x - X 坐标（0-159）
   * @param &#123;number&#125; y - Y 坐标（0-143）
   * @param &#123;number&#125; r - 红色分量（0-255）
   * @param &#123;number&#125; g - 绿色分量（0-255）
   * @param &#123;number&#125; b - 蓝色分量（0-255）
   * @param &#123;number&#125; a - 透明度（0-255），默认 255
   */
  setPixel(x, y, r, g, b, a = 255) &#123;
    if (x &lt; 0 || x &gt;= DISPLAY_CONFIG.WIDTH || y &lt; 0 || y &gt;= DISPLAY_CONFIG.HEIGHT) &#123;
      return; // 越界检查
    &#125;

    const pixelIndex = (y * DISPLAY_CONFIG.WIDTH + x) * 4;
    const data = this.frameBuffer.data;

    data[pixelIndex] = r;
    data[pixelIndex + 1] = g;
    data[pixelIndex + 2] = b;
    data[pixelIndex + 3] = a;
  &#125;
&#125;</code></pre>
<p>现在，我们有一个可以操作的帧缓冲区。通过修改 <code>this.frameBuffer.data</code> 数组中的 RGBA 值，我们可以改变屏幕上任何像素的颜色。修改完成后，调用 <code>this.context.putImageData(this.frameBuffer, 0, 0)</code> 就可以将更新后的帧缓冲区内容绘制到 Canvas 上。</p>
<h2 id="32-栅格图形与显示时序"><a class="markdownIt-Anchor" href="#32-栅格图形与显示时序"></a> 3.2. 栅格图形与显示时序</h2>
<blockquote>
<p>GPU 工作原理：</p>
<p>我们可以看一下老式电视是如何显示画面的：</p>
<pre><code class="language-plaintext">电子枪从左到右扫描 →→→→→→→→→→→（一行画完）
然后跳到下一行    ↓
再从左到右扫描   →→→→→→→→→→→（下一行）
...重复 144次 ...
最后回到顶部     ↑↑↑↑↑↑↑↑↑（准备下一帧）</code></pre>
<p>GameBoy 的 GPU 完全模仿了这个过程。</p>
<p>1989 年的硬件很慢，一次只能处理一行像素，这样做也能省电省内存。当年的程序员很聪明，用最少的资源做最多的事。</p>
</blockquote>
<p>GameBoy 的显示硬件模拟了阴极射线管（CRT）的工作方式。在 CRT 显示器中，电子束逐行扫描屏幕，并在扫描完成后返回到屏幕顶部。这个扫描过程不是瞬间完成的，它包含了消隐期：</p>
<ul>
<li>水平消隐：电子束从一行的末尾移动到下一行的开头所需的时间</li>
<li>垂直消隐：在一帧结束后，电子束从屏幕底部回到屏幕左上角所需的时间。垂直消隐期通常比水平消隐期长得多，因为它需要移动更远的距离</li>
</ul>
<p>GameBoy 的显示器也遵循类似的模式，并将其工作周期细分为四个不同的 GPU 模式。这对于精确模拟非常重要，因为某些硬件操作只能在特定的 GPU 模式下进行。</p>
<table>
<thead>
<tr>
<th>周期</th>
<th>GPU 模式号</th>
<th>时间消耗（<code>t</code> 时钟周期）</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>OAM 搜索</td>
<td>2</td>
<td>80</td>
<td>GPU 扫描 OAM 获取当前扫描线上的精灵信息。</td>
</tr>
<tr>
<td>像素传输</td>
<td>3</td>
<td>172</td>
<td>GPU 从 VRAM 读取图块和地图数据并渲染像素。</td>
</tr>
<tr>
<td>水平消隐</td>
<td>0</td>
<td>204</td>
<td>当前扫描线渲染完成后的等待期。</td>
</tr>
<tr>
<td>一条扫描线总时间</td>
<td></td>
<td>456</td>
<td>(80 + 172 + 204)</td>
</tr>
<tr>
<td>垂直消隐</td>
<td>1</td>
<td>4560（10 行）</td>
<td>所有可见扫描线渲染完成后的等待期。</td>
</tr>
<tr>
<td>一帧总时间</td>
<td></td>
<td>70224</td>
<td>（456 * 154 行）</td>
</tr>
</tbody>
</table>
<blockquote>
<p>为什么是这些数字呢？</p>
<p>GPU 像是一个画家，每天画一行像素。</p>
<ol>
<li>准备阶段（80）：看看要画什么角色（OAM 搜索）</li>
<li>绘画阶段（172）：专心画这一行（像素传输）</li>
<li>休息阶段（204）：喝口水，准备下一行（水平消隐）</li>
<li>长休息（4560）：一张画完了，休息下（垂直消隐）</li>
</ol>
<p>因此我们的游戏不能随时访问 GPU。</p>
</blockquote>
<p>为了在模拟器中保持这些时序，我们需要一个 <code>step</code> 函数，它会在 CPU 每执行一条指令后被调用，并根据 CPU 消耗的时钟周期来推进 GPU 的内部时序状态。</p>
<p>我们定义 GPU 模式和时序常量：</p>
<pre><code class="language-javascript">/**
 * GPU 模式常量定义
 * GameBoy GPU 有 4 种不同的工作模式，模拟 CRT 显示器的扫描过程
 */
const GPU_MODES = &#123;
  HBLANK: 0,        // 水平消隐期（扫描线结束后）
  VBLANK: 1,        // 垂直消隐期（帧结束后）
  OAM_SEARCH: 2,    // OAM 搜索期（精灵属性扫描）
  PIXEL_TRANSFER: 3 // 像素传输期（VRAM 读取和渲染）
&#125;;

/**
 * GPU 时序常量（以 CPU 的 T 时钟周期为单位）
 * CPU 频率：4194304 Hz
 */
const GPU_TIMINGS = &#123;
  // 扫描线时序
  OAM_SEARCH_CYCLES: 80,      // 模式 2：OAM 访问时间
  PIXEL_TRANSFER_CYCLES: 172, // 模式 3：VRAM 访问时间
  HBLANK_CYCLES: 204,         // 模式 0：水平消隐时间

  // 计算得出的时序
  SCANLINE_CYCLES: 456,       // 一条扫描线总时间（80 + 172 + 204）
  VBLANK_LINE_CYCLES: 456,    // 垂直消隐期每线时间
  VBLANK_TOTAL_CYCLES: 4560,  // 垂直消隐总时间（456 * 10）

  // 帧时序
  VISIBLE_LINES: 144,         // 可见扫描线数量
  VBLANK_LINES: 10,           // 垂直消隐扫描线数量
  TOTAL_LINES: 154,           // 总扫描线数量（144 + 10）
  FRAME_CYCLES: 70224         // 完整帧时间（456 * 154）
&#125;;

/**
 * 显示常量
 */
const DISPLAY_CONFIG = &#123;
  WIDTH: 160,                 // 屏幕宽度
  HEIGHT: 144,                // 屏幕高度
  BYTES_PER_PIXEL: 4,         // RGBA 格式，每像素 4 字节
  TOTAL_PIXELS: 160 * 144,    // 总像素数
  BUFFER_SIZE: 160 * 144 * 4  // 帧缓冲区大小
&#125;;</code></pre>
<p>接下来，我们在 <code>GameBoyGPU</code> 类中初始化时序状态，并实现 <code>step</code> 方法：</p>
<pre><code class="language-javascript">// ... 之前写的其他方法 ...

/**
 * 初始化时序状态
 */
initializeTimingState() &#123;
  this.mode = GPU_MODES.OAM_SEARCH; // 初始 GPU 模式
  this.modeClock = 0;                // 当前模式的时钟计数器
  this.currentLine = 0;              // 当前扫描线号（0-153）
  this.totalClock = 0;               // GPU 总时钟计数（累积）
  this.frameCount = 0;               // 帧计数器
  this.lastFrameTime = performance.now(); // 上次帧渲染时间（用于计算 FPS）
&#125;

/**
 * 重置 GPU 到初始状态
 */
reset() &#123;
  this.initializeTimingState();
  this.clearFrameBuffer();
  this.updateDisplay(); // 更新 Canvas 以显示清空后的画面

  console.log(&#x27;GPU 已重置&#x27;);
&#125;

/**
 * GPU 时序步进函数
 * 每次 CPU 执行指令后调用，根据 CPU 消耗的时钟周期推进 GPU 状态
 * @param &#123;number&#125; cycles CPU 消耗的时钟周期数
 */
step(cycles) &#123;
  this.modeClock += cycles; // 累加当前模式下的时钟
  this.totalClock += cycles; // 累加总时钟

  // 根据当前模式处理时序逻辑
  switch (this.mode) &#123;
    case GPU_MODES.OAM_SEARCH:
      this.handleOAMSearchMode();
      break;

    case GPU_MODES.PIXEL_TRANSFER:
      this.handlePixelTransferMode();
      break;

    case GPU_MODES.HBLANK:
      this.handleHBlankMode();
      break;

    case GPU_MODES.VBLANK:
      this.handleVBlankMode();
      break;

    default:
      console.warn(`未知的 GPU 模式：$&#123;this.mode&#125;`);
      this.mode = GPU_MODES.OAM_SEARCH; // 恢复到默认模式
  &#125;
&#125;

/**
 * 处理 OAM 搜索模式（模式 2）
 * 当模式时钟达到 OAM_SEARCH_CYCLES 时，切换到像素传输模式
 */
handleOAMSearchMode() &#123;
  if (this.modeClock &gt;= GPU_TIMINGS.OAM_SEARCH_CYCLES) &#123;
    this.modeClock = 0;
    this.mode = GPU_MODES.PIXEL_TRANSFER;

    // TODO: 在这个阶段，会进行 OAM 搜索逻辑，在第 7 章（精灵）中实现
    this.searchOAM();
  &#125;
&#125;

/**
 * 处理像素传输模式（模式 3）
 * 当模式时钟达到 PIXEL_TRANSFER_CYCLES 时，切换到水平消隐模式，并渲染当前扫描线
 */
handlePixelTransferMode() &#123;
  if (this.modeClock &gt;= GPU_TIMINGS.PIXEL_TRANSFER_CYCLES) &#123;
    this.modeClock = 0;
    this.mode = GPU_MODES.HBLANK;

    // 渲染当前扫描线
    this.renderScanline();
  &#125;
&#125;

/**
 * 处理水平消隐模式（模式 0）
 * 当模式时钟达到 HBLANK_CYCLES 时，递增扫描线，并根据扫描线数量决定进入 VBLANK 或下一条扫描线
 */
handleHBlankMode() &#123;
  if (this.modeClock &gt;= GPU_TIMINGS.HBLANK_CYCLES) &#123;
    this.modeClock = 0;
    this.currentLine++; // 扫描线递增

    if (this.currentLine === GPU_TIMINGS.VISIBLE_LINES) &#123;
      // 所有可见扫描线完成（0-143），进入垂直消隐模式
      this.mode = GPU_MODES.VBLANK;
      this.onFrameComplete(); // 通知一帧渲染完成
    &#125; else &#123;
      // 继续下一条扫描线，回到 OAM 搜索模式
      this.mode = GPU_MODES.OAM_SEARCH;
    &#125;
  &#125;
&#125;

/**
 * 处理垂直消隐模式（模式 1）
 * VBLANK 持续 10 条扫描线的时间。当模式时钟达到 VBLANK_LINE_CYCLES 时，递增扫描线，
 * 直到所有 VBLANK 扫描线完成，然后开始新的一帧。
 */
handleVBlankMode() &#123;
  if (this.modeClock &gt;= GPU_TIMINGS.VBLANK_LINE_CYCLES) &#123;
    this.modeClock = 0;
    this.currentLine++; // 扫描线递增

    if (this.currentLine &gt; GPU_TIMINGS.TOTAL_LINES - 1) &#123;
      // 垂直消隐结束（总共 154 条扫描线），开始新的一帧
      this.currentLine = 0;
      this.mode = GPU_MODES.OAM_SEARCH;
      this.onNewFrameStart(); // 通知新帧开始
    &#125;
  &#125;
&#125;

/**
 * OAM 搜索逻辑（占位函数）
 * 在第 7 章（精灵）中会实现完整的精灵处理逻辑
 */
searchOAM() &#123;
  // TODO: 实现精灵搜索逻辑
  // 1. 扫描 OAM 表中的 40 个精灵
  // 2. 找出在当前扫描线上的精灵（最多 10 个）
  // 3. 按 X 坐标排序准备渲染
&#125;

/**
 * 渲染当前扫描线
 * TODO: 目前是一个简单的测试渲染，在第 4 章（图形）中会实现完整的背景和精灵渲染
 */
renderScanline() &#123;
  this.renderTestPattern(); // 渲染一个测试图案
&#125;

/**
 * 渲染测试图案（用于验证 GPU 时序）
 * 在 Canvas 上显示彩色条纹，以验证扫描线渲染是否正常工作
 */
renderTestPattern() &#123;
  const data = this.frameBuffer.data;
  const y = this.currentLine; // 当前要渲染的扫描线

  // 为每条扫描线生成不同颜色的测试图案
  for (let x = 0; x &lt; DISPLAY_CONFIG.WIDTH; x++) &#123;
    const pixelIndex = (y * DISPLAY_CONFIG.WIDTH + x) * 4;

    // 创建彩色测试图案，使之随帧动画
    const colorPhase = (x + y + this.frameCount) % 64;

    if (colorPhase &lt; 16) &#123;
      // 红色渐变
      data[pixelIndex] = 255;
      data[pixelIndex + 1] = colorPhase * 16;
      data[pixelIndex + 2] = colorPhase * 16;
    &#125; else if (colorPhase &lt; 32) &#123;
      // 绿色渐变
      data[pixelIndex] = (32 - colorPhase) * 16;
      data[pixelIndex + 1] = 255;
      data[pixelIndex + 2] = (colorPhase - 16) * 16;
    &#125; else if (colorPhase &lt; 48) &#123;
      // 蓝色渐变
      data[pixelIndex] = (colorPhase - 32) * 16;
      data[pixelIndex + 1] = (48 - colorPhase) * 16;
      data[pixelIndex + 2] = 255;
    &#125; else &#123;
      // 白色渐变
      const brightness = (64 - colorPhase) * 16;
      data[pixelIndex] = brightness;
      data[pixelIndex + 1] = brightness;
      data[pixelIndex + 2] = brightness;
    &#125;

    data[pixelIndex + 3] = 255; // Alpha（完全不透明）
  &#125;
&#125;

/**
 * 帧渲染完成回调
 * 当一帧的所有可见扫描线渲染完成时调用。在这里我们将帧缓冲区显示到 Canvas。
 */
onFrameComplete() &#123;
  // 将帧缓冲区内容显示到 Canvas
  this.updateDisplay();

  // 更新帧计数和性能统计
  this.frameCount++;
  this.updatePerformanceStats();

  // TODO: 触发垂直消隐中断（在第 8 章中断中实现）
  this.triggerVBlankInterrupt();

  console.log(`帧 $&#123;this.frameCount&#125; 渲染完成`);
&#125;

/**
 * 新帧开始回调
 * 当垂直消隐期结束，准备开始新的一帧渲染时调用。
 */
onNewFrameStart() &#123;
  // TODO: 为新帧做准备，例如：
  // 1. 重置精灵计数器
  // 2. 更新背景/窗口滚动寄存器
  // 3. 处理显示控制寄存器变化
&#125;

/**
 * 将帧缓冲区内容更新到 Canvas
 */
updateDisplay() &#123;
  this.context.putImageData(this.frameBuffer, 0, 0);
&#125;

/**
 * 更新性能统计，例如 FPS
 */
updatePerformanceStats() &#123;
  const currentTime = performance.now();
  const frameTime = currentTime - this.lastFrameTime;
  this.lastFrameTime = currentTime;

  // 计算 FPS
  const fps = 1000 / frameTime;

  // 每 60 帧输出一次性能信息，避免频繁日志输出
  if (this.frameCount % 60 === 0) &#123;
    console.log(`性能统计 - FPS: $&#123;fps.toFixed(2)&#125;, 帧时间: $&#123;frameTime.toFixed(2)&#125;ms`);
  &#125;
&#125;

/**
 * 触发垂直消隐中断（占位函数）
 * 在第 8 章（中断）中会实现完整的中断系统，通知 CPU 进行 VBLANK 相关操作
 */
triggerVBlankInterrupt() &#123;
  // TODO: 实现 V-Blank 中断
  // 1. 设置中断标志位（例如在 MMU 中设置 IE/IF 寄存器）
  // 2. 如果中断使能，通知 CPU 暂停当前执行并跳转到中断处理程序
&#125;

/**
 * 获取当前 GPU 状态信息（用于调试）
 * @returns &#123;Object&#125; GPU 状态对象，包含模式、时钟、扫描线等
 */
getStatus() &#123;
  return &#123;
    mode: this.mode,
    modeName: this.getModeName(this.mode),
    modeClock: this.modeClock,
    currentLine: this.currentLine,
    totalClock: this.totalClock,
    frameCount: this.frameCount,
    fps: this.calculateFPS()
  &#125;;
&#125;

/**
 * 获取 GPU 模式名称的辅助函数
 * @param &#123;number&#125; mode - 模式号
 * @returns &#123;string&#125; 模式名称
 */
getModeName(mode) &#123;
  const modeNames = &#123;
    [GPU_MODES.HBLANK]: &#x27;水平消隐&#x27;,
    [GPU_MODES.VBLANK]: &#x27;垂直消隐&#x27;,
    [GPU_MODES.OAM_SEARCH]: &#x27;OAM 搜索&#x27;,
    [GPU_MODES.PIXEL_TRANSFER]: &#x27;像素传输&#x27;
  &#125;;
  return modeNames[mode] || &#x27;未知模式&#x27;;
&#125;

/**
 * 计算当前 FPS
 * @returns &#123;number&#125; 当前 FPS 值
 */
calculateFPS() &#123;
  const currentTime = performance.now();
  const timeDiff = currentTime - this.lastFrameTime;
  return timeDiff &gt; 0 ? 1000 / timeDiff : 0;
&#125;

/**
 * 获取调试信息字符串
 * @returns &#123;string&#125; 格式化的调试信息
 */
getDebugInfo() &#123;
  const status = this.getStatus();
  return `GPU 状态：
模式：$&#123;status.modeName&#125;（$&#123;status.mode&#125;）
模式时钟：$&#123;status.modeClock&#125;
当前扫描线：$&#123;status.currentLine&#125;
总时钟：$&#123;status.totalClock&#125;
帧计数：$&#123;status.frameCount&#125;
FPS：$&#123;status.fps.toFixed(2)&#125;`;
&#125;</code></pre>
<h1 id="4-图形渲染绘制背景与瓦片"><a class="markdownIt-Anchor" href="#4-图形渲染绘制背景与瓦片"></a> 4. 图形渲染：绘制背景与瓦片</h1>
<p>与现代显卡动辄数 GB 的显存不同，早期游戏机（如 GameBoy）的内存极其有限，无法在内存中直接存储完整的屏幕像素（即帧缓冲区）。为了解决这个问题，工程师们采用了一种非常聪明的技术——瓦片系统。</p>
<p>想象一下你在用瓷砖来铺地板。你不需要为每一块地面都设计一个独一无二的图案，而是可以使用一组预先设计好的瓷砖（瓦片），通过不同的排列组合来创造出丰富的地面样式。GameBoy 的图形渲染就是基于这个原理。我们只需要存储一份“模板”，然后在需要的地方“引用”它即可。这个“模板”就是瓦片。</p>
<ul>
<li>瓦片：一个 8x8 像素的基本图形单元。游戏中的所有背景和角色（精灵）都是由这些小小的瓦片拼接而成的</li>
<li>瓦片地图：一个 32x32 的二维数组，其中每个元素都是一个指向特定瓦片的索引。它就像一张设计图纸，规定了哪个位置应该使用哪个瓦片</li>
<li>视图：GameBoy 屏幕只有 160x144 像素，而整个背景地图却有 256x256 像素（32个瓦片 × 8像素/瓦片）。屏幕就像一个“摄像机”，我们只能通过这个 160x144 的窗口看到庞大背景地图的一部分</li>
</ul>
<blockquote>
<p>做过游戏开发的，尤其是做像素风格的应该对这个都很熟悉吧。</p>
<p>还是不太理解的，可以想一下拼图。</p>
<p>你要拼一幅大画，瓦片是你的拼图块（8x8 像素的小方块）、瓦片地图是拼图说明书、视图是拼图框。</p>
<p>游戏背景制作过程：</p>
<ol>
<li>美术画了很多 8x8 的小图块</li>
<li>策划说：“草地用 1 号块、石头用 2 号块……”</li>
<li>程序：“我按照说明书拼。”（GPU 渲染）</li>
<li>玩家在游戏中看到森林</li>
</ol>
<p>1989 年光是 1MB 内存就动不动要几千块钱，直接存储一张完整图片作为背景实在是过于奢侈。使用瓦片系统不仅可以节省内存，也可以节省空间。整个游戏卡带也才 32KB，必须得精打细算。</p>
</blockquote>
<p>VRAM（视频内存）中，瓦片数据和瓦片地图的布局如下：</p>
<table>
<thead>
<tr>
<th>地址区域</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x8000</code> - <code>0x8FFF</code></td>
<td>瓦片集 #1</td>
</tr>
<tr>
<td><code>0x9000</code> - <code>0x97FF</code></td>
<td>瓦片集 #2</td>
</tr>
<tr>
<td><code>0x9800</code> - <code>0x9BFF</code></td>
<td>瓦片地图 #0</td>
</tr>
<tr>
<td><code>0x9C00</code> - <code>0x9FFF</code></td>
<td>瓦片地图 #1</td>
</tr>
</tbody>
</table>
<p>有趣的是，瓦片集 #0 和 #1 有一部分是重叠的。游戏可以通过设置寄存器来选择使用哪个瓦片集和哪个瓦片地图，从而实现不同的显示效果。</p>
<h2 id="41-背景滚动与调色板"><a class="markdownIt-Anchor" href="#41-背景滚动与调色板"></a> 4.1. 背景滚动与调色板</h2>
<p>既然背景地图比屏幕大，我们自然就可以通过移动“摄像机”的位置来实现背景滚动的效果。这在平台跳跃或飞行射击游戏中非常常见。</p>
<p>GameBoy 提供了两个特殊的 GPU 寄存器来控制滚动：</p>
<ul>
<li><code>SCY</code>（Scroll Y, 地址 <code>0xFF42</code>）：定义了屏幕顶边对应在 256x256 背景地图上的垂直坐标</li>
<li><code>SCX</code>（Scroll X, 地址 <code>0xFF43</code>）：定义了屏幕左边对应在 256x256 背景地图上的水平坐标</li>
</ul>
<p>通过在每一帧之间改变 <code>SCX</code> 和 <code>SCY</code> 的值，游戏就能让背景平滑地滚动起来，创造出动态的世界。</p>
<p>或许大家都会以为 GameBoy 是纯黑白的，但实际上它可以显示四种深浅不同的“灰色”（或者说是绿色，取决于屏幕材质）。这四种颜色是通过调色板系统实现的。</p>
<p>一个瓦片中的每个像素用 2 个比特来表示，可以表示四种值（00, 01, 10, 11）。但这四个值具体对应哪种颜色，是由背景调色板寄存器（<code>BGP</code>, 地址 <code>0xFF47</code>）决定的。</p>
<p><code>BGP</code> 是一个 8 位寄存器，每 2 位定义一个颜色的映射关系：</p>
<ul>
<li>位 1-0：映射像素值 <code>00</code></li>
<li>位 3-2：映射像素值 <code>01</code></li>
<li>位 5-4：映射像素值 <code>10</code></li>
<li>位 7-6：映射像素值 <code>11</code></li>
</ul>
<p>例如，如果 <code>BGP</code> 的值是 <code>0xE4</code>（二进制 <code>11100100</code>），那么映射关系就是：</p>
<ul>
<li><code>00</code> → <code>00</code>（颜色 0）</li>
<li><code>01</code> → <code>01</code>（颜色 1）</li>
<li><code>10</code> → <code>10</code>（颜色 2）</li>
<li><code>11</code> → <code>11</code>（颜色 3）</li>
</ul>
<p>这是最常见的默认调色板。但如果游戏将 <code>BGP</code> 的值改为 <code>0x1E</code>（二进制 <code>00011011</code>），映射就会变成：</p>
<ul>
<li><code>00</code> → <code>11</code>（颜色 3）</li>
<li><code>01</code> → <code>10</code>（颜色 2）</li>
<li><code>10</code> → <code>01</code>（颜色 1）</li>
<li><code>11</code> → <code>00</code>（颜色 0）</li>
</ul>
<p>这样整个屏幕的颜色就瞬间反转了，能够很高效地实现特殊视觉效果（比方说闪烁、水下效果）的方式。</p>
<p>在我们的模拟器中，我们将这四种颜色定义为经典的 GameBoy 绿色调：</p>
<pre><code class="language-javascript">const DEFAULT_PALETTE = [
  [155, 188, 15, 255],   // 颜色 0: 最亮 (白)
  [139, 172, 15, 255],   // 颜色 1: 亮灰 (浅绿)
  [48, 98, 48, 255],     // 颜色 2: 暗灰 (深绿)
  [15, 56, 15, 255]      // 颜色 3: 最暗 (黑)
];</code></pre>
<h2 id="42-瓦片数据结构与缓存管理"><a class="markdownIt-Anchor" href="#42-瓦片数据结构与缓存管理"></a> 4.2. 瓦片数据结构与缓存管理</h2>
<p>在 GameBoy 中，每个瓦片的像素数据以一种特殊的方式存储。每个像素需要 2 位来表示（因为有 4 种颜色），但这 2 位并不是连续存储的。相反，一个瓦片行的 8 个像素的低位全部存储在一个字节中，高位存储在下一个字节中。</p>
<p>例如，如果一个瓦片行的像素值是 <code>[3, 2, 1, 0, 0, 1, 2, 3]</code>，那么：</p>
<ul>
<li>低位字节：<code>11100001</code>（每个像素值的最低位）</li>
<li>高位字节：<code>11000011</code>（每个像素值的最高位）</li>
</ul>
<p>这种存储方式虽然看起来复杂，但符合 GameBoy 硬件的读取方式。</p>
<blockquote>
<p>这一部分不需要完全理解，只要知道“GameBoy 有自己的存储格式，我们需要转换一下”就够了。</p>
</blockquote>
<p>为了提高模拟器的性能，我们需要将这种原始格式转换为更易于处理的格式，并建立缓存机制：</p>
<pre><code class="language-javascript">/**
 * 瓦片管理器类
 * 负责瓦片数据的存储、更新和缓存管理
 */
class TileManager &#123;
  constructor() &#123;
    // 扩展瓦片数据缓存 - 每个瓦片预计算为 8x8 的像素数组
    this.tileCache = new Array(GRAPHICS_CONSTANTS.TOTAL_TILES);
    
    for (let i = 0; i &lt; GRAPHICS_CONSTANTS.TOTAL_TILES; i++) &#123;
      this.tileCache[i] = new Array(GRAPHICS_CONSTANTS.TILE_HEIGHT);
      for (let y = 0; y &lt; GRAPHICS_CONSTANTS.TILE_HEIGHT; y++) &#123;
        this.tileCache[i][y] = new Uint8Array(GRAPHICS_CONSTANTS.TILE_WIDTH);
      &#125;
    &#125;
    
    // 标记哪些瓦片需要更新
    this.dirtyTiles = new Set();
  &#125;

  /**
   * 更新单个瓦片的缓存数据
   */
  updateTileCache(tileIndex) &#123;
    // 计算瓦片在 VRAM 中的起始地址
    const baseAddr = tileIndex * GRAPHICS_CONSTANTS.TILE_SIZE_BYTES;
    
    // 逐行处理瓦片数据
    for (let y = 0; y &lt; GRAPHICS_CONSTANTS.TILE_HEIGHT; y++) &#123;
      const rowAddr = baseAddr + (y * 2); // 每行占 2 字节
      
      if (rowAddr + 1 &lt; this.vram.length) &#123;
        const lowByte = this.vram[rowAddr];     // 像素低位
        const highByte = this.vram[rowAddr + 1]; // 像素高位
        
        // 从两个字节中提取 8 个像素
        for (let x = 0; x &lt; GRAPHICS_CONSTANTS.TILE_WIDTH; x++) &#123;
          const bitMask = 1 &lt;&lt; (7 - x);
          
          const lowBit = (lowByte &amp; bitMask) ? 1 : 0;
          const highBit = (highByte &amp; bitMask) ? 2 : 0;
          
          // 组合成 2 位颜色值
          this.tileCache[tileIndex][y][x] = lowBit + highBit;
        &#125;
      &#125;
    &#125;
  &#125;
&#125;</code></pre>
<p>这个缓存系统的核心思想是“按需更新”——只有当 VRAM 中的瓦片数据发生变化时，我们才重新计算对应的缓存。这样可以避免每次渲染时都进行耗时的位操作。</p>
<h2 id="43-调色板系统实现"><a class="markdownIt-Anchor" href="#43-调色板系统实现"></a> 4.3. 调色板系统实现</h2>
<p>调色板管理器负责处理颜色映射。它不仅存储当前的调色板设置，还提供了动态更新调色板的能力：</p>
<pre><code class="language-javascript">/**
 * 调色板管理器类
 * 处理 GameBoy 的 4 色调色板系统
 */
class PaletteManager &#123;
  constructor() &#123;
    // 背景调色板（4 种颜色，每种颜色 RGBA 4 字节）
    this.backgroundPalette = new Array(GRAPHICS_CONSTANTS.PALETTE_COLORS);
    
    // 原始调色板寄存器值（用于模拟硬件寄存器）
    this.paletteRegister = 0xFC; // 默认值：11 10 01 00
    
    this.setDefaultPalette();
  &#125;

  /**
   * 更新调色板寄存器
   */
  updatePaletteRegister(value) &#123;
    this.paletteRegister = value &amp; 0xFF;
    
    // 从寄存器值提取 4 个 2 位颜色映射
    for (let i = 0; i &lt; GRAPHICS_CONSTANTS.PALETTE_COLORS; i++) &#123;
      const colorIndex = (this.paletteRegister &gt;&gt; (i * 2)) &amp; 0x03;
      this.backgroundPalette[i] = [...DEFAULT_PALETTE[colorIndex]];
    &#125;
  &#125;

  /**
   * 获取映射后的颜色
   */
  getColor(paletteIndex) &#123;
    if (paletteIndex &lt; 0 || paletteIndex &gt;= GRAPHICS_CONSTANTS.PALETTE_COLORS) &#123;
      return DEFAULT_PALETTE[0];
    &#125;
    
    return this.backgroundPalette[paletteIndex];
  &#125;
&#125;</code></pre>
<p>例如，当游戏写入调色板寄存器 <code>0xFF47</code> 时，<code>updatePaletteRegister</code> 方法会被调用，自动重新映射所有颜色。这意味着游戏可以通过一个简单的寄存器写入操作瞬间改变整个屏幕的色调。</p>
<h2 id="44-背景滚动控制"><a class="markdownIt-Anchor" href="#44-背景滚动控制"></a> 4.4. 背景滚动控制</h2>
<p>滚动控制器管理背景的偏移位置，这是实现动态背景效果的关键：</p>
<pre><code class="language-javascript">/**
 * 滚动控制器类
 * 管理背景的滚动位置
 */
class ScrollController &#123;
  constructor() &#123;
    this.scrollX = 0; // 水平滚动位置
    this.scrollY = 0; // 垂直滚动位置
  &#125;

  /**
   * 设置滚动位置
   */
  setScroll(x, y) &#123;
    this.scrollX = x &amp; 0xFF;
    this.scrollY = y &amp; 0xFF;
  &#125;

  /**
   * 获取当前滚动位置
   */
  getScrollPosition() &#123;
    return &#123;
      x: this.scrollX,
      y: this.scrollY
    &#125;;
  &#125;
&#125;</code></pre>
<p>这个简单的类封装了 GameBoy 的 <code>SCX</code> 和 <code>SCY</code> 寄存器的功能。当游戏修改这些寄存器时，滚动位置会立即更新，下一帧的渲染就会反映出新的滚动位置。</p>
<h2 id="45-扫描线级背景渲染"><a class="markdownIt-Anchor" href="#45-扫描线级背景渲染"></a> 4.5. 扫描线级背景渲染</h2>
<p>背景渲染器是整个图形系统的核心，它负责将瓦片地图转换为实际的像素数据。渲染是按扫描线进行的，这模拟了 GameBoy 的真实渲染方式：</p>
<pre><code class="language-javascript">/**
 * 背景渲染器类
 * 负责将瓦片地图渲染到帧缓冲区
 */
class BackgroundRenderer &#123;
  /**
   * 渲染单条扫描线的背景
   */
  renderBackgroundScanline(lineNumber, frameBuffer) &#123;
    // 获取滚动位置
    const scroll = this.scrollController.getScrollPosition();
    
    // 计算当前扫描线在瓦片地图中的 Y 位置
    const mapY = (lineNumber + scroll.y) &amp; 0xFF;
    const tileY = Math.floor(mapY / GRAPHICS_CONSTANTS.TILE_HEIGHT);
    const pixelY = mapY % GRAPHICS_CONSTANTS.TILE_HEIGHT;
    
    // 计算瓦片地图行的起始偏移
    const mapBaseAddr = this.backgroundMapSelect ? 
      VRAM_LAYOUT.TILEMAP_1_START : VRAM_LAYOUT.TILEMAP_0_START;
    const mapOffset = mapBaseAddr - VRAM_LAYOUT.TILESET_1_START;
    const mapLineOffset = mapOffset + (tileY * GRAPHICS_CONSTANTS.MAP_WIDTH_TILES);
    
    // 计算起始瓦片的 X 位置
    let mapX = scroll.x;
    let tileX = Math.floor(mapX / GRAPHICS_CONSTANTS.TILE_WIDTH);
    let pixelX = mapX % GRAPHICS_CONSTANTS.TILE_WIDTH;
    
    // 计算帧缓冲区的起始位置
    let canvasOffset = lineNumber * GRAPHICS_CONSTANTS.SCREEN_WIDTH * 4;
    
    // 获取第一个瓦片
    let tileIndex = this.getTileIndex(mapLineOffset + tileX);
    let tileData = this.tileManager.getTileData(tileIndex);
    
    // 渲染整条扫描线（160 像素）
    for (let screenX = 0; screenX &lt; GRAPHICS_CONSTANTS.SCREEN_WIDTH; screenX++) &#123;
      // 获取当前像素的调色板索引
      const paletteIndex = tileData ? tileData[pixelY][pixelX] : 0;
      
      // 通过调色板获取最终颜色
      const color = this.paletteManager.getColor(paletteIndex);
      
      // 写入帧缓冲区
      frameBuffer.data[canvasOffset] = color[0];     // R
      frameBuffer.data[canvasOffset + 1] = color[1]; // G
      frameBuffer.data[canvasOffset + 2] = color[2]; // B
      frameBuffer.data[canvasOffset + 3] = color[3]; // A
      canvasOffset += 4;
      
      // 移动到下一个像素
      pixelX++;
      if (pixelX &gt;= GRAPHICS_CONSTANTS.TILE_WIDTH) &#123;
        // 移动到下一个瓦片
        pixelX = 0;
        tileX = (tileX + 1) &amp; 31; // 瓦片地图是 32x32，循环
        tileIndex = this.getTileIndex(mapLineOffset + tileX);
        tileData = this.tileManager.getTileData(tileIndex);
      &#125;
    &#125;
  &#125;
&#125;</code></pre>
<p>这个渲染过程的关键在于理解坐标转换：</p>
<ol>
<li>从屏幕坐标转换为背景地图坐标（考虑滚动偏移）</li>
<li>从背景地图坐标转换为瓦片坐标和瓦片内像素坐标</li>
<li>从瓦片地图读取瓦片索引</li>
<li>从瓦片缓存读取像素的调色板索引</li>
<li>通过调色板获取最终的 RGBA 颜色值</li>
</ol>
<h2 id="46-图形系统集成"><a class="markdownIt-Anchor" href="#46-图形系统集成"></a> 4.6. 图形系统集成</h2>
<p>最后，图形系统主类将所有组件协调起来工作：</p>
<pre><code class="language-javascript">/**
 * 图形系统主类
 * 协调所有图形组件的工作
 */
class GameBoyGraphicsSystem &#123;
  constructor() &#123;
    // 创建各个组件
    this.tileManager = new TileManager();
    this.paletteManager = new PaletteManager();
    this.scrollController = new ScrollController();
    this.backgroundRenderer = new BackgroundRenderer(
      this.tileManager,
      this.paletteManager,
      this.scrollController
    );
  &#125;

  /**
   * 连接到 MMU 的 VRAM
   */
  connectVRAM(vramData) &#123;
    this.tileManager.setVRAM(vramData);
    this.backgroundRenderer.setVRAM(vramData);
  &#125;

  /**
   * 处理图形寄存器写入
   */
  writeGraphicsRegister(register, value) &#123;
    switch (register) &#123;
      case 0xFF42: // SCY - 垂直滚动
        this.scrollController.setScrollY(value);
        break;
        
      case 0xFF43: // SCX - 水平滚动
        this.scrollController.setScrollX(value);
        break;
        
      case 0xFF47: // BGP - 背景调色板
        this.paletteManager.updatePaletteRegister(value);
        break;
    &#125;
  &#125;

  /**
   * 渲染单条扫描线
   */
  renderScanline(lineNumber, frameBuffer) &#123;
    if (!this.enabled || !this.backgroundEnabled) &#123;
      return;
    &#125;
    
    this.backgroundRenderer.renderBackgroundScanline(lineNumber, frameBuffer);
  &#125;
&#125;</code></pre>
<p>这个集成系统的设计遵循了模块化原则——每个组件都有清晰的职责，通过明确的接口进行通信。当 GPU 需要渲染一条扫描线时，它只需调用 <code>renderScanline</code> 方法，图形系统会自动协调所有子组件完成复杂的渲染过程。</p>
<h2 id="47-图形系统集成与性能优化"><a class="markdownIt-Anchor" href="#47-图形系统集成与性能优化"></a> 4.7. 图形系统集成与性能优化</h2>
<p>在完成了瓦片管理、调色板和背景渲染等核心组件后，我们需要将图形系统与现有的 GPU 时序系统集成起来，并进行性能优化以确保流畅的渲染效果（当时测试的时候 FPS 发现连 1 都不到……）。</p>
<p>首先，我们需要在 GPU 类中添加图形系统的初始化和管理逻辑：</p>
<pre><code class="language-javascript">/**
 * 初始化图形系统
 */
initializeGraphicsSystem() &#123;
  // 图形系统实例（如果可用）
  this.graphicsSystem = null;
  this.renderMode = &#x27;test&#x27;; // &#x27;test&#x27; 或 &#x27;graphics&#x27;

  // 尝试初始化图形系统
  if (typeof GameBoyGraphicsSystem !== &#x27;undefined&#x27;) &#123;
    try &#123;
      this.graphicsSystem = new GameBoyGraphicsSystem();
      this.renderMode = &#x27;graphics&#x27;;
      console.log(&#x27;图形系统已集成到 GPU&#x27;);
    &#125; catch (error) &#123;
      console.warn(&#x27;图形系统初始化失败，使用测试模式:&#x27;, error);
    &#125;
  &#125; else &#123;
    console.log(&#x27;图形系统未加载，使用测试渲染模式&#x27;);
  &#125;
&#125;</code></pre>
<p>接下来，我们需要建立 GPU 与图形系统之间的数据连接：</p>
<pre><code class="language-javascript">/**
 * 连接到 MMU 的 VRAM
 */
connectVRAM(vramData) &#123;
  if (this.graphicsSystem) &#123;
    this.graphicsSystem.connectVRAM(vramData);
    console.log(&#x27;GPU 已连接到 VRAM&#x27;);
  &#125;
&#125;

/**
 * 处理 VRAM 写入事件
 */
onVRAMWrite(address, value) &#123;
  if (this.graphicsSystem) &#123;
    this.graphicsSystem.onVRAMWrite(address, value);
  &#125;
&#125;

/**
 * 处理图形寄存器写入
 */
writeRegister(register, value) &#123;
  if (this.graphicsSystem) &#123;
    this.graphicsSystem.writeGraphicsRegister(register, value);
  &#125;
&#125;</code></pre>
<p>为了提供更好的调试体验和性能，我们要实现渲染模式切换：</p>
<pre><code class="language-javascript">/**
 * 渲染真实的 GameBoy 背景图形
 */
renderGameBoyGraphics() &#123;
  if (window.GameBoyGraphicsSystem &amp;&amp; this.graphicsSystem) &#123;
    this.graphicsSystem.renderScanline(this.currentLine, this.frameBuffer);
  &#125; else &#123;
    // 否则使用测试图案
    this.renderTestPattern();
  &#125;
&#125;

/**
 * 切换渲染模式
 */
setRenderMode(mode) &#123;
  if (mode === &#x27;graphics&#x27; &amp;&amp; !this.graphicsSystem) &#123;
    console.warn(&#x27;图形系统未初始化，无法切换到图形模式&#x27;);
    return;
  &#125;

  this.renderMode = mode;
  console.log(`渲染模式已切换到：$&#123;mode&#125;`);
&#125;

/**
 * 渲染当前扫描线
 */
renderScanline() &#123;
  // 根据渲染模式选择渲染方式
  if (this.renderMode === &#x27;graphics&#x27; &amp;&amp; this.graphicsSystem) &#123;
    this.renderGameBoyGraphics();
  &#125; else &#123;
    this.renderTestPattern();
  &#125;
&#125;</code></pre>
<p>最重要的性能优化是引入了简化的帧级别渲染，避免了复杂的周期级别计算：</p>
<pre><code class="language-javascript">/**
 * 简化的帧级别步进
 * 每次调用渲染一整帧，避免复杂的周期计算
 */
stepFrame() &#123;
  // 1. 渲染所有可见扫描线 (0-143)
  for (let line = 0; line &lt; GPU_TIMINGS.VISIBLE_LINES; line++) &#123;
    this.currentLine = line;
    this.mode = GPU_MODES.PIXEL_TRANSFER;
    this.renderScanline();
  &#125;

  // 2. 模拟垂直消隐期间 (144-153)
  this.mode = GPU_MODES.VBLANK;
  this.currentLine = GPU_TIMINGS.VISIBLE_LINES;

  // 3. 完成帧渲染
  this.onFrameComplete();

  // 4. 重置到下一帧开始
  this.currentLine = 0;
  this.mode = GPU_MODES.OAM_SEARCH;
  this.modeClock = 0;
&#125;</code></pre>
<h1 id="5-系统集成构建完整的模拟器架构"><a class="markdownIt-Anchor" href="#5-系统集成构建完整的模拟器架构"></a> 5. 系统集成：构建完整的模拟器架构</h1>
<p>在前面的章节中，我们分别实现了 CPU 指令处理、MMU 内存管理、GPU 时序控制和图形渲染系统。虽然这些组件各自功能完善，但它们就跟分散的乐器差不多，需要一个指挥家来协调，不然是无法演奏出和谐的交响乐的。这一章的核心任务就是建立这样一个统一的系统架构，让所有硬件组件无缝协作。</p>
<h2 id="51-硬件抽象层与组件连接"><a class="markdownIt-Anchor" href="#51-硬件抽象层与组件连接"></a> 5.1. 硬件抽象层与组件连接</h2>
<p>在真实的 GameBoy 中，各个硬件组件通过物理总线连接。在我们的模拟器中，我们需要建立一个软件层面的“总线系统“，让组件间能够进行通信。MMU 作为内存管理的中心，天然地成为了这个连接中心。</p>
<p>我们为 MMU 添加硬件组件连接能力：</p>
<pre><code class="language-javascript">/**
 * 初始化硬件组件引用
 */
initializeHardwareReferences() &#123;
  // 硬件组件引用，由外部注入
  this.gpu = null;
  this.inputController = null;      // 第6章添加
  this.timer = null;                // 第10章添加
  this.interruptController = null;  // 第8章添加

  console.log(&#x27;📡 MMU 硬件接口已初始化&#x27;);
&#125;

/**
 * 连接硬件组件
 * @param &#123;string&#125; componentType 组件类型（&#x27;gpu&#x27;, &#x27;input&#x27;, &#x27;timer&#x27;, &#x27;interrupt&#x27;）
 * @param &#123;Object&#125; component 硬件组件实例
 */
connectHardware(componentType, component) &#123;
  switch (componentType) &#123;
    case &#x27;gpu&#x27;:
      this.gpu = component;
      console.log(&#x27;✅ GPU 已连接到 MMU&#x27;);
      break;
    case &#x27;input&#x27;:
      this.inputController = component;
      console.log(&#x27;✅ 输入控制器已连接到 MMU&#x27;);
      break;
    // ... 其他组件
  &#125;
&#125;</code></pre>
<p>这种设计的优势在于<strong>松耦合</strong>：每个组件都不需要知道其他组件的具体实现，只需要通过 MMU 这个“中介”进行通信。当我们要添加新的硬件组件时，只需要在 MMU 中注册即可。</p>
<h2 id="52-io-寄存器路由系统"><a class="markdownIt-Anchor" href="#52-io-寄存器路由系统"></a> 5.2. I/O 寄存器路由系统</h2>
<p>GameBoy 的硬件组件通过内存映射的 I/O 寄存器进行控制。这些寄存器位于 <code>0xFF00-0xFF7F</code> 地址范围内，不同的地址控制不同的硬件功能。我们需要建立一个路由系统，将对这些地址的读写操作转发给相应的硬件组件。</p>
<p>首先，定义一个完整的寄存器地址映射：</p>
<pre><code class="language-javascript">/**
 * I/O 寄存器映射常量
 */
const IO_REGISTERS = &#123;
  // GPU 寄存器范围（0xFF40-0xFF7F）
  GPU_START: 0xFF40,
  GPU_END: 0xFF7F,

  // 具体的 GPU 寄存器
  LCDC: 0xFF40,    // LCD 控制寄存器
  STAT: 0xFF41,    // LCD 状态寄存器
  SCY: 0xFF42,     // 垂直滚动
  SCX: 0xFF43,     // 水平滚动
  LY: 0xFF44,      // 当前扫描线（只读）
  BGP: 0xFF47,     // 背景调色板

  // 其他硬件寄存器
  JOYPAD: 0xFF00,  // 按键输入（第6章实现）
  IF: 0xFF0F,      // 中断标志
  IE: 0xFFFF       // 中断使能
&#125;;</code></pre>
<p>MMU 中的寄存器读写方法会根据地址范围自动将请求路由到对应的硬件组件：</p>
<pre><code class="language-javascript">/**
 * 连接硬件组件
 * @param &#123;string&#125; componentType - 组件类型 (&#x27;gpu&#x27;, &#x27;input&#x27;, &#x27;timer&#x27;, &#x27;interrupt&#x27;)
 * @param &#123;Object&#125; component - 硬件组件实例
 */
connectHardware(componentType, component) &#123;
  switch (componentType) &#123;
    case &#x27;gpu&#x27;:
      this.gpu = component;
      console.log(&#x27;✅ GPU 已连接到 MMU&#x27;);
      break;
    case &#x27;input&#x27;:
      this.inputController = component;
      console.log(&#x27;✅ 输入控制器已连接到 MMU&#x27;);
      break;
    case &#x27;timer&#x27;:
      this.timer = component;
      console.log(&#x27;✅ 定时器已连接到 MMU&#x27;);
      break;
    case &#x27;interrupt&#x27;:
      this.interruptController = component;
      console.log(&#x27;✅ 中断控制器已连接到 MMU&#x27;);
      break;
    default:
      console.warn(`⚠️ 未知的硬件组件类型: $&#123;componentType&#125;`);
  &#125;
&#125;</code></pre>
<p>不同的寄存器地址控制不同的硬件功能，MMU 需要将读写操作正确路由到对应的硬件组件：</p>
<pre><code class="language-javascript">/**
 * 读取I/O寄存器 - 支持硬件组件路由
 */
readIORegister(address) &#123;
  // 🎨 GPU 寄存器范围 (0xFF40-0xFF7F)
  if (address &gt;= IO_REGISTERS.GPU_START &amp;&amp; address &lt;= IO_REGISTERS.GPU_END) &#123;
    if (this.gpu &amp;&amp; typeof this.gpu.readRegister === &#x27;function&#x27;) &#123;
      return this.gpu.readRegister(address);
    &#125; else &#123;
      console.warn(`⚠️ GPU 未连接，无法读取寄存器 0x$&#123;address.toString(16)&#125;`);
      return 0xFF;
    &#125;
  &#125;

  // TODO: 以下都会在未来的章节中实现

  // 🎮 按键输入寄存器 (0xFF00)
  if (address === IO_REGISTERS.JOYPAD) &#123;
    if (this.inputController &amp;&amp; typeof this.inputController.readJoypadRegister === &#x27;function&#x27;) &#123;
      return this.inputController.readJoypadRegister();
    &#125;
    return 0xFF; // 默认：所有按键未按下
  &#125;

  // ⏰ 定时器寄存器 (0xFF04-0xFF07)
  if (address &gt;= IO_REGISTERS.TIMER_DIV &amp;&amp; address &lt;= IO_REGISTERS.TIMER_TAC) &#123;
    if (this.timer &amp;&amp; typeof this.timer.readRegister === &#x27;function&#x27;) &#123;
      return this.timer.readRegister(address);
    &#125;
    return 0x00;
  &#125;

  // 🔔 中断寄存器 (0xFF0F, 0xFFFF)
  if (address === IO_REGISTERS.IF || address === IO_REGISTERS.IE) &#123;
    if (this.interruptController &amp;&amp; typeof this.interruptController.readRegister === &#x27;function&#x27;) &#123;
      return this.interruptController.readRegister(address);
    &#125;
    return 0x00;
  &#125;

  // 默认处理
  const registerIndex = address - MEMORY_REGIONS.IO_START;
  return this.ioRegisters[registerIndex] || 0xFF;
&#125;</code></pre>
<p>对应的写入路由逻辑确保了每个硬件组件都能及时收到控制指令：</p>
<pre><code class="language-javascript">/**
 * 写入I/O寄存器 - 支持硬件组件路由
 * @param &#123;number&#125; address - I/O寄存器地址
 * @param &#123;number&#125; value - 要写入的值
 */
writeIORegister(address, value) &#123;
  // 🎨 GPU 寄存器范围 (0xFF40-0xFF7F)
  if (address &gt;= IO_REGISTERS.GPU_START &amp;&amp; address &lt;= IO_REGISTERS.GPU_END) &#123;
    if (this.gpu &amp;&amp; typeof this.gpu.writeRegister === &#x27;function&#x27;) &#123;
      this.gpu.writeRegister(address, value);
    &#125; else &#123;
      console.warn(`⚠️ GPU 未连接，无法写入寄存器 0x$&#123;address.toString(16)&#125;`);
    &#125;
    // 同时保存到本地数组（用于后备）
    const registerIndex = address - MEMORY_REGIONS.IO_START;
    if (registerIndex &gt;= 0 &amp;&amp; registerIndex &lt; this.ioRegisters.length) &#123;
      this.ioRegisters[registerIndex] = value;
    &#125;
    return;
  &#125;

  // 🎮 按键输入寄存器 (0xFF00) - 第6章实现
  if (address === IO_REGISTERS.JOYPAD) &#123;
    if (this.inputController &amp;&amp; typeof this.inputController.writeJoypadRegister === &#x27;function&#x27;) &#123;
      this.inputController.writeJoypadRegister(value);
    &#125;
    // 保存到本地数组
    this.ioRegisters[address - MEMORY_REGIONS.IO_START] = value;
    return;
  &#125;

  // ⏰ 定时器寄存器 (0xFF04-0xFF07) - 第10章实现
  if (address &gt;= IO_REGISTERS.TIMER_DIV &amp;&amp; address &lt;= IO_REGISTERS.TIMER_TAC) &#123;
    if (this.timer &amp;&amp; typeof this.timer.writeRegister === &#x27;function&#x27;) &#123;
      this.timer.writeRegister(address, value);
    &#125;
    this.ioRegisters[address - MEMORY_REGIONS.IO_START] = value;
    return;
  &#125;

  // 🔔 中断寄存器 (0xFF0F, 0xFFFF) - 第8章实现
  if (address === IO_REGISTERS.IF || address === IO_REGISTERS.IE) &#123;
    if (this.interruptController &amp;&amp; typeof this.interruptController.writeRegister === &#x27;function&#x27;) &#123;
      this.interruptController.writeRegister(address, value);
    &#125;
    // 特殊处理：IE 寄存器在零页RAM中
    if (address === IO_REGISTERS.IE) &#123;
      this.zram[0x7F] = value; // 0xFFFF -&gt; ZRAM[0x7F]
    &#125; else &#123;
      this.ioRegisters[address - MEMORY_REGIONS.IO_START] = value;
    &#125;
    return;
  &#125;

  // 默认处理：保存到本地寄存器数组
  const registerIndex = address - MEMORY_REGIONS.IO_START;
  if (registerIndex &gt;= 0 &amp;&amp; registerIndex &lt; this.ioRegisters.length) &#123;
    this.ioRegisters[registerIndex] = value;
  &#125; else &#123;
    console.warn(`⚠️ 无效的I/O寄存器写入: 0x$&#123;address.toString(16).padStart(4, &#x27;0&#x27;)&#125;`);
  &#125;
&#125;</code></pre>
<p>这样，当游戏代码写入 <code>0xFF40</code>（LCD 控制寄存器）时，MMU 会自动将这个写入操作转发给 GPU，GPU 就能实时更新其内部状态。</p>
<p>GPU 是 I/O 寄存器最密集的硬件组件，拥有十多个不同功能的寄存器。这些寄存器不仅控制显示行为，还影响中断、DMA 传输等关键功能。</p>
<pre><code class="language-javascript">/**
 * GPU 寄存器常量定义
 */
const GPU_REGISTERS = &#123;
  // LCD 控制和状态
  LCDC: 0xFF40,    // LCD 控制寄存器
  STAT: 0xFF41,    // LCD 状态寄存器
  
  // 滚动位置
  SCY: 0xFF42,     // 垂直滚动
  SCX: 0xFF43,     // 水平滚动
  
  // 扫描线相关
  LY: 0xFF44,      // 当前扫描线（只读）
  LYC: 0xFF45,     // 扫描线比较值
  
  // DMA 传输
  DMA: 0xFF46,     // DMA 传输寄存器
  
  // 调色板
  BGP: 0xFF47,     // 背景调色板
  OBP0: 0xFF48,    // 精灵调色板 0
  OBP1: 0xFF49,    // 精灵调色板 1
  
  // 窗口位置
  WY: 0xFF4A,      // 窗口 Y 位置
  WX: 0xFF4B       // 窗口 X 位置
&#125;;

/**
 * LCD 控制寄存器标志位
 */
const LCDC_FLAGS = &#123;
  LCD_ENABLE: 0x80,        // 位 7：LCD 开关
  WINDOW_TILEMAP: 0x40,    // 位 6：窗口瓦片地图选择
  WINDOW_ENABLE: 0x20,     // 位 5：窗口开关
  BG_TILESET: 0x10,        // 位 4：背景瓦片数据选择
  BG_TILEMAP: 0x08,        // 位 3：背景瓦片地图选择
  SPRITE_SIZE: 0x04,       // 位 2：精灵大小（0=8x8, 1=8x16）
  SPRITE_ENABLE: 0x02,     // 位 1：精灵开关
  BG_ENABLE: 0x01          // 位 0：背景开关
&#125;;</code></pre>
<p>GPU 内部维护所有寄存器的当前状态：</p>
<pre><code class="language-javascript">/**
 * 初始化寄存器状态
 */
initializeRegisters() &#123;
  // GPU 寄存器状态
  this.registers = &#123;
    // LCD 控制寄存器 (0xFF40)
    lcdc: 0x00,

    // LCD 状态寄存器 (0xFF41)
    stat: 0x00,

    // 滚动寄存器
    scy: 0x00,   // 垂直滚动 (0xFF42)
    scx: 0x00,   // 水平滚动 (0xFF43)

    // 扫描线寄存器
    ly: 0x00,    // 当前扫描线 (0xFF44) - 只读
    lyc: 0x00,   // 扫描线比较值 (0xFF45)

    // 调色板寄存器
    bgp: 0xFC,   // 背景调色板 (0xFF47) - 默认值

    // 窗口位置寄存器
    wy: 0x00,    // 窗口 Y 位置 (0xFF4A)
    wx: 0x00     // 窗口 X 位置 (0xFF4B)
  &#125;;

  // 解析控制标志位到独立变量（向后兼容）
  this.updateControlFlags();
&#125;</code></pre>
<p>LCD 控制寄存器（LCDC）是一个特殊的寄存器，它的每一位都控制不同的显示功能：</p>
<pre><code class="language-javascript">/**
 * 从寄存器值更新控制标志位
 */
updateControlFlags() &#123;
  const lcdc = this.registers.lcdc;

  // LCD 控制标志
  this._lcdEnabled = (lcdc &amp; LCDC_FLAGS.LCD_ENABLE) !== 0;
  this._windowEnabled = (lcdc &amp; LCDC_FLAGS.WINDOW_ENABLE) !== 0;
  this._spritesEnabled = (lcdc &amp; LCDC_FLAGS.SPRITE_ENABLE) !== 0;
  this._backgroundEnabled = (lcdc &amp; LCDC_FLAGS.BG_ENABLE) !== 0;

  // 瓦片和地图选择
  this._backgroundTileSet = (lcdc &amp; LCDC_FLAGS.BG_TILESET) !== 0 ? 1 : 0;
  this._backgroundTileMap = (lcdc &amp; LCDC_FLAGS.BG_TILEMAP) !== 0 ? 1 : 0;
  this._windowTileMap = (lcdc &amp; LCDC_FLAGS.WINDOW_TILEMAP) !== 0 ? 1 : 0;
  this._spriteSize = (lcdc &amp; LCDC_FLAGS.SPRITE_SIZE) !== 0 ? 16 : 8;
&#125;</code></pre>
<p>GPU 提供完整的寄存器读写接口：</p>
<pre><code class="language-javascript">/**
 * 读取 GPU 寄存器
 * @param &#123;number&#125; address - 寄存器地址
 * @returns &#123;number&#125; 寄存器值
 */
readRegister(address) &#123;
  switch (address) &#123;
    // LCD 控制寄存器 (0xFF40)
    case GPU_REGISTERS.LCDC:
      return this.registers.lcdc;

    // LCD 状态寄存器 (0xFF41)
    case GPU_REGISTERS.STAT:
      // 组合状态标志位和当前模式
      let stat = this.registers.stat &amp; 0xF8; // 保留高 5 位
      stat |= (this.mode &amp; 0x03); // 添加当前模式
      
      // 检查 LYC=LY 标志
      if (this.registers.ly === this.registers.lyc) &#123;
        stat |= STAT_FLAGS.LYC_FLAG;
      &#125;
      
      return stat;

    // 滚动寄存器
    case GPU_REGISTERS.SCY:
      return this.registers.scy;

    case GPU_REGISTERS.SCX:
      return this.registers.scx;

    // 当前扫描线 (只读)
    case GPU_REGISTERS.LY:
      return this.registers.ly;

    // 扫描线比较值
    case GPU_REGISTERS.LYC:
      return this.registers.lyc;

    // DMA 寄存器 (写入专用，读取返回上次写入值)
    case GPU_REGISTERS.DMA:
      return this.registers.dma;

    // 调色板寄存器
    case GPU_REGISTERS.BGP:
      return this.registers.bgp;

    case GPU_REGISTERS.OBP0:
      return this.registers.obp0;

    case GPU_REGISTERS.OBP1:
      return this.registers.obp1;

    // 窗口位置寄存器
    case GPU_REGISTERS.WY:
      return this.registers.wy;

    case GPU_REGISTERS.WX:
      return this.registers.wx;

    default:
      console.warn(`⚠️ 尝试读取未知的 GPU 寄存器: 0x$&#123;address.toString(16).padStart(4, &#x27;0&#x27;)&#125;`);
      return 0xFF;
  &#125;
&#125;

/**
 * 写入 GPU 寄存器
 * @param &#123;number&#125; address - 寄存器地址
 * @param &#123;number&#125; value - 要写入的值
 */
writeRegister(address, value) &#123;
  // 确保值在 8 位范围内
  value &amp;= 0xFF;

  switch (address) &#123;
    // LCD 控制寄存器 (0xFF40)
    case GPU_REGISTERS.LCDC:
      this.registers.lcdc = value;
      this.updateControlFlags();
      
      // 当 LCD 被禁用时，重置一些状态
      if (!this._lcdEnabled) &#123;
        this.currentLine = 0;
        this.registers.ly = 0;
        this.mode = GPU_MODES.HBLANK;
        this.modeClock = 0;
      &#125;
      
      console.log(`🎛️ LCD 控制寄存器更新: 0x$&#123;value.toString(16).padStart(2, &#x27;0&#x27;)&#125;`);
      break;

    // LCD 状态寄存器 (0xFF41) - 只有高 5 位可写
    case GPU_REGISTERS.STAT:
      this.registers.stat = (value &amp; 0xF8) | (this.registers.stat &amp; 0x07);
      break;

    // 滚动寄存器
    case GPU_REGISTERS.SCY:
      this.registers.scy = value;
      // 通知图形系统滚动更新
      if (this.graphicsSystem &amp;&amp; this.graphicsSystem.scrollController) &#123;
        this.graphicsSystem.scrollController.setScrollY(value);
      &#125;
      break;

    case GPU_REGISTERS.SCX:
      this.registers.scx = value;
      // 通知图形系统滚动更新
      if (this.graphicsSystem &amp;&amp; this.graphicsSystem.scrollController) &#123;
        this.graphicsSystem.scrollController.setScrollX(value);
      &#125;
      break;

    // 当前扫描线 (只读寄存器，写入被忽略)
    case GPU_REGISTERS.LY:
      console.warn(`⚠️ 尝试写入只读寄存器 LY: 0x$&#123;value.toString(16)&#125;`);
      break;

    // 扫描线比较值
    case GPU_REGISTERS.LYC:
      this.registers.lyc = value;
      break;

    // DMA 传输寄存器 (0xFF46)
    case GPU_REGISTERS.DMA:
      this.registers.dma = value;
      this.performDMATransfer(value);
      break;

    // 背景调色板 (0xFF47)
    case GPU_REGISTERS.BGP:
      this.registers.bgp = value;
      this.updateBackgroundPalette(value);
      console.log(`🎨 背景调色板更新: 0x$&#123;value.toString(16).padStart(2, &#x27;0&#x27;)&#125;`);
      break;

    // 精灵调色板寄存器
    case GPU_REGISTERS.OBP0:
      this.registers.obp0 = value;
      // TODO: 实现精灵调色板更新 (第7章)
      break;

    case GPU_REGISTERS.OBP1:
      this.registers.obp1 = value;
      // TODO: 实现精灵调色板更新 (第7章)
      break;

    // 窗口位置寄存器
    case GPU_REGISTERS.WY:
      this.registers.wy = value;
      break;

    case GPU_REGISTERS.WX:
      this.registers.wx = value;
      break;

    default:
      console.warn(`⚠️ 尝试写入未知的 GPU 寄存器: 0x$&#123;address.toString(16).padStart(4, &#x27;0&#x27;)&#125; = 0x$&#123;value.toString(16).padStart(2, &#x27;0&#x27;)&#125;`);
  &#125;
&#125;</code></pre>
<p>DMA（直接内存访问）是 GameBoy 的重要功能，允许快速复制精灵数据到 OAM：</p>
<pre><code class="language-javascript">/**
 * 执行 DMA 传输
 * @param &#123;number&#125; sourceHigh - 源地址高字节
 */
performDMATransfer(sourceHigh) &#123;
  // DMA 传输：将 256 字节从 sourceHigh*0x100 复制到 OAM (0xFE00-0xFE9F)
  const sourceAddr = sourceHigh &lt;&lt; 8;
  
  console.log(`🚚 DMA 传输: 0x$&#123;sourceAddr.toString(16).padStart(4, &#x27;0&#x27;)&#125; -&gt; OAM`);
  
  // TODO: 实现完整的 DMA 传输逻辑
  // 需要从 MMU 读取数据并写入 OAM
  // 在真实硬件中，这会锁定总线并需要特定的时序
&#125;</code></pre>
<pre><code class="language-javascript">/**
 * 更新背景调色板
 * @param &#123;number&#125; paletteValue - 调色板寄存器值
 */
updateBackgroundPalette(paletteValue) &#123;
  if (this.graphicsSystem &amp;&amp; this.graphicsSystem.paletteManager) &#123;
    this.graphicsSystem.paletteManager.updatePaletteRegister(paletteValue);
  &#125;
&#125;</code></pre>
<h2 id="54-系统调度器架构"><a class="markdownIt-Anchor" href="#54-系统调度器架构"></a> 5.4. 系统调度器架构</h2>
<p>现在我们有了能够相互通信的硬件组件，但还需要一个“指挥家”来协调它们的工作。这就是系统调度器 <code>gameboy.js</code> 的作用。</p>
<p>系统调度器作为顶层管理器，负责创建、连接和管理所有硬件组件：</p>
<pre><code class="language-javascript">/**
 * 系统常量定义
 */
const SYSTEM_CONSTANTS = &#123;
  // 时序常量
  CPU_FREQUENCY: 4194304,      // 4.194304 MHz
  TARGET_FPS: 59.7,           // GameBoy 目标帧率
  FRAME_CYCLES: 70224,        // 每帧的 CPU 周期数
  
  // 系统状态
  STATE_STOPPED: &#x27;stopped&#x27;,
  STATE_RUNNING: &#x27;running&#x27;,
  STATE_PAUSED: &#x27;paused&#x27;,
  STATE_ERROR: &#x27;error&#x27;,
  
  // 调度模式
  SCHEDULE_FRAME: &#x27;frame&#x27;,     // 帧级别调度（默认）
  SCHEDULE_CYCLE: &#x27;cycle&#x27;,     // 周期级别调度（精确）
  SCHEDULE_BURST: &#x27;burst&#x27;      // 突发调度（性能优先）
&#125;;

/**
 * GameBoy 主系统类
 * 协调 CPU、MMU、GPU 和其他硬件组件的工作
 */
class GameBoySystem &#123;
  constructor() &#123;
    // 系统状态
    this.state = SYSTEM_CONSTANTS.STATE_STOPPED;
    this.scheduleMode = SYSTEM_CONSTANTS.SCHEDULE_FRAME;

    // 硬件组件
    this.cpu = null;
    this.mmu = null;
    this.gpu = null;
    this.graphics = null;

    // 调度器状态
    this.runningInterval = null;
    this.frameRequestId = null;
    
    // 性能统计
    this.stats = &#123;
      framesRendered: 0,
      cyclesExecuted: 0,
      startTime: 0,
      currentFPS: 0,
      averageFPS: 0,
      errors: 0
    &#125;;
  &#125;
&#125;</code></pre>
<p>系统调度器的初始化过程展示了完整的组件连接流程：</p>
<pre><code class="language-javascript">/**
 * 创建硬件组件实例
 */
async createHardwareComponents() &#123;
  // 创建 MMU（内存管理单元）
  this.mmu = new GameBoyMMU();
  console.log(&#x27;✅ MMU 已创建&#x27;);

  // 创建 GPU（图形处理单元）
  this.gpu = new GameBoyGPU();
  console.log(&#x27;✅ GPU 已创建&#x27;);

  // 获取图形系统引用
  if (this.gpu.graphicsSystem) &#123;
    this.graphics = this.gpu.graphicsSystem;
    console.log(&#x27;✅ 图形系统已连接&#x27;);
  &#125;

  // 创建 CPU（中央处理器）
  this.cpu = new GameBoyCPU();
  console.log(&#x27;✅ CPU 已创建&#x27;);
&#125;

/**
 * 连接硬件组件
 */
connectComponents() &#123;
  // 连接 GPU 到 MMU
  this.mmu.connectHardware(&#x27;gpu&#x27;, this.gpu);

  // 连接 GPU 到 VRAM
  if (this.mmu.vram) &#123;
    this.gpu.connectVRAM(this.mmu.vram);

    // 连接图形系统到 VRAM
    if (this.graphics) &#123;
      this.graphics.connectVRAM(this.mmu.vram);
    &#125;
  &#125;

  console.log(&#x27;🔗 硬件组件连接完成&#x27;);
&#125;</code></pre>
<p>这个连接过程确保了：</p>
<ol>
<li>GPU 能够通过 MMU 接收寄存器访问</li>
<li>GPU 能够直接访问 VRAM 进行渲染</li>
<li>图形系统能够接收 VRAM 更新通知</li>
</ol>
<h2 id="55-帧级别时序调度"><a class="markdownIt-Anchor" href="#55-帧级别时序调度"></a> 5.5. 帧级别时序调度</h2>
<p>先前我们实现了精确的周期级别时序，但在实际运行中这种精确度往往会带来性能负担，因此我们当时引入了帧级别调度，在保持足够精度的同时大幅提升性能。现在我们完善一下当时只是简化版本的 <code>stepFrame()</code>。</p>
<pre><code class="language-javascript">/**
 * 每次调用渲染一整帧，避免复杂的周期计算
 */
stepFrame() &#123;
  // 如果 LCD 被禁用，不渲染
  if (!this._lcdEnabled) &#123;
    return;
  &#125;

  // 1. 渲染所有可见扫描线 (0-143)
  for (let line = 0; line &lt; GPU_TIMINGS.VISIBLE_LINES; line++) &#123;
    this.currentLine = line;
    this.registers.ly = line;
    this.mode = GPU_MODES.PIXEL_TRANSFER;
    this.renderScanline();
  &#125;

  // 2. 模拟垂直消隐期间 (144-153)
  this.mode = GPU_MODES.VBLANK;
  this.currentLine = GPU_TIMINGS.VISIBLE_LINES;
  this.registers.ly = GPU_TIMINGS.VISIBLE_LINES;

  // 3. 完成帧渲染
  this.onFrameComplete();

  // 4. 重置到下一帧开始
  this.currentLine = 0;
  this.registers.ly = 0;
  this.mode = GPU_MODES.OAM_SEARCH;
  this.modeClock = 0;
&#125;</code></pre>
<p>系统调度器支持多种调度模式以适应不同的需求：</p>
<pre><code class="language-javascript">/**
 * 帧级别调度循环（默认模式）
 */
startFrameLoop() &#123;
  const frameLoop = (currentTime) =&gt; &#123;
    if (this.state !== SYSTEM_CONSTANTS.STATE_RUNNING) &#123;
      return;
    &#125;

    try &#123;
      // 计算时间差
      const deltaTime = currentTime - this.lastFrameTime;

      // 如果达到目标帧时间，执行一帧
      if (deltaTime &gt;= this.targetFrameTime) &#123;
        this.executeFrame();
        this.lastFrameTime = currentTime;
        this.updateFPS(deltaTime);
      &#125;

      // 请求下一帧
      this.frameRequestId = requestAnimationFrame(frameLoop);

    &#125; catch (error) &#123;
      this.handleError(error);
    &#125;
  &#125;;

  // 启动循环
  this.frameRequestId = requestAnimationFrame(frameLoop);
&#125;

/**
 * 执行一帧的渲染
 */
executeFrame() &#123;
  // TODO: 简化的帧执行：直接让 GPU 渲染一帧
  if (this.gpu) &#123;
    this.gpu.stepFrame();
  &#125;

  // 更新统计
  this.stats.framesRendered++;
  this.stats.cyclesExecuted += SYSTEM_CONSTANTS.FRAME_CYCLES;
&#125;</code></pre>
<p>这种设计的优势是：</p>
<ul>
<li>性能优化：避免了复杂的周期级别计算</li>
<li>稳定的帧率：使用 <code>requestAnimationFrame</code> 确保流畅的 60 FPS</li>
<li>灵活性：可以根据需要切换到其他调度模式</li>
</ul>
<h2 id="56-错误处理与系统监控"><a class="markdownIt-Anchor" href="#56-错误处理与系统监控"></a> 5.6. 错误处理与系统监控</h2>
<p>一个健壮的模拟器必须能够优雅地处理错误并提供丰富的监控信息。系统调度器实现了多层次的错误处理：</p>
<pre><code class="language-javascript">/**
 * 错误处理
 */
handleError(error) &#123;
  this.stats.errors++;

  console.error(`🚨 系统错误 #$&#123;this.stats.errors&#125;:`, error);

  // 如果错误过多，停止系统
  if (this.stats.errors &gt; 10) &#123;
    console.error(&#x27;❌ 错误过多，停止系统运行&#x27;);
    this.stop();
    this.state = SYSTEM_CONSTANTS.STATE_ERROR;
    return;
  &#125;

  // 尝试恢复
  this.retryCount++;
  if (this.retryCount &lt; this.maxRetries) &#123;
    console.log(`🔄 尝试恢复系统 ($&#123;this.retryCount&#125;/$&#123;this.maxRetries&#125;)`);
    setTimeout(() =&gt; &#123;
      if (this.state === SYSTEM_CONSTANTS.STATE_ERROR) &#123;
        this.reset();
      &#125;
    &#125;, 1000);
  &#125; else &#123;
    console.error(&#x27;❌ 恢复失败，系统进入错误状态&#x27;);
    this.state = SYSTEM_CONSTANTS.STATE_ERROR;
  &#125;
&#125;</code></pre>
<p>系统提供了丰富的性能统计信息：</p>
<pre><code class="language-javascript">/**
 * 更新 FPS 计算
 * @param &#123;number&#125; deltaTime - 帧时间差
 */
updateFPS(deltaTime) &#123;
  this.stats.currentFPS = deltaTime &gt; 0 ? 1000 / deltaTime : 0;
&#125;

/**
 * 计算平均 FPS
 */
calculateAverageFPS() &#123;
  const totalTime = (performance.now() - this.stats.startTime) / 1000;
  this.stats.averageFPS = totalTime &gt; 0 ? this.stats.framesRendered / totalTime : 0;
&#125;

/**
 * 获取系统状态
 */
getStatus() &#123;
  const status = &#123;
    state: this.state,
    scheduleMode: this.scheduleMode,
    statistics: &#123; ...this.stats &#125;,
    components: &#123;
      cpu: this.cpu ? this.cpu.getStatusString() : &#x27;未初始化&#x27;,
      mmu: this.mmu ? this.mmu.getMemoryStats() : &#x27;未初始化&#x27;,
      gpu: this.gpu ? this.gpu.getStatus() : &#x27;未初始化&#x27;
    &#125;
  &#125;;

  // 计算实时统计
  if (this.stats.startTime &gt; 0) &#123;
    const totalTime = (performance.now() - this.stats.startTime) / 1000;
    status.statistics.totalRunTime = totalTime;
    status.statistics.averageFPS = totalTime &gt; 0 ? this.stats.framesRendered / totalTime : 0;
  &#125;

  return status;
&#125;

/**
 * 获取调试信息
 * @returns &#123;string&#125; 格式化的调试信息
 */
getDebugInfo() &#123;
  const status = this.getStatus();

  let debugInfo = `🎮 === GameBoy 系统状态 ===
系统状态：$&#123;status.state&#125;
调度模式：$&#123;status.scheduleMode&#125;
运行时间：$&#123;status.statistics.totalRunTime?.toFixed(2) || 0&#125;秒
已渲染帧数：$&#123;status.statistics.framesRendered&#125;
执行周期数：$&#123;status.statistics.cyclesExecuted&#125;
当前 FPS：$&#123;status.statistics.currentFPS?.toFixed(2) || 0&#125;
平均 FPS：$&#123;status.statistics.averageFPS?.toFixed(2) || 0&#125;
错误计数：$&#123;status.statistics.errors&#125;

📱 硬件组件状态：`;

  // CPU 状态
  if (this.cpu) &#123;
    debugInfo += `\n\n💻 CPU 状态：\n$&#123;this.cpu.getStatusString()&#125;`;
  &#125;

  // GPU 状态
  if (this.gpu) &#123;
    debugInfo += `\n\n🎨 GPU 状态：\n$&#123;this.gpu.getDebugInfo()&#125;`;
  &#125;

  // MMU 状态
  if (this.mmu) &#123;
    const mmuStats = this.mmu.getMemoryStats();
    debugInfo += `\n\n💾 MMU 状态：
BIOS 启用：$&#123;mmuStats.biosEnabled ? &#x27;是&#x27; : &#x27;否&#x27;&#125;
ROM 已加载：$&#123;mmuStats.romLoaded ? &#x27;是&#x27; : &#x27;否&#x27;&#125;
硬件连接：
GPU: $&#123;mmuStats.hardwareConnections.gpu ? &#x27;✅&#x27; : &#x27;❌&#x27;&#125;
输入: $&#123;mmuStats.hardwareConnections.input ? &#x27;✅&#x27; : &#x27;❌&#x27;&#125;
定时器: $&#123;mmuStats.hardwareConnections.timer ? &#x27;✅&#x27; : &#x27;❌&#x27;&#125;
中断: $&#123;mmuStats.hardwareConnections.interrupt ? &#x27;✅&#x27; : &#x27;❌&#x27;&#125;`;
  &#125;

  return debugInfo;
&#125;

/**
 * 获取内存转储
 * @param &#123;number&#125; address - 起始地址
 * @param &#123;number&#125; length - 长度
 * @returns &#123;string&#125; 内存转储
 */
getMemoryDump(address, length = 256) &#123;
  if (!this.mmu) &#123;
    return &#x27;❌ MMU 未初始化&#x27;;
  &#125;

  return this.mmu.getMemoryDump(address, length);
&#125;

/**
 * 设置调试模式
 * @param &#123;boolean&#125; enabled - 是否启用调试模式
 */
setDebugMode(enabled) &#123;
  window.DEBUG_MODE = enabled;
  console.log(`🔧 调试模式$&#123;enabled ? &#x27;已启用&#x27; : &#x27;已禁用&#x27;&#125;`);
&#125;

/**
 * 销毁系统（清理资源）
 */
destroy() &#123;
  console.log(&#x27;💥 销毁 GameBoy 系统...&#x27;);

  // 停止运行
  this.stop();

  // 清理组件引用
  this.cpu = null;
  this.mmu = null;
  this.gpu = null;
  this.graphics = null;

  // 清理全局引用
  if (window.MMU) delete window.MMU;
  if (window.GPU) delete window.GPU;
  if (window.CPU) delete window.CPU;
  if (window.Graphics) delete window.Graphics;

  console.log(&#x27;✅ 系统已销毁&#x27;);
&#125;</code></pre>
<h2 id="57-现代化用户界面"><a class="markdownIt-Anchor" href="#57-现代化用户界面"></a> 5.7. 现代化用户界面</h2>
<details>
<summary>展开以查看</summary>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;zh-CN&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;GameBoy 模拟器 - JavaScript 版本&lt;/title&gt;
  &lt;style&gt;
    /* 全局样式重置 */
    * &#123;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    &#125;

    body &#123;
      font-family: &#x27;Courier New&#x27;, monospace;
      background: linear-gradient(135deg, #2c5530, #4a7c59);
      color: #000;
      min-height: 100vh;
      padding: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
    &#125;

    /* 主容器 */
    .gameboy-container &#123;
      background: linear-gradient(145deg, #8b956d, #9bb583);
      border-radius: 20px 20px 60px 20px;
      padding: 40px;
      box-shadow:
              0 20px 40px rgba(0, 0, 0, 0.3),
              inset 0 2px 4px rgba(255, 255, 255, 0.1);
      max-width: 700px;
      width: 100%;
    &#125;

    /* 顶部标题区域 */
    .header &#123;
      text-align: center;
      margin-bottom: 30px;
    &#125;

    .title &#123;
      font-size: 28px;
      font-weight: bold;
      color: #2c5530;
      text-shadow:
              1px 1px 0 rgba(255, 255, 255, 0.3),
              2px 2px 4px rgba(0, 0, 0, 0.2);
      margin-bottom: 10px;
      letter-spacing: 2px;
    &#125;

    .subtitle &#123;
      font-size: 14px;
      color: #5a6b4d;
      margin-bottom: 5px;
    &#125;

    .version &#123;
      font-size: 12px;
      color: #6b7a5e;
      font-style: italic;
    &#125;

    /* 屏幕区域 */
    .screen-container &#123;
      background: linear-gradient(145deg, #4a5c3a, #5a6c4a);
      border-radius: 15px;
      padding: 25px;
      margin: 30px auto;
      box-shadow:
              inset 0 4px 8px rgba(0, 0, 0, 0.3),
              0 2px 4px rgba(255, 255, 255, 0.1);
      position: relative;
      width: fit-content;
    &#125;

    .screen-bezel &#123;
      background: linear-gradient(145deg, #2c3624, #3c4634);
      border-radius: 10px;
      padding: 15px;
      box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.5);
    &#125;

    /* GameBoy 屏幕 Canvas */
    #screen &#123;
      display: block;
      width: 320px;
      height: 288px;
      background: #9bbc0f;
      border-radius: 5px;
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
      box-shadow:
              inset 0 0 0 2px #8bac0f,
              inset 0 0 0 4px #5a6b4d;
    &#125;

    /* 屏幕标签 */
    .screen-label &#123;
      position: absolute;
      bottom: 8px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      color: #6b7a5e;
      letter-spacing: 1px;
    &#125;

    /* 系统状态指示器 */
    .status-indicator &#123;
      position: absolute;
      top: 15px;
      right: 15px;
      display: flex;
      gap: 8px;
      font-size: 10px;
    &#125;

    .indicator &#123;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 1px solid #333;
    &#125;

    .indicator.running &#123; background: #00ff00; &#125;
    .indicator.stopped &#123; background: #ff0000; &#125;
    .indicator.paused &#123; background: #ffff00; &#125;
    .indicator.error &#123; background: #ff8800; &#125;

    /* 控制面板 */
    .controls &#123;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-top: 30px;
    &#125;

    .control-section &#123;
      background: linear-gradient(145deg, #7a8a6d, #8a9a7d);
      border-radius: 12px;
      padding: 20px;
      box-shadow:
              inset 0 2px 4px rgba(255, 255, 255, 0.1),
              0 4px 8px rgba(0, 0, 0, 0.2);
    &#125;

    .control-title &#123;
      font-size: 14px;
      font-weight: bold;
      color: #2c5530;
      margin-bottom: 15px;
      text-align: center;
      border-bottom: 1px solid #5a6b4d;
      padding-bottom: 8px;
    &#125;

    /* 按钮样式 */
    .btn &#123;
      background: linear-gradient(145deg, #a5b588, #95a578);
      border: none;
      border-radius: 8px;
      padding: 12px 20px;
      color: #2c5530;
      font-weight: bold;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow:
              0 3px 6px rgba(0, 0, 0, 0.2),
              inset 0 1px 2px rgba(255, 255, 255, 0.2);
      margin: 5px;
      width: calc(100% - 10px);
      position: relative;
    &#125;

    .btn:hover &#123;
      background: linear-gradient(145deg, #b5c598, #a5b588);
      transform: translateY(-1px);
      box-shadow:
              0 4px 8px rgba(0, 0, 0, 0.3),
              inset 0 1px 2px rgba(255, 255, 255, 0.3);
    &#125;

    .btn:active &#123;
      transform: translateY(1px);
      box-shadow:
              0 2px 4px rgba(0, 0, 0, 0.2),
              inset 0 2px 4px rgba(0, 0, 0, 0.1);
    &#125;

    .btn:disabled &#123;
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    &#125;

    .btn.primary &#123;
      background: linear-gradient(145deg, #5a7c4a, #4a6c3a);
      color: #fff;
    &#125;

    .btn.primary:hover:not(:disabled) &#123;
      background: linear-gradient(145deg, #6a8c5a, #5a7c4a);
    &#125;

    .btn.danger &#123;
      background: linear-gradient(145deg, #a56565, #955555);
      color: #fff;
    &#125;

    .btn.danger:hover:not(:disabled) &#123;
      background: linear-gradient(145deg, #b57575, #a56565);
    &#125;

    .btn.success &#123;
      background: linear-gradient(145deg, #5a8a5a, #4a7a4a);
      color: #fff;
    &#125;

    .btn.success:hover:not(:disabled) &#123;
      background: linear-gradient(145deg, #6a9a6a, #5a8a5a);
    &#125;

    /* 按钮状态指示 */
    .btn.loading::after &#123;
      content: &#x27;&#x27;;
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      width: 12px;
      height: 12px;
      border: 2px solid transparent;
      border-top: 2px solid currentColor;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    &#125;

    @keyframes spin &#123;
      to &#123; transform: translateY(-50%) rotate(360deg); &#125;
    &#125;

    /* 状态显示区域 */
    .status-panel &#123;
      margin-top: 30px;
      background: linear-gradient(145deg, #3c4634, #4c5644);
      border-radius: 12px;
      padding: 20px;
      box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.3);
    &#125;

    .status-title &#123;
      color: #9bb583;
      font-size: 14px;
      font-weight: bold;
      margin-bottom: 15px;
      text-align: center;
    &#125;

    .status-content &#123;
      background: #1a1a1a;
      color: #00ff00;
      font-family: &#x27;Courier New&#x27;, monospace;
      font-size: 11px;
      padding: 15px;
      border-radius: 6px;
      height: 250px;
      overflow-y: auto;
      border: 1px solid #333;
      white-space: pre-wrap;
    &#125;

    /* 性能面板 */
    .performance-panel &#123;
      margin-top: 20px;
      background: linear-gradient(145deg, #2c3624, #3c4634);
      border-radius: 12px;
      padding: 20px;
      box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.3);
    &#125;

    .performance-grid &#123;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 15px;
      margin-top: 15px;
    &#125;

    .performance-item &#123;
      text-align: center;
      padding: 10px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
    &#125;

    .performance-value &#123;
      display: block;
      font-size: 18px;
      font-weight: bold;
      color: #00ff00;
      margin-bottom: 5px;
    &#125;

    .performance-label &#123;
      font-size: 10px;
      color: #9bb583;
      text-transform: uppercase;
    &#125;

    /* 响应式设计 */
    @media (max-width: 768px) &#123;
      .gameboy-container &#123;
        padding: 20px;
        margin: 10px;
      &#125;

      #screen &#123;
        width: 240px;
        height: 216px;
      &#125;

      .controls &#123;
        grid-template-columns: 1fr;
        gap: 15px;
      &#125;

      .title &#123;
        font-size: 24px;
      &#125;

      .performance-grid &#123;
        grid-template-columns: repeat(2, 1fr);
      &#125;
    &#125;

    /* 信息提示 */
    .info-box &#123;
      background: linear-gradient(145deg, #6a7c5a, #7a8c6a);
      border-radius: 8px;
      padding: 15px;
      margin: 20px 0;
      border-left: 4px solid #4a6c3a;
      color: #2c5530;
      font-size: 13px;
      line-height: 1.5;
    &#125;

    .info-box h4 &#123;
      margin-bottom: 8px;
      color: #1a3520;
    &#125;

    /* 键盘快捷键显示 */
    .keyboard-hint &#123;
      font-size: 10px;
      color: #6b7a5e;
      text-align: center;
      margin-top: 10px;
    &#125;

    .key &#123;
      background: #5a6b4d;
      color: #fff;
      padding: 2px 6px;
      border-radius: 3px;
      font-weight: bold;
      margin: 0 2px;
    &#125;
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;gameboy-container&quot;&gt;
  &lt;!-- 顶部标题区域 --&gt;
  &lt;div class=&quot;header&quot;&gt;
    &lt;h1 class=&quot;title&quot;&gt;GAME BOY&lt;/h1&gt;
    &lt;div class=&quot;subtitle&quot;&gt;JavaScript 模拟器&lt;/div&gt;
    &lt;div class=&quot;version&quot;&gt;版本 0.5.0 - 系统集成&lt;/div&gt;
  &lt;/div&gt;

  &lt;!-- 屏幕区域 --&gt;
  &lt;div class=&quot;screen-container&quot;&gt;
    &lt;div class=&quot;status-indicator&quot;&gt;
      &lt;div class=&quot;indicator stopped&quot; id=&quot;system-indicator&quot; title=&quot;系统状态&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;screen-bezel&quot;&gt;
      &lt;canvas id=&quot;screen&quot; width=&quot;160&quot; height=&quot;144&quot;&gt;&lt;/canvas&gt;
      &lt;div class=&quot;screen-label&quot;&gt;DOT MATRIX WITH STEREO SOUND&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;!-- 控制面板 --&gt;
  &lt;div class=&quot;controls&quot;&gt;
    &lt;!-- 系统控制 --&gt;
    &lt;div class=&quot;control-section&quot;&gt;
      &lt;div class=&quot;control-title&quot;&gt;🎮 系统控制&lt;/div&gt;
      &lt;button class=&quot;btn primary&quot; id=&quot;init-btn&quot;&gt;初始化系统&lt;/button&gt;
      &lt;button class=&quot;btn success&quot; id=&quot;start-btn&quot; disabled&gt;开始运行&lt;/button&gt;
      &lt;button class=&quot;btn&quot; id=&quot;pause-btn&quot; disabled&gt;暂停/恢复&lt;/button&gt;
      &lt;button class=&quot;btn danger&quot; id=&quot;stop-btn&quot; disabled&gt;停止运行&lt;/button&gt;
      &lt;button class=&quot;btn&quot; id=&quot;reset-btn&quot; disabled&gt;重置系统&lt;/button&gt;
      &lt;div class=&quot;keyboard-hint&quot;&gt;
        快捷键：&lt;span class=&quot;key&quot;&gt;Space&lt;/span&gt; 开始/暂停 &lt;span class=&quot;key&quot;&gt;R&lt;/span&gt; 重置
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- 程序加载 --&gt;
    &lt;div class=&quot;control-section&quot;&gt;
      &lt;div class=&quot;control-title&quot;&gt;📦 程序加载&lt;/div&gt;
      &lt;button class=&quot;btn&quot; id=&quot;load-demo-btn&quot; disabled&gt;加载演示程序&lt;/button&gt;
      &lt;button class=&quot;btn&quot; id=&quot;load-rom-btn&quot; disabled&gt;加载 ROM 文件&lt;/button&gt;
      &lt;input type=&quot;file&quot; id=&quot;rom-file-input&quot; accept=&quot;.gb,.gbc&quot; style=&quot;display: none;&quot;&gt;
      &lt;button class=&quot;btn&quot; id=&quot;step-btn&quot; disabled&gt;单步执行&lt;/button&gt;
      &lt;div class=&quot;keyboard-hint&quot;&gt;
        快捷键：&lt;span class=&quot;key&quot;&gt;L&lt;/span&gt; 加载演示 &lt;span class=&quot;key&quot;&gt;S&lt;/span&gt; 单步
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;!-- 调试和图形控制 --&gt;
  &lt;div class=&quot;controls&quot;&gt;
    &lt;!-- 调试工具 --&gt;
    &lt;div class=&quot;control-section&quot;&gt;
      &lt;div class=&quot;control-title&quot;&gt;🔧 调试工具&lt;/div&gt;
      &lt;button class=&quot;btn&quot; id=&quot;show-status-btn&quot;&gt;显示系统状态&lt;/button&gt;
      &lt;button class=&quot;btn&quot; id=&quot;show-memory-btn&quot;&gt;内存转储&lt;/button&gt;
      &lt;button class=&quot;btn&quot; id=&quot;show-registers-btn&quot;&gt;CPU 寄存器&lt;/button&gt;
      &lt;button class=&quot;btn&quot; id=&quot;toggle-debug-btn&quot;&gt;切换调试模式&lt;/button&gt;
      &lt;div class=&quot;keyboard-hint&quot;&gt;
        快捷键：&lt;span class=&quot;key&quot;&gt;D&lt;/span&gt; 调试 &lt;span class=&quot;key&quot;&gt;M&lt;/span&gt; 内存
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- 图形控制 --&gt;
    &lt;div class=&quot;control-section&quot;&gt;
      &lt;div class=&quot;control-title&quot;&gt;🎨 图形控制&lt;/div&gt;
      &lt;button class=&quot;btn&quot; id=&quot;toggle-render-btn&quot;&gt;切换渲染模式&lt;/button&gt;
      &lt;button class=&quot;btn&quot; id=&quot;show-graphics-btn&quot;&gt;图形系统状态&lt;/button&gt;
      &lt;button class=&quot;btn&quot; id=&quot;test-graphics-btn&quot;&gt;测试图形渲染&lt;/button&gt;
      &lt;button class=&quot;btn danger&quot; id=&quot;clear-console-btn&quot;&gt;清空控制台&lt;/button&gt;
      &lt;div class=&quot;keyboard-hint&quot;&gt;
        快捷键：&lt;span class=&quot;key&quot;&gt;G&lt;/span&gt; 图形模式 &lt;span class=&quot;key&quot;&gt;T&lt;/span&gt; 测试
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;!-- 性能监控面板 --&gt;
  &lt;div class=&quot;performance-panel&quot;&gt;
    &lt;div class=&quot;status-title&quot;&gt;📊 实时性能监控&lt;/div&gt;
    &lt;div class=&quot;performance-grid&quot;&gt;
      &lt;div class=&quot;performance-item&quot;&gt;
        &lt;span class=&quot;performance-value&quot; id=&quot;fps-value&quot;&gt;0.0&lt;/span&gt;
        &lt;span class=&quot;performance-label&quot;&gt;FPS&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&quot;performance-item&quot;&gt;
        &lt;span class=&quot;performance-value&quot; id=&quot;frames-value&quot;&gt;0&lt;/span&gt;
        &lt;span class=&quot;performance-label&quot;&gt;帧数&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&quot;performance-item&quot;&gt;
        &lt;span class=&quot;performance-value&quot; id=&quot;instructions-value&quot;&gt;0&lt;/span&gt;
        &lt;span class=&quot;performance-label&quot;&gt;指令数&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&quot;performance-item&quot;&gt;
        &lt;span class=&quot;performance-value&quot; id=&quot;cycles-value&quot;&gt;0&lt;/span&gt;
        &lt;span class=&quot;performance-label&quot;&gt;周期数&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&quot;performance-item&quot;&gt;
        &lt;span class=&quot;performance-value&quot; id=&quot;errors-value&quot;&gt;0&lt;/span&gt;
        &lt;span class=&quot;performance-label&quot;&gt;错误数&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&quot;performance-item&quot;&gt;
        &lt;span class=&quot;performance-value&quot; id=&quot;uptime-value&quot;&gt;0s&lt;/span&gt;
        &lt;span class=&quot;performance-label&quot;&gt;运行时间&lt;/span&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;!-- 状态显示面板 --&gt;
  &lt;div class=&quot;status-panel&quot;&gt;
    &lt;div class=&quot;status-title&quot;&gt;📋 系统控制台 &amp; 调试输出&lt;/div&gt;
    &lt;div id=&quot;console-output&quot; class=&quot;status-content&quot;&gt;GameBoy 模拟器 v0.5.0 已准备就绪...
🎮 第五章：系统集成
✨ 新功能：完整的系统架构、CPU 指令集、寄存器控制

等待系统初始化...

使用说明：
1. 点击&quot;初始化系统&quot;启动模拟器
2. 点击&quot;加载演示程序&quot;或加载 ROM 文件
3. 点击&quot;开始运行&quot;启动系统
4. 观察实时性能监控和调试输出
5. 使用调试工具查看系统状态

组件状态：
- CPU: 等待初始化...
- MMU: 等待初始化...
- GPU: 等待初始化...
- 图形系统: 等待初始化...
- 系统调度器: 等待初始化...
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;!-- JavaScript 文件导入 --&gt;
&lt;script src=&quot;mmu.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;graphics.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;gpu.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;cpu.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;gameboy.js&quot;&gt;&lt;/script&gt;

&lt;!-- 主程序脚本 --&gt;
&lt;script&gt;
(function() &#123;
  &#x27;use strict&#x27;;
  
  // 全局变量
  let systemInstance = null;  // 避免与 gameboy.js 中的变量冲突
  let performanceUpdateInterval = null;
  let isDebugMode = false;

  // UI 元素引用
  const elements = &#123;
    // 按钮
    initBtn: document.getElementById(&#x27;init-btn&#x27;),
    startBtn: document.getElementById(&#x27;start-btn&#x27;),
    pauseBtn: document.getElementById(&#x27;pause-btn&#x27;),
    stopBtn: document.getElementById(&#x27;stop-btn&#x27;),
    resetBtn: document.getElementById(&#x27;reset-btn&#x27;),
    loadDemoBtn: document.getElementById(&#x27;load-demo-btn&#x27;),
    loadRomBtn: document.getElementById(&#x27;load-rom-btn&#x27;),
    stepBtn: document.getElementById(&#x27;step-btn&#x27;),
    showStatusBtn: document.getElementById(&#x27;show-status-btn&#x27;),
    showMemoryBtn: document.getElementById(&#x27;show-memory-btn&#x27;),
    showRegistersBtn: document.getElementById(&#x27;show-registers-btn&#x27;),
    toggleDebugBtn: document.getElementById(&#x27;toggle-debug-btn&#x27;),
    toggleRenderBtn: document.getElementById(&#x27;toggle-render-btn&#x27;),
    showGraphicsBtn: document.getElementById(&#x27;show-graphics-btn&#x27;),
    testGraphicsBtn: document.getElementById(&#x27;test-graphics-btn&#x27;),
    clearConsoleBtn: document.getElementById(&#x27;clear-console-btn&#x27;),
    
    // 状态指示器
    systemIndicator: document.getElementById(&#x27;system-indicator&#x27;),
    
    // 性能显示
    fpsValue: document.getElementById(&#x27;fps-value&#x27;),
    framesValue: document.getElementById(&#x27;frames-value&#x27;),
    instructionsValue: document.getElementById(&#x27;instructions-value&#x27;),
    cyclesValue: document.getElementById(&#x27;cycles-value&#x27;),
    errorsValue: document.getElementById(&#x27;errors-value&#x27;),
    uptimeValue: document.getElementById(&#x27;uptime-value&#x27;),
    
    // 控制台输出
    consoleOutput: document.getElementById(&#x27;console-output&#x27;),
    
    // 文件输入
    romFileInput: document.getElementById(&#x27;rom-file-input&#x27;)
  &#125;;

  // 添加日志输出功能
  function addLog(message, type = &#x27;info&#x27;) &#123;
    const timestamp = new Date().toLocaleTimeString();
    const prefix = &#123;
      &#x27;info&#x27;: &#x27;📝&#x27;,
      &#x27;success&#x27;: &#x27;✅&#x27;,
      &#x27;warning&#x27;: &#x27;⚠️&#x27;,
      &#x27;error&#x27;: &#x27;❌&#x27;,
      &#x27;debug&#x27;: &#x27;🔧&#x27;
    &#125;[type] || &#x27;📝&#x27;;
    
    elements.consoleOutput.textContent += `[$&#123;timestamp&#125;] $&#123;prefix&#125; $&#123;message&#125;\n`;
    elements.consoleOutput.scrollTop = elements.consoleOutput.scrollHeight;
  &#125;

  // 重写 console.log 以在页面上显示
  const originalConsoleLog = console.log;
  const originalConsoleError = console.error;
  const originalConsoleWarn = console.warn;

  console.log = function(...args) &#123;
    originalConsoleLog.apply(console, args);
    const message = args.join(&#x27; &#x27;);
    
    // 只有重要消息才显示到页面
    const importantKeywords = [&#x27;✅&#x27;, &#x27;❌&#x27;, &#x27;⚠️&#x27;, &#x27;🎮&#x27;, &#x27;📊&#x27;, &#x27;🔧&#x27;, &#x27;初始化&#x27;, &#x27;加载&#x27;, &#x27;错误&#x27;, &#x27;完成&#x27;];
    if (importantKeywords.some(keyword =&gt; message.includes(keyword)) || isDebugMode) &#123;
      addLog(message);
    &#125;
  &#125;;

  console.error = function(...args) &#123;
    originalConsoleError.apply(console, args);
    addLog(args.join(&#x27; &#x27;), &#x27;error&#x27;);
  &#125;;

  console.warn = function(...args) &#123;
    originalConsoleWarn.apply(console, args);
    addLog(args.join(&#x27; &#x27;), &#x27;warning&#x27;);
  &#125;;

  // 更新系统状态指示器
  function updateSystemIndicator(state) &#123;
    const indicator = elements.systemIndicator;
    indicator.className = `indicator $&#123;state&#125;`;
    indicator.title = `系统状态: $&#123;state&#125;`;
  &#125;

  // 更新按钮状态
  function updateButtonStates(systemState) &#123;
    const isInitialized = systemInstance !== null;
    const isRunning = systemState === &#x27;running&#x27;;
    const isStopped = systemState === &#x27;stopped&#x27;;
    
    elements.initBtn.disabled = isInitialized;
    elements.startBtn.disabled = !isInitialized || isRunning;
    elements.pauseBtn.disabled = !isInitialized || isStopped;
    elements.stopBtn.disabled = !isInitialized || isStopped;
    elements.resetBtn.disabled = !isInitialized;
    elements.loadDemoBtn.disabled = !isInitialized;
    elements.loadRomBtn.disabled = !isInitialized;
    elements.stepBtn.disabled = !isInitialized || isRunning;
  &#125;

  // 系统初始化
  async function initializeSystem() &#123;
    try &#123;
      addLog(&#x27;正在初始化 GameBoy 系统...&#x27;, &#x27;info&#x27;);
      elements.initBtn.classList.add(&#x27;loading&#x27;);
      
      // 使用系统控制器
      systemInstance = await window.GameBoySystemController.init();
      
      updateSystemIndicator(&#x27;stopped&#x27;);
      updateButtonStates(&#x27;stopped&#x27;);
      
      // 启动性能监控
      startPerformanceMonitoring();
      
      addLog(&#x27;✅ GameBoy 系统初始化完成&#x27;, &#x27;success&#x27;);
      
    &#125; catch (error) &#123;
      addLog(`❌ 系统初始化失败: $&#123;error.message&#125;`, &#x27;error&#x27;);
      updateSystemIndicator(&#x27;error&#x27;);
    &#125; finally &#123;
      elements.initBtn.classList.remove(&#x27;loading&#x27;);
    &#125;
  &#125;

  // 系统控制函数
  function startSystem() &#123;
    if (!systemInstance) &#123;
      addLog(&#x27;❌ 系统未初始化&#x27;, &#x27;error&#x27;);
      return;
    &#125;

    try &#123;
      window.GameBoySystemController.start();
      updateSystemIndicator(&#x27;running&#x27;);
      updateButtonStates(&#x27;running&#x27;);
      addLog(&#x27;🚀 系统开始运行&#x27;, &#x27;success&#x27;);
    &#125; catch (error) &#123;
      addLog(`❌ 启动失败: $&#123;error.message&#125;`, &#x27;error&#x27;);
    &#125;
  &#125;

  function pauseSystem() &#123;
    if (!systemInstance) return;
    
    try &#123;
      window.GameBoySystemController.togglePause();
      const status = window.GameBoySystemController.getStatus();
      updateSystemIndicator(status.state);
      updateButtonStates(status.state);
      addLog(`⏸️ 系统$&#123;status.state === &#x27;paused&#x27; ? &#x27;已暂停&#x27; : &#x27;继续运行&#x27;&#125;`, &#x27;info&#x27;);
    &#125; catch (error) &#123;
      addLog(`❌ 暂停操作失败: $&#123;error.message&#125;`, &#x27;error&#x27;);
    &#125;
  &#125;

  function stopSystem() &#123;
    if (!systemInstance) return;
    
    try &#123;
      window.GameBoySystemController.stop();
      updateSystemIndicator(&#x27;stopped&#x27;);
      updateButtonStates(&#x27;stopped&#x27;);
      addLog(&#x27;⏹️ 系统已停止&#x27;, &#x27;info&#x27;);
    &#125; catch (error) &#123;
      addLog(`❌ 停止操作失败: $&#123;error.message&#125;`, &#x27;error&#x27;);
    &#125;
  &#125;

  function resetSystem() &#123;
    if (!systemInstance) return;
    
    try &#123;
      window.GameBoySystemController.reset();
      updateSystemIndicator(&#x27;stopped&#x27;);
      updateButtonStates(&#x27;stopped&#x27;);
      addLog(&#x27;🔄 系统已重置&#x27;, &#x27;info&#x27;);
    &#125; catch (error) &#123;
      addLog(`❌ 重置失败: $&#123;error.message&#125;`, &#x27;error&#x27;);
    &#125;
  &#125;

  function stepSystem() &#123;
    if (!systemInstance) return;
    
    try &#123;
      // TODO: 实现单步执行
      addLog(&#x27;👣 执行单步操作...&#x27;, &#x27;debug&#x27;);
    &#125; catch (error) &#123;
      addLog(`❌ 单步执行失败: $&#123;error.message&#125;`, &#x27;error&#x27;);
    &#125;
  &#125;

  // 程序加载函数
  async function loadDemo() &#123;
    if (!systemInstance) &#123;
      addLog(&#x27;❌ 系统未初始化&#x27;, &#x27;error&#x27;);
      return;
    &#125;

    try &#123;
      addLog(&#x27;📦 正在加载演示程序...&#x27;, &#x27;info&#x27;);
      const success = window.GameBoySystemController.loadDemo();
      
      if (success) &#123;
        addLog(&#x27;✅ 演示程序加载完成&#x27;, &#x27;success&#x27;);
        addLog(&#x27;💡 现在可以点击&quot;开始运行&quot;启动系统&#x27;, &#x27;info&#x27;);
      &#125; else &#123;
        addLog(&#x27;❌ 演示程序加载失败&#x27;, &#x27;error&#x27;);
      &#125;
    &#125; catch (error) &#123;
      addLog(`❌ 加载演示程序失败: $&#123;error.message&#125;`, &#x27;error&#x27;);
    &#125;
  &#125;

  function loadROMFile() &#123;
    elements.romFileInput.click();
  &#125;

  async function handleROMFile(event) &#123;
    const file = event.target.files[0];
    if (!file) return;

    try &#123;
      addLog(`📦 正在加载 ROM 文件: $&#123;file.name&#125;`, &#x27;info&#x27;);
      
      const arrayBuffer = await file.arrayBuffer();
      const success = await window.GameBoySystemController.loadROM(arrayBuffer);
      
      if (success) &#123;
        addLog(`✅ ROM 文件加载完成: $&#123;file.name&#125;`, &#x27;success&#x27;);
      &#125; else &#123;
        addLog(`❌ ROM 文件加载失败: $&#123;file.name&#125;`, &#x27;error&#x27;);
      &#125;
    &#125; catch (error) &#123;
      addLog(`❌ 文件读取失败: $&#123;error.message&#125;`, &#x27;error&#x27;);
    &#125;
  &#125;

  // 调试工具函数
  function showSystemStatus() &#123;
    if (!systemInstance) &#123;
      addLog(&#x27;❌ 系统未初始化&#x27;, &#x27;error&#x27;);
      return;
    &#125;

    try &#123;
      const debugInfo = window.GameBoySystemController.getDebugInfo();
      addLog(&#x27;📊 === 系统状态 ===&#x27;, &#x27;debug&#x27;);
      addLog(debugInfo, &#x27;debug&#x27;);
      addLog(&#x27;=================&#x27;, &#x27;debug&#x27;);
    &#125; catch (error) &#123;
      addLog(`❌ 获取系统状态失败: $&#123;error.message&#125;`, &#x27;error&#x27;);
    &#125;
  &#125;

  function showMemoryDump() &#123;
    if (!systemInstance) &#123;
      addLog(&#x27;❌ 系统未初始化&#x27;, &#x27;error&#x27;);
      return;
    &#125;

    try &#123;
      const system = window.GameBoySystemController.getInstance();
      if (system &amp;&amp; system.mmu) &#123;
        addLog(&#x27;💾 === 内存转储 (0x0000-0x00FF) ===&#x27;, &#x27;debug&#x27;);
        const dump = system.getMemoryDump(0x0000, 256);
        addLog(dump, &#x27;debug&#x27;);
      &#125;
    &#125; catch (error) &#123;
      addLog(`❌ 内存转储失败: $&#123;error.message&#125;`, &#x27;error&#x27;);
    &#125;
  &#125;

  function showCPURegisters() &#123;
    if (!systemInstance) &#123;
      addLog(&#x27;❌ 系统未初始化&#x27;, &#x27;error&#x27;);
      return;
    &#125;

    try &#123;
      const system = window.GameBoySystemController.getInstance();
      if (system &amp;&amp; system.cpu) &#123;
        addLog(&#x27;💻 === CPU 寄存器状态 ===&#x27;, &#x27;debug&#x27;);
        addLog(system.cpu.getStatusString(), &#x27;debug&#x27;);
      &#125;
    &#125; catch (error) &#123;
      addLog(`❌ 获取 CPU 状态失败: $&#123;error.message&#125;`, &#x27;error&#x27;);
    &#125;
  &#125;

  function toggleDebugMode() &#123;
    isDebugMode = !isDebugMode;
    window.DEBUG_MODE = isDebugMode;
    addLog(`🔧 调试模式$&#123;isDebugMode ? &#x27;已启用&#x27; : &#x27;已禁用&#x27;&#125;`, &#x27;debug&#x27;);
  &#125;

  // 图形控制函数
  function toggleRenderMode() &#123;
    try &#123;
      const system = window.GameBoySystemController.getInstance();
      if (system &amp;&amp; system.gpu) &#123;
        const currentMode = system.gpu.renderMode || &#x27;test&#x27;;
        const newMode = currentMode === &#x27;test&#x27; ? &#x27;graphics&#x27; : &#x27;test&#x27;;
        system.gpu.setRenderMode(newMode);
        addLog(`🎨 渲染模式已切换到：$&#123;newMode === &#x27;test&#x27; ? &#x27;测试模式&#x27; : &#x27;图形模式&#x27;&#125;`, &#x27;info&#x27;);
      &#125;
    &#125; catch (error) &#123;
      addLog(`❌ 切换渲染模式失败: $&#123;error.message&#125;`, &#x27;error&#x27;);
    &#125;
  &#125;

  function showGraphicsStatus() &#123;
    try &#123;
      const system = window.GameBoySystemController.getInstance();
      if (system &amp;&amp; system.gpu) &#123;
        addLog(&#x27;🎨 === 图形系统状态 ===&#x27;, &#x27;debug&#x27;);
        addLog(system.gpu.getDebugInfo(), &#x27;debug&#x27;);
      &#125;
    &#125; catch (error) &#123;
      addLog(`❌ 获取图形状态失败: $&#123;error.message&#125;`, &#x27;error&#x27;);
    &#125;
  &#125;

  function testGraphicsSystem() &#123;
    try &#123;
      const system = window.GameBoySystemController.getInstance();
      if (system &amp;&amp; system.gpu) &#123;
        addLog(&#x27;🧪 运行图形系统测试...&#x27;, &#x27;debug&#x27;);
        
        // 创建测试数据
        if (system.mmu &amp;&amp; system.mmu.vram) &#123;
          const vram = system.mmu.vram;
          
          // 创建测试瓦片
          for (let i = 0; i &lt; 16; i += 2) &#123;
            vram[0x8000 + i] = Math.floor(Math.random() * 256);
            vram[0x8000 + i + 1] = Math.floor(Math.random() * 256);
          &#125;
          
          addLog(&#x27;✅ 测试数据已生成&#x27;, &#x27;debug&#x27;);
        &#125;
        
        // 测试渲染
        system.gpu.stepFrame();
        addLog(&#x27;✅ 图形系统测试完成&#x27;, &#x27;success&#x27;);
      &#125;
    &#125; catch (error) &#123;
      addLog(`❌ 图形系统测试失败: $&#123;error.message&#125;`, &#x27;error&#x27;);
    &#125;
  &#125;

  function clearConsoleLog() &#123;
    elements.consoleOutput.textContent = &#x27;GameBoy 模拟器控制台\n已清空...\n\n&#x27;;
  &#125;

  // 性能监控
  function startPerformanceMonitoring() &#123;
    performanceUpdateInterval = setInterval(updatePerformanceDisplay, 500);
  &#125;

  function updatePerformanceDisplay() &#123;
    if (!systemInstance) return;

    try &#123;
      const status = window.GameBoySystemController.getStatus();
      if (!status) return;

      const stats = status.statistics;
      
      // 更新显示
      elements.fpsValue.textContent = (stats.currentFPS || 0).toFixed(1);
      elements.framesValue.textContent = stats.framesRendered || 0;
      elements.instructionsValue.textContent = formatNumber(stats.cyclesExecuted / 4 || 0);
      elements.cyclesValue.textContent = formatNumber(stats.cyclesExecuted || 0);
      elements.errorsValue.textContent = stats.errors || 0;
      elements.uptimeValue.textContent = formatTime(stats.totalRunTime || 0);
      
    &#125; catch (error) &#123;
      // 静默处理性能监控错误
    &#125;
  &#125;

  function formatNumber(num) &#123;
    if (num &gt;= 1000000) &#123;
      return (num / 1000000).toFixed(1) + &#x27;M&#x27;;
    &#125; else if (num &gt;= 1000) &#123;
      return (num / 1000).toFixed(1) + &#x27;K&#x27;;
    &#125;
    return num.toString();
  &#125;

  function formatTime(seconds) &#123;
    if (seconds &gt;= 60) &#123;
      const minutes = Math.floor(seconds / 60);
      const remainingSeconds = Math.floor(seconds % 60);
      return `$&#123;minutes&#125;m$&#123;remainingSeconds&#125;s`;
    &#125;
    return `$&#123;Math.floor(seconds)&#125;s`;
  &#125;

  // 绑定事件监听器
  function bindEventListeners() &#123;
    elements.initBtn.addEventListener(&#x27;click&#x27;, initializeSystem);
    elements.startBtn.addEventListener(&#x27;click&#x27;, startSystem);
    elements.pauseBtn.addEventListener(&#x27;click&#x27;, pauseSystem);
    elements.stopBtn.addEventListener(&#x27;click&#x27;, stopSystem);
    elements.resetBtn.addEventListener(&#x27;click&#x27;, resetSystem);
    elements.loadDemoBtn.addEventListener(&#x27;click&#x27;, loadDemo);
    elements.loadRomBtn.addEventListener(&#x27;click&#x27;, loadROMFile);
    elements.stepBtn.addEventListener(&#x27;click&#x27;, stepSystem);
    elements.showStatusBtn.addEventListener(&#x27;click&#x27;, showSystemStatus);
    elements.showMemoryBtn.addEventListener(&#x27;click&#x27;, showMemoryDump);
    elements.showRegistersBtn.addEventListener(&#x27;click&#x27;, showCPURegisters);
    elements.toggleDebugBtn.addEventListener(&#x27;click&#x27;, toggleDebugMode);
    elements.toggleRenderBtn.addEventListener(&#x27;click&#x27;, toggleRenderMode);
    elements.showGraphicsBtn.addEventListener(&#x27;click&#x27;, showGraphicsStatus);
    elements.testGraphicsBtn.addEventListener(&#x27;click&#x27;, testGraphicsSystem);
    elements.clearConsoleBtn.addEventListener(&#x27;click&#x27;, clearConsoleLog);
    elements.romFileInput.addEventListener(&#x27;change&#x27;, handleROMFile);
  &#125;

  // 键盘快捷键
  document.addEventListener(&#x27;keydown&#x27;, function(event) &#123;
    // 防止在输入框中触发快捷键
    if (event.target.tagName === &#x27;INPUT&#x27;) return;
    
    switch(event.code) &#123;
      case &#x27;Space&#x27;:
        event.preventDefault();
        if (systemInstance) &#123;
          const status = window.GameBoySystemController.getStatus();
          if (status.state === &#x27;running&#x27;) &#123;
            pauseSystem();
          &#125; else &#123;
            startSystem();
          &#125;
        &#125;
        break;
      case &#x27;KeyR&#x27;:
        event.preventDefault();
        resetSystem();
        break;
      case &#x27;KeyL&#x27;:
        event.preventDefault();
        loadDemo();
        break;
      case &#x27;KeyS&#x27;:
        event.preventDefault();
        stepSystem();
        break;
      case &#x27;KeyD&#x27;:
        event.preventDefault();
        showSystemStatus();
        break;
      case &#x27;KeyM&#x27;:
        event.preventDefault();
        showMemoryDump();
        break;
      case &#x27;KeyG&#x27;:
        event.preventDefault();
        toggleRenderMode();
        break;
      case &#x27;KeyT&#x27;:
        event.preventDefault();
        testGraphicsSystem();
        break;
    &#125;
  &#125;);

  // 页面加载完成后的初始化
  window.addEventListener(&#x27;load&#x27;, function() &#123;
    bindEventListeners();
    
    addLog(&#x27;🎮 GameBoy 模拟器 v0.5.0 已准备就绪&#x27;, &#x27;success&#x27;);
    addLog(&#x27;📚 当前版本：第五章 - 系统集成&#x27;, &#x27;info&#x27;);
    addLog(&#x27;✨ 新功能：完整系统架构、CPU 指令集、寄存器控制&#x27;, &#x27;info&#x27;);
    addLog(&#x27;💡 点击&quot;初始化系统&quot;开始使用&#x27;, &#x27;info&#x27;);

    // 检查组件加载状态
    setTimeout(() =&gt; &#123;
      const components = [
        &#123; name: &#x27;MMU&#x27;, check: () =&gt; typeof GameBoyMMU !== &#x27;undefined&#x27; &#125;,
        &#123; name: &#x27;GPU&#x27;, check: () =&gt; typeof GameBoyGPU !== &#x27;undefined&#x27; &#125;,
        &#123; name: &#x27;CPU&#x27;, check: () =&gt; typeof GameBoyCPU !== &#x27;undefined&#x27; &#125;,
        &#123; name: &#x27;图形系统&#x27;, check: () =&gt; typeof GameBoyGraphicsSystem !== &#x27;undefined&#x27; &#125;,
        &#123; name: &#x27;系统控制器&#x27;, check: () =&gt; typeof GameBoySystem !== &#x27;undefined&#x27; &#125;
      ];

      components.forEach(comp =&gt; &#123;
        if (comp.check()) &#123;
          addLog(`✅ $&#123;comp.name&#125; 组件已加载`, &#x27;success&#x27;);
        &#125; else &#123;
          addLog(`❌ $&#123;comp.name&#125; 组件加载失败`, &#x27;error&#x27;);
        &#125;
      &#125;);
      
      addLog(&#x27;🔧 所有组件检查完成，可以开始初始化&#x27;, &#x27;info&#x27;);
    &#125;, 500);
  &#125;);

  // 页面卸载时清理
  window.addEventListener(&#x27;beforeunload&#x27;, function() &#123;
    if (performanceUpdateInterval) &#123;
      clearInterval(performanceUpdateInterval);
    &#125;
    
    if (systemInstance) &#123;
      window.GameBoySystemController.stop();
    &#125;
  &#125;);

&#125;)();
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</details>
<p>效果（点击 <em>初始化系统</em> → <em>切换渲染模式</em> → <em>测试图形渲染</em> → <em>加载演示程序</em> → <em>开始运行</em> ）：</p>
<p><img src="/posts/4148/1.png" alt="alt text"></p>
<h2 id="58-全局系统控制接口"><a class="markdownIt-Anchor" href="#58-全局系统控制接口"></a> 5.8. 全局系统控制接口</h2>
<p>为了方便外部访问和调试，我们写一个统一的全局的系统控制接口：</p>
<pre><code class="language-javascript">/**
 * 全局系统控制函数
 */
window.GameBoySystemController = &#123;
	/**
	 * 初始化系统
	 */
	async init() &#123;
		try &#123;
			if (!gameBoySystem) &#123;
				gameBoySystem = new GameBoySystem();
			&#125;

			await gameBoySystem.initialize();
			window.GameBoySystem = gameBoySystem; // 全局引用
			return gameBoySystem;
		&#125; catch (error) &#123;
			console.error(&#x27;❌ 系统初始化失败:&#x27;, error);
			throw error;
		&#125;
	&#125;,

	/**
	 * 获取系统实例
	 */
	getInstance() &#123;
		return gameBoySystem;
	&#125;,

	/**
	 * 重置系统
	 */
	reset() &#123;
		if (gameBoySystem) &#123;
			gameBoySystem.reset();
		&#125;
	&#125;,

	/**
	 * 启动系统
	 */
	start(mode) &#123;
		if (gameBoySystem) &#123;
			gameBoySystem.start(mode);
		&#125;
	&#125;,

	/**
	 * 停止系统
	 */
	stop() &#123;
		if (gameBoySystem) &#123;
			gameBoySystem.stop();
		&#125;
	&#125;,

	/**
	 * 暂停/恢复
	 */
	togglePause() &#123;
		if (gameBoySystem) &#123;
			gameBoySystem.togglePause();
		&#125;
	&#125;,

	/**
	 * 加载 ROM
	 */
	async loadROM(romData) &#123;
		if (gameBoySystem) &#123;
			return await gameBoySystem.loadROM(romData);
		&#125;
		return false;
	&#125;,

	/**
	 * 加载演示
	 */
	loadDemo() &#123;
		if (gameBoySystem) &#123;
			return gameBoySystem.loadDemo();
		&#125;
		return false;
	&#125;,

	/**
	 * 获取状态
	 */
	getStatus() &#123;
		if (gameBoySystem) &#123;
			return gameBoySystem.getStatus();
		&#125;
		return null;
	&#125;,

	/**
	 * 获取调试信息
	 */
	getDebugInfo() &#123;
		if (gameBoySystem) &#123;
			return gameBoySystem.getDebugInfo();
		&#125;
		return &#x27;系统未初始化&#x27;;
	&#125;
&#125;;</code></pre>
<p>这个控制器接口使得前端可以通过简洁的 API 来操作整个模拟器系统，同时在浏览器控制台中也可以直接调用这些方法进行调试：</p>
<pre><code class="language-javascript">// 在浏览器控制台中
const system = window.GameBoySystemController.getInstance();

// 查看系统状态
console.log(system.getStatus());

// 测试寄存器
system.gpu.writeRegister(0xFF43, 50); // 设置水平滚动
console.log(system.gpu.readRegister(0xFF43)); // 读取确认</code></pre>
<p><img src="/posts/4148/2.png" alt="alt text"></p>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="d601.html">上一篇</a><a class="next" href="5e08.html">下一篇</a></div><div class="copyright"><p>© 2022 - 2025 <a href="https://cytrogen.icu">Cytrogen</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/cytrogen/hexo-theme-ares" target="_blank">hexo-theme-ares</a>.</p></div></footer></div></div><a class="back-to-top" href="#top" aria-label="返回顶部"><svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path d="M3.293 9.707a1 1 0 010-1.414L9.586 2a2 2 0 012.828 0l6.293 6.293a1 1 0 01-1.414 1.414L11 3.414V17a1 1 0 11-2 0V3.414L2.707 9.707a1 1 0 01-1.414 0z"></path></svg></a><script>document.addEventListener('DOMContentLoaded', function() {
  const codeBlocks = document.querySelectorAll('figure.highlight');
  
  codeBlocks.forEach(block => {
    let caption = block.querySelector('figcaption');
    if (!caption) {
      caption = document.createElement('figcaption');
      block.insertBefore(caption, block.firstChild);
    }

    const info = document.createElement('div');
    info.className = 'info';
    
    const filename = caption.querySelector('span');
    if (filename) {
      filename.className = 'filename';
      info.appendChild(filename);
    }
    
    const lang = block.className.split(' ')[1];
    if (lang) {
      const langSpan = document.createElement('span');
      langSpan.className = 'lang-name';
      langSpan.textContent = lang;
      info.appendChild(langSpan);
    }

    const sourceLink = caption.querySelector('a');
    if (sourceLink) {
      sourceLink.className = 'source-link';
      info.appendChild(sourceLink);
    }

    const actions = document.createElement('div');
    actions.className = 'actions';

    const codeHeight = block.scrollHeight;
    const threshold = 300;

    if (codeHeight > threshold) {
      block.classList.add('folded');
      
      const toggleBtn = document.createElement('button');
      toggleBtn.textContent = '展开';
      toggleBtn.addEventListener('click', () => {
        block.classList.toggle('folded');
        toggleBtn.textContent = block.classList.contains('folded') ? '展开' : '折叠';
      });
      actions.appendChild(toggleBtn);
    }

    const copyBtn = document.createElement('button');
    copyBtn.textContent = '复制';
    copyBtn.addEventListener('click', async () => {
      const codeLines = block.querySelectorAll('.code .line');
      const code = Array.from(codeLines)
        .map(line => line.textContent)
        .join('\n')
        .replace(/\n\n/g, '\n');
      
      try {
        await navigator.clipboard.writeText(code);
        copyBtn.textContent = '已复制';
        copyBtn.classList.add('copied');
        
        setTimeout(() => {
          copyBtn.textContent = '复制';
          copyBtn.classList.remove('copied');
        }, 3000);
      } catch (err) {
        console.error('复制失败:', err);
        copyBtn.textContent = '复制失败';
        
        setTimeout(() => {
          copyBtn.textContent = '复制';
        }, 3000);
      }
    });
    actions.appendChild(copyBtn);

    caption.innerHTML = '';
    caption.appendChild(info);
    caption.appendChild(actions);

    const markedLines = block.getAttribute('data-marked-lines');
    if (markedLines) {
      const lines = markedLines.split(',');
      lines.forEach(range => {
        if (range.includes('-')) {
          const [start, end] = range.split('-').map(Number);
          for (let i = start; i <= end; i++) {
            const line = block.querySelector(`.line-${i}`);
            if (line) line.classList.add('marked');
          }
        } else {
          const line = block.querySelector(`.line-${range}`);
          if (line) line.classList.add('marked');
        }
      });
    }
  });
});</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=G-4PVPZXE0QQ"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-4PVPZXE0QQ');</script><script>(function() {
  // Wait for DOM to be ready
  document.addEventListener('DOMContentLoaded', function() {
    const themeToggle = document.querySelector('.theme-toggle');
    
    if (!themeToggle) return;
    
    // Get current theme
    const getCurrentTheme = () => {
      return document.documentElement.getAttribute('data-theme') || 'light';
    };
    
    // Update UI to match current theme
    const updateUI = (theme) => {
      const isDark = theme === 'dark';
      themeToggle.setAttribute('aria-pressed', isDark.toString());
    };
    
    // Simplified theme setter - CSS handles all animations
    const setTheme = (theme) => {
      document.documentElement.setAttribute('data-theme', theme);
      document.documentElement.style.colorScheme = theme; // Update native UI elements
      
      // Also update page-wrapper for animation support
      const pageWrapper = document.getElementById('page-wrapper');
      if (pageWrapper) {
        pageWrapper.setAttribute('data-theme', theme);
      }
      
      // Find and remove the temporary anti-flicker style tag if it exists.
      // This ensures the main stylesheet takes full control after the initial load.
      const antiFlickerStyle = document.getElementById('anti-flicker-style');
      if (antiFlickerStyle) {
        antiFlickerStyle.remove();
      }
      
      localStorage.setItem('theme', theme);
      updateUI(theme);
    };
    
    // Simple theme toggle - letting CSS handle the smooth transitions
    const toggleTheme = () => {
      const current = getCurrentTheme();
      const newTheme = current === 'light' ? 'dark' : 'light';
      setTheme(newTheme);
    };
    
    // Initialize UI on page load
    updateUI(getCurrentTheme());
    
    // Add click event listener
    themeToggle.addEventListener('click', toggleTheme);
    
    // Listen for system theme changes
    if (window.matchMedia) {
      const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
      mediaQuery.addEventListener('change', function(e) {
        // Only update if no manual preference is saved
        if (!localStorage.getItem('theme')) {
          const theme = e.matches ? 'dark' : 'light';
          setTheme(theme);
        }
      });
    }
  });
})();
</script><script>(function() {
  document.addEventListener('DOMContentLoaded', function() {
    const backToTopBtn = document.querySelector('.back-to-top');
    
    if (!backToTopBtn) return;
    
    // Show/hide button based on scroll position
    const toggleButtonVisibility = () => {
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      const shouldShow = scrollTop > 200; // Show after scrolling 200px
      
      if (shouldShow) {
        backToTopBtn.classList.add('is-visible');
      } else {
        backToTopBtn.classList.remove('is-visible');
      }
    };
    
    // Throttle scroll events for better performance
    let ticking = false;
    const handleScroll = () => {
      if (!ticking) {
        requestAnimationFrame(() => {
          toggleButtonVisibility();
          ticking = false;
        });
        ticking = true;
      }
    };
    
    // Smooth scroll to top when clicked
    const scrollToTop = (event) => {
      event.preventDefault();
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    };
    
    // Add event listeners
    window.addEventListener('scroll', handleScroll);
    backToTopBtn.addEventListener('click', scrollToTop);
    
    // Check initial scroll position
    toggleButtonVisibility();
  });
})();</script></body></html>