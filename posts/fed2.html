<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>IBM全栈开发【5】：Node.js & Express创建后端 · Cytrogen 的个人博客</title><meta name="description" content="本文是 IBM 全栈开发课程的第五篇学习笔记，详细介绍了如何使用 Node.js 和 Express.js 构建后端应用。笔记从服务端 JavaScript 的基础出发，讲解了 Node.js 的非阻塞I/O、模块化（CommonJS vs ES Modules）以及异步回调编程，并引入 Promise 来解决“回调地狱”问题。教程的核心部分深入探讨了 Express.js 框架，涵盖了路由、中间件、模板渲染，并提供了一个基于 JWT（JSON Web Token）实现用户身份验证的完整代码示例。这篇笔记为学习和掌握 Node.js 后端开发提供了一份全面的知识点总结。"><link rel="icon" href="../favicon.png"><link rel="preload" href="../fonts/opensans-regular-latin.woff2" as="font" type="font/woff2" crossorigin="anonymous"><style>@font-face {
  font-family: 'Open Sans';
  src: url('../fonts/opensans-regular-latin.woff2') format('woff2');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
  size-adjust: 107%;
  ascent-override: 97%;
  descent-override: 25%;
  line-gap-override: 0%;
}
</style><link rel="stylesheet" href="../css/ares.css"><script>(function() {
  const getInitialTheme = () => {
    const saved = localStorage.getItem('theme');
    if (saved && (saved === 'light' || saved === 'dark')) {
      return saved;
    }
    
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      return 'dark';
    }
    
    return 'light';
  };
  
  const theme = getInitialTheme();
  document.documentElement.setAttribute('data-theme', theme);
  
  document.documentElement.style.colorScheme = theme;
  
  // Add anti-flicker style for dark mode
  if (theme === 'dark') {
    const style = document.createElement('style');
    style.id = 'anti-flicker-style';
    style.innerHTML = `
      #page-wrapper[data-theme="dark"] {
        background-color: #0f172a;
        color: #f1f5f9;
      }
    `;
    document.head.appendChild(style);
  }
  
  document.addEventListener('DOMContentLoaded', function() {
    const pageWrapper = document.getElementById('page-wrapper');
    if (pageWrapper) {
      pageWrapper.setAttribute('data-theme', theme);
    }
  });
})();

</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="atom.xml" title="Cytrogen 的个人博客" type="application/atom+xml">
</head><body><div id="page-wrapper"><a class="skip-link" href="#main-content">跳到主要内容</a><div class="wrap"><header><a class="logo-link" href="../index.html"><img src="../favicon.png" alt="logo"></a><nav class="site-nav"><div class="nav-main"><div class="nav-primary"><ul class="nav-list hidden-mobile"><li class="nav-item"><a class="nav-link" href="../index.html">首页</a></li></ul><div class="nav-tools"><div class="language-menu"><button class="language-toggle" type="button"><svg class="icon icon-globe" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true" focusable="false"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8zm7.5-6.923c-.67.204-1.335.82-1.887 1.855A7.97 7.97 0 0 0 5.145 4H7.5V1.077zM4.09 4a9.267 9.267 0 0 1 .64-1.539 6.7 6.7 0 0 1 .597-.933A7.025 7.025 0 0 0 2.255 4H4.09zm-.582 3.5c.03-.877.138-1.718.312-2.5H1.674a6.958 6.958 0 0 0-.656 2.5h2.49zM4.847 5a12.5 12.5 0 0 0-.338 2.5H7.5V5H4.847zM8.5 5v2.5h2.99a12.495 12.495 0 0 0-.337-2.5H8.5zM4.51 8.5a12.5 12.5 0 0 0 .337 2.5H7.5V8.5H4.51zm3.99 0V11h2.653c.187-.765.306-1.608.338-2.5H8.5zM5.145 12c.138.386.295.744.468 1.068.552 1.035 1.218 1.65 1.887 1.855V12H5.145zm.182 2.472a6.696 6.696 0 0 1-.597-.933A9.268 9.268 0 0 1 4.09 12H2.255a7.024 7.024 0 0 0 3.072 2.472zM3.82 11a13.652 13.652 0 0 1-.312-2.5h-2.49c.062.89.291 1.733.656 2.5H3.82zm6.853 3.472A7.024 7.024 0 0 0 13.745 12H11.91a9.27 9.27 0 0 1-.64 1.539 6.688 6.688 0 0 1-.597.933zM8.5 12v2.923c.67-.204 1.335-.82 1.887-1.855A7.97 7.97 0 0 0 10.855 12H8.5zm3.68-1h2.146c.365-.767.594-1.61.656-2.5h-2.49a13.65 13.65 0 0 1-.312 2.5zm2.802-3.5a6.959 6.959 0 0 0-.656-2.5H12.18c.174.782.282 1.623.312 2.5h2.49zM11.27 2.461c.247.464.462.98.64 1.539h1.835a7.024 7.024 0 0 0-3.072-2.472c.218.284.418.598.597.933zM10.855 4a7.966 7.966 0 0 0-.468-1.068C9.835 1.897 9.17 1.282 8.5 1.077V4h2.355z"></path></svg><span>中文</span></button><div class="language-dropdown"></div></div></div><div class="nav-controls"><div class="more-menu hidden-mobile"><button class="more-toggle" type="button"><span>更多</span><svg class="icon icon-chevron-down" width="12" height="12" viewBox="0 0 12 12" fill="currentColor" aria-hidden="true" focusable="false"><path d="M6 8.825c-.2 0-.4-.1-.5-.2l-3.3-3.3c-.3-.3-.3-.8 0-1.1s.8-.3 1.1 0l2.7 2.7 2.7-2.7c.3-.3.8-.3 1.1 0s.3.8 0 1.1l-3.3 3.3c-.1.1-.3.2-.5.2z"></path></svg></button><div class="more-dropdown"><ul class="dropdown-list"><li class="dropdown-item"><a class="nav-link" href="../archives">归档</a></li><li class="dropdown-item"><a class="nav-link" href="../categories">分类</a></li><li class="dropdown-item"><a class="nav-link" href="../tags">标签</a></li><li class="dropdown-item"><a class="nav-link" href="../about">关于</a></li><li class="dropdown-item"><a class="nav-link" href="../friends">友链</a></li><li class="dropdown-item"><a class="nav-link" href="../atom.xml">RSS订阅</a></li><li class="dropdown-item"><a class="dropdown-link" href="https://portfolio.cytrogen.icu" target="_blank" rel="noopener noreferrer">作品集<svg class="icon icon-external-link" width="14" height="14" viewBox="0 0 14 14" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8.636 2.364A1 1 0 0 1 10 1h3a1 1 0 0 1 1 1v3a1 1 0 0 1-2 0V3.414l-4.293 4.293a1 1 0 0 1-1.414-1.414L10.586 2H9a1 1 0 0 1-1.364-1.636zM2 3a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V9a1 1 0 1 1 2 0v3a3 3 0 0 1-3 3H2a3 3 0 0 1-3-3V4a3 3 0 0 1 3-3h3a1 1 0 1 1 0 2H2z"></path></svg></a></li><li class="dropdown-item"><a class="dropdown-link" href="https://github.com/cytrogen" target="_blank" rel="noopener noreferrer">GitHub<svg class="icon icon-external-link" width="14" height="14" viewBox="0 0 14 14" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8.636 2.364A1 1 0 0 1 10 1h3a1 1 0 0 1 1 1v3a1 1 0 0 1-2 0V3.414l-4.293 4.293a1 1 0 0 1-1.414-1.414L10.586 2H9a1 1 0 0 1-1.364-1.636zM2 3a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V9a1 1 0 1 1 2 0v3a3 3 0 0 1-3 3H2a3 3 0 0 1-3-3V4a3 3 0 0 1 3-3h3a1 1 0 1 1 0 2H2z"></path></svg></a></li></ul></div></div><div class="theme-switcher"><button class="theme-toggle" type="button" role="switch" aria-pressed="false" aria-label="切换主题"><div class="theme-icon moon-icon"><svg class="icon icon-moon" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true" focusable="false"><path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"></path></svg></div><div class="theme-icon sun-icon"><svg class="icon icon-sun" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0 1a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"></path></svg></div></button></div><details class="mobile-menu-details hidden-desktop"><summary class="hamburger-menu" aria-label="nav.menu"><svg class="icon icon-bars" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true" focusable="false"><path d="M2.5 12a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5z"></path></svg><span class="menu-text">nav.menu</span></summary><div class="mobile-menu-dropdown"><ul class="mobile-nav-list"><li class="mobile-nav-item"><a class="mobile-nav-link" href="../index.html">首页</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../archives">归档</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../categories">分类</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../tags">标签</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../about">关于</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../friends">友链</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../atom.xml">RSS订阅</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="https://portfolio.cytrogen.icu" target="_blank" rel="noopener noreferrer">作品集<svg class="icon icon-external-link" width="14" height="14" viewBox="0 0 14 14" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8.636 2.364A1 1 0 0 1 10 1h3a1 1 0 0 1 1 1v3a1 1 0 0 1-2 0V3.414l-4.293 4.293a1 1 0 0 1-1.414-1.414L10.586 2H9a1 1 0 0 1-1.364-1.636zM2 3a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V9a1 1 0 1 1 2 0v3a3 3 0 0 1-3 3H2a3 3 0 0 1-3-3V4a3 3 0 0 1 3-3h3a1 1 0 1 1 0 2H2z"></path></svg></a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="https://github.com/cytrogen" target="_blank" rel="noopener noreferrer">GitHub<svg class="icon icon-external-link" width="14" height="14" viewBox="0 0 14 14" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8.636 2.364A1 1 0 0 1 10 1h3a1 1 0 0 1 1 1v3a1 1 0 0 1-2 0V3.414l-4.293 4.293a1 1 0 0 1-1.414-1.414L10.586 2H9a1 1 0 0 1-1.364-1.636zM2 3a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V9a1 1 0 1 1 2 0v3a3 3 0 0 1-3 3H2a3 3 0 0 1-3-3V4a3 3 0 0 1 3-3h3a1 1 0 1 1 0 2H2z"></path></svg></a></li></ul></div></details></div></div></div></nav></header><main class="container" id="main-content" tabindex="-1"><div class="post"><article class="post-block"><h1 class="post-title">IBM全栈开发【5】：Node.js & Express创建后端</h1><div class="post-info">1/21/2024</div><div class="post-content"><p>近期在学习IBM全栈应用开发微学士课程，故此记录学习笔记。</p>
<span id="more"></span>
<h1 id="1-服务端javascript入门"><a class="markdownIt-Anchor" href="#1-服务端javascript入门"></a> 1. 服务端JavaScript入门</h1>
<p>客户端-服务端的应用程序（比如基于云的应用程序）通常由“前端”和“后端”组成。前端是指用户在浏览器中看到的应用程序的部分，后端是指在服务器上运行的应用程序的部分。</p>
<h2 id="11-后端"><a class="markdownIt-Anchor" href="#11-后端"></a> 1.1. 后端</h2>
<p>后端开发人员负责开发确保网站正常运行的技术，包括服务器端的应用程序、数据库和服务器。</p>
<ul>
<li>服务器由硬件和软件组成，它们与客户端进行通信并提供功能。多种类型的服务器可用于不同的目的：Web服务器用于存储和提供网站的内容，数据库服务器用于存储和提供数据，应用程序服务器用于存储和提供应用程序的功能</li>
<li>数据库是一种用于存储和访问数据的软件。数据库服务器是一种用于存储和访问数据的服务器。数据库服务器可以存储和访问结构化数据（例如，关系数据库）和非结构化数据（例如，文本文件、图像和视频）</li>
<li>网页应用程序接口（API）允许两个软件之间相互通信。网络服务便是网页应用程序接口的一种、使用HTTP请求进行通信</li>
<li>编程语言是一种用于编写软件的语言。用于后端开发的编程语言包括Java、Python、PHP、Ruby、JavaScript和C#</li>
<li>框架是一种用于编写软件的工具。框架提供了一组通用的功能，可以帮助开发人员编写软件。用于后端开发的框架包括Spring、Django、Laravel、Ruby on Rails、<a target="_blank" rel="noopener" href="http://Node.xn--jsASP-sn9h.NET">Node.js和ASP.NET</a></li>
<li>runtimes是一种用于运行软件的工具，行为类似于微型操作系统，为应用程序的运行提供必要的资源。Node.js就是后端runtime环境的一个例子</li>
</ul>
<p>Node.js作为一种后端技术之所以如此流行，原因之一是它运行在谷歌Chrome浏览器的开源V8引擎上。V8引擎也是在前端运行浏览器的引擎。大多数现代浏览器都使用V8引擎，因此，Node.js和浏览器之间的代码兼容性很好。</p>
<h4 id="111-可扩展性"><a class="markdownIt-Anchor" href="#111-可扩展性"></a> 1.1.1. 可扩展性</h4>
<p>可扩展性对企业软件的成功至关重要。它受应用程序负载的影响，是后端的一大责任。而负载指的是并发用户、交易、数据量和其他因素的总和。</p>
<p>可扩展性是指应用程序在不影响性能的情况下动态处理负载增减的能力。</p>
<h2 id="12-nodejs"><a class="markdownIt-Anchor" href="#12-nodejs"></a> 1.2. Node.js</h2>
<p>Node.js是一个运行在V8上的开源语言，它是JavaScript的服务器端实现。Node.js由事件驱动，使用非阻塞I/O模型，这使得它非常轻量级、高效和可扩展。</p>
<p>Node.js着重强调使用轻量级语言进行并发编程，它是一种单线程语言，但是，它可以使用事件循环和回调函数来处理并发。</p>
<p>Node.js适合希望使用回调函数和Node.js runtime事件循环等功能来构建并发应用程序的开发人员。JavaScript语言和Node.js runtime的这些功能使得开发人员只需使用一套最少的工具就可以实现快速开发。</p>
<p>通过服务器端JavaScript，Node.js的应用程序可以处理和路由来自客户端的请求：</p>
<ol>
<li>用户在用HTML和CSS编写的用户界面中选择一个选项</li>
<li>用户的这一操作会触发在客户端实现业务逻辑的JavaScript代码</li>
<li>JavaScript代码会向服务器发送一个请求（通过HTTP调用带有JSON数据的API）</li>
<li>作为在服务器上运行的Node.js应用程序的一部分，REST网络服务会接收请求并处理它</li>
<li>REST网络服务处理请求后，通过HTTP将结果作为JSON数据返回给客户端</li>
</ol>
<h4 id="121-模块"><a class="markdownIt-Anchor" href="#121-模块"></a> 1.2.1. 模块</h4>
<p>在Node.js中，模块是包含相关的、已封装的JavaScript代码的文件，用于实现特定的功能。模块可以是内置的，也可以是外部的；可以是单个文件，也可以是文件夹。</p>
<p>当外部应用程序需要使用模块中包含的代码时，应用程序需要调用该模块。而调用模块就需要使用语句<code>import()</code>或者<code>require()</code>。</p>
<blockquote>
<p>模块规范：<br>
一个或多个模块组成一个包，包是一个目录，其中包含一个<code>package.json</code>文件，该文件描述了包的内容。包可以发布到npm（Node.js包管理器）上，以便其他开发人员可以使用它们。</p>
<p>常用的模块规范有CommonJS和ES。默认情况下，Node.js使用CommonJS规范，但是，Node.js也支持ES规范。库作者仅需要将包文件的扩展名从<code>.js</code>更改为<code>.mjs</code>，就可以使用ES模块规范。</p>
<p>CommonJS规范使用<code>require()</code>，而ES规范使用<code>import()</code>。<br>
当需要在自身文件之外使用模块时，必须先导出模块。在使用CommonJS规范时，可以使用<code>module.exports</code>导出模块；在使用ES规范时，可以使用<code>export</code>导出模块。</p>
</blockquote>
<p><code>import()</code>和<code>require()</code>的区别：</p>
<table>
<thead>
<tr>
<th style="text-align:left">import()</th>
<th style="text-align:left">require()</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">必须在文件开头调用</td>
<td style="text-align:left">可以在文件的任何位置调用</td>
</tr>
<tr>
<td style="text-align:left">不能在条件语句和函数中调用</td>
<td style="text-align:left">可以在条件语句和函数中调用</td>
</tr>
<tr>
<td style="text-align:left">静态绑定</td>
<td style="text-align:left">动态绑定</td>
</tr>
<tr>
<td style="text-align:left">在编译时解析</td>
<td style="text-align:left">在运行时解析</td>
</tr>
<tr>
<td style="text-align:left">异步</td>
<td style="text-align:left">同步</td>
</tr>
<tr>
<td style="text-align:left">对比<code>require()</code>，在涉及到加载数百个模块的应用程序中运行速度更快</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<blockquote>
<p><code>require()</code>：</p>
<pre><code class="language-js">// export from a file named message.js
module.exports = &#x27;Hello Programmers&#x27;;</code></pre>
<pre><code class="language-js">// import from the message.js file
let msg = require(&#x27;./message.js&#x27;);
console.log(msg);</code></pre>
</blockquote>
<blockquote>
<p><code>import()</code>：</p>
<pre><code class="language-js">// export from file named module.mjs
const a = 1;
export &#123; a as &quot;myvalue&quot; &#125;;</code></pre>
<pre><code class="language-js">// import from module.mjs
import &#123; myvalue &#125; from module.mjs;</code></pre>
</blockquote>
<h4 id="122-创建简单的网络服务器"><a class="markdownIt-Anchor" href="#122-创建简单的网络服务器"></a> 1.2.2. 创建简单的网络服务器</h4>
<p>Node.js runtime打包了许多实用程序模块，你可以使用它们来创建和扩展应用程序。例如，HTTP Node.js模块提供了能够监听HTTP请求的功能。</p>
<pre><code class="language-js">let server = http.createServer(function(request, response) &#123;  // create an instance of a web server
    let body = &quot;Hello World!&quot;;
    response.writeHead(200, &#123;  // this callback function handles the incoming request message and provides an appropriate response message
        &quot;Content-Length&quot;: body.length,
        &quot;Content-Type&quot;: &quot;text/plain&quot;
    &#125;);
    response.end(body);
&#125;);

server.listen(8080);  // set the server to listen to a specific port</code></pre>
<h4 id="123-packagejson"><a class="markdownIt-Anchor" href="#123-packagejson"></a> 1.2.3. <code>Package.json</code></h4>
<p>一个软件包由一个或多个模块组成。每个软件包都有一个<code>package.json</code>文件，用于描述Node.js模块的详细信息。</p>
<p>如果模块没有<code>package.json</code>文件，Node.js就会假定主模块是<code>index.js</code>文件。</p>
<pre><code class="language-json">// Package.json
&#123;
    &quot;name&quot;: &quot;mod_today&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;,
    &quot;main&quot;: &quot;./lib/today&quot;,
    &quot;license&quot;: &quot;Apache-2.0&quot;
&#125;</code></pre>
<p>要为模块指定不同的主模块，可以在模块目录中Node.js脚本的相对路径中指定主模块。</p>
<h4 id="124-导入导出nodejs模块"><a class="markdownIt-Anchor" href="#124-导入导出nodejs模块"></a> 1.2.4. 导入/导出Node.js模块</h4>
<p>你可以使用<code>require()</code>函数导入Node.js模块。</p>
<pre><code class="language-js">let today = require(&quot;./today&quot;);</code></pre>
<p><code>require()</code>语句假定了脚本的文件扩展名为<code>.js</code>。它会创建一个对象来表示导入的模块，并将其分配给变量<code>today</code>。</p>
<p>每个Node.js模块都有一个隐式<code>exports</code>对象。要向导入模块的Node.js应用程序提供函数或值，就需要在<code>exports</code>中添加属性。</p>
<pre><code class="language-js">let date = new Date();

let days = [&#x27;Monday&#x27;, &#x27;Tuesday&#x27;, &#x27;Wednesday&#x27;, &#x27;Thursday&#x27;, &#x27;Friday&#x27;, &#x27;Saturday&#x27;, &#x27;Sunday&#x27;];

exports.dayOfWeek = function() &#123;  // the dayOfWeek property is added to the exports object
    return days[date.getDay() - 1];
&#125;;</code></pre>
<p>导入Node.js模块时，<code>require()</code>函数会返回一个JavaScript对象，该对象代表着模块的一个实例。</p>
<pre><code class="language-js">let today = require(&quot;./mod_today&quot;);  // the today variable is an instance of the today Node.js module that is called &quot;today&quot;</code></pre>
<p>要访问模块的属性，就要从变量中检索属性。</p>
<pre><code class="language-js">console.log(&quot;Happy %s!&quot;, today.dayOfWeek());  // today.dayOfWeek() represents the current exported property from the today Node.js module</code></pre>
<h2 id="13-express"><a class="markdownIt-Anchor" href="#13-express"></a> 1.3. Express</h2>
<p>Express.js是一个高度可配置的框架，用于在Node.js上构建应用程序。它通过使用HTTP实现程序方法和中间件来抽象出Node.js中的低级API。</p>
<p>以下功能可让你快速开发应用程序：</p>
<ol>
<li>
<p>Express.js应用程序</p>
 <pre><code class="language-js">const app = express();</code></pre>
</li>
<li>
<p>图像、CSS和JavaScript文件等静态文件</p>
</li>
<li>
<p>静态路由：定义接收和处理客户端请求的端点</p>
</li>
<li>
<p><code>server.js</code>：用于启动应用程序的文件</p>
</li>
<li>
<p><code>package.json</code>：用于定义应用程序的依赖项和脚本的文件</p>
</li>
</ol>
<h2 id="14-软件包管理器"><a class="markdownIt-Anchor" href="#14-软件包管理器"></a> 1.4. 软件包管理器</h2>
<p>软件包管理器是一套用于处理包含依赖关系的模块和软件包的工具。依赖关系是指一个软件包依赖于另一个软件包。</p>
<p>代码库通常包含着许多依赖项，但代码库本身是独立的，不依赖于代码库之外的任何东西。这种独立性使得代码库可以在不同的环境中使用。</p>
<p>软件包管理器能够自动完成查找、安装、更新、配置、维护和删除软件包的工作。它们通常连接并维护一个数据库，其中包含着软件包的依赖关系和版本信息。</p>
<h4 id="141-npm"><a class="markdownIt-Anchor" href="#141-npm"></a> 1.4.1. npm</h4>
<p>npm是Node.js的软件包管理器。它是一个命令行工具，用于安装、更新、配置和删除Node.js软件包。</p>
<p>所有的npm软件包都需要一个<code>package.json</code>文件，该文件描述了软件包的详细信息。</p>
<pre><code class="language-json">&#123;
    &quot;name&quot;: &quot;myapp&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;,
    &quot;description&quot;: &quot;My first Node.js app&quot;,
    &quot;main&quot;: &quot;server.js&quot;,
    &quot;scripts&quot;: &#123;
        &quot;start&quot;: &quot;node server.js&quot;
    &#125;,
    &quot;author&quot;: &quot;John Doe&quot;,
    &quot;license&quot;: &quot;ISC&quot;,
    &quot;dependencies&quot;: &#123;
        &quot;express&quot;: &quot;^4.17.1&quot;
    &#125;
&#125;</code></pre>
<p>npm使用<code>package.json</code>文件中的<code>dependencies</code>属性来确定软件包的依赖关系。<code>dependencies</code>属性是一个对象，其中包含着软件包的名称和版本号。</p>
<p>npm有两种安装软件包的方式：本地安装或者全局安装。如果安装的软件包要在应用程序中使用，就应该使用本地安装。如果安装的软件包要在命令行中使用，就应该使用全局安装。</p>
<p>默认情况下npm会采用本地安装。</p>
<pre><code class="language-bash">npm install &lt;package_name&gt;</code></pre>
<p>该命令将在当前工作目录中创建一个<code>node_modules</code>文件夹，并将软件包安装到该文件夹中。</p>
<p>全局安装意味着安装软件包的计算机上的所有应用程序都可以使用该代码。全局安装应当谨慎使用，因为它会在计算机上创建一个全局软件包，这可能会导致版本冲突。</p>
<p>要安装<code>node_modules</code>文件夹中的所有软件包，要使用以下命令：</p>
<pre><code class="language-bash">npm install -g &lt;package_name&gt;</code></pre>
<h1 id="2-异步io与回调编程"><a class="markdownIt-Anchor" href="#2-异步io与回调编程"></a> 2. 异步I/O与回调编程</h1>
<h2 id="21-异步io"><a class="markdownIt-Anchor" href="#21-异步io"></a> 2.1. 异步I/O</h2>
<p>所有的网络操作都是异步的，因为它们需要等待网络响应。</p>
<blockquote>
<p>网络服务调用的响应可能不会立即返回。当应用程序阻塞（或等待）网络操作完成时，就会浪费服务器上的处理时间。</p>
</blockquote>
<p>Node.js以非阻塞方式进行所有网络操作。每个网络操作都会立即返回。要处理网络调用的结果，就需要编写一个回调函数。</p>
<p>应用程序、Node.js框架、调用远程服务器的网络服务和回调函数之间的交互如下：</p>
<ol>
<li>应用程序会调用<code>http.request()</code>，该函数会调用远程网络服务器并请求网络服务</li>
<li>在Node.js框架从远程网络服务器接收HTTP响应消息之前，它会立即返回<code>http.request()</code>函数调用的结果。该结果只表明请求消息已成功发送，并不会说明任何有关响应消息的信息</li>
<li>当Node.js框架从远程服务器接收到HTTP响应消息时，它会调用在<code>http.request()</code>函数调用过程中定义的回调函数。该函数处理HTTP响应消息，并将结果返回给应用程序</li>
</ol>
<pre><code class="language-js">let options = &#123;  // included the hostname of the remote server, and a URL resource path
    host: &quot;w1.weather.gov&quot;,
    path: &quot;/xml/current_obs/KSFO.xml&quot;
&#125;;

http.request(options, function(response) &#123;  // when the Node.js module calls this anonymous function, events occur while it is receiving parts of the HTTP response object
    let buffer = &quot;&quot;;
    let result = &quot;&quot;;
    
    response.on(&quot;data&quot;, function(chunk) &#123;
        buffer += chunk;
    &#125;);
    
    response.on(&quot;end&quot;, function() &#123;
        console.log(buffer);
    &#125;);
&#125;).end();</code></pre>
<ul>
<li>在实际的应用程序时，你可能需要使用HTTPS而不是HTTP</li>
</ul>
<h4 id="211-httprequest"><a class="markdownIt-Anchor" href="#211-httprequest"></a> 2.1.1. <code>http.request()</code></h4>
<p>该函数接收一个URL和一组选项。如果URL和选项都被传入，则将两者合并，选项优先。</p>
<pre><code class="language-js">http.request(options, [callback function]);</code></pre>
<p>该方法还可以接收一个可选的回调函数，在收到响应后立即调用。</p>
<pre><code class="language-js">http.request(options, function(response) &#123; ... &#125;);</code></pre>
<p>当<code>http.request()</code>调用回调函数时，会在回调函数的第一个参数中传递一个响应对象。该回调函数的第一个参数就是响应对象。</p>
<p>Node.js框架会在请求函数运行时发出多个事件。你可以使用<code>object.on()</code>方法并将事件名称作为第一个参数传递，从而监听这些事件。如果请求成功，每次数据输入时都会在响应对象上触发一个数据事件，响应结束时触发一个结束事件。</p>
<h4 id="212-处理错误"><a class="markdownIt-Anchor" href="#212-处理错误"></a> 2.1.2. 处理错误</h4>
<p>如果请求失败，在<code>close</code>事件之后就会出现<code>error</code>事件。</p>
<pre><code class="language-js">let request = http.request(options, function(response) &#123; ... &#125;);
                                                        
request.on(&quot;error&quot;, function(e) &#123;
    resultCallback(e.message);
&#125;);
request.end();</code></pre>
<h2 id="22-回调函数"><a class="markdownIt-Anchor" href="#22-回调函数"></a> 2.2. 回调函数</h2>
<p>作为一个异步框架，Node.js广泛地使用了回调函数。回调函数是一个函数，它作为参数传递给另一个函数，并在另一个函数完成后调用。</p>
<p>软件开发工具包（SDK）中的Node.js模块会将错误对象作为回调函数的第一个参数。</p>
<pre><code class="language-js">Call function((error))</code></pre>
<p>根据这一约定，回调函数会检查第一个参数是否包含了错误对象。</p>
<pre><code class="language-js">function(error, parameter1, parameter2, ...) &#123; ... &#125;</code></pre>
<p>如果定义了错误对象，回调函数就会处理错误并清理所有打开的网络或数据库连接。</p>
<pre><code class="language-js">weather.current(location, function(error, temp_f) &#123;
    if (error) &#123;
        console.log(error);  // if the error is defined, print the error message
        return;
    &#125;
    
    // otherwise, the weather.current function call completed successfully
    console.log(&quot;The current weather reading is %s degrees.&quot;, temp_f);
&#125;);

response.end(&quot;... $&#123;temp_f&#125;_&quot;)</code></pre>
<h4 id="221-传递错误对象"><a class="markdownIt-Anchor" href="#221-传递错误对象"></a> 2.2.1. 传递错误对象</h4>
<pre><code class="language-js">exports.current = function(location, resultCallback) &#123;
    // ...
    http.request(options, function(response) &#123;
        let buffer = &quot;&quot;;
        let result = &quot;&quot;;
        
        response.on(&quot;data&quot;, function(chunk) &#123;
            buffer += chunk;
        &#125;);
        
        response.on(&quot;end&quot;, function() &#123;
            parseString(buffer, function(error, result) &#123;
                if (error) &#123;
                    resultCallback(error);
                    return;
                &#125;
                
                resultCallback(null, result.current_observation.temp_f[0]);
            &#125;);
        &#125;);
    &#125;);
&#125;</code></pre>
<h4 id="222-每级一个回调"><a class="markdownIt-Anchor" href="#222-每级一个回调"></a> 2.2.2. 每级一个回调</h4>
<p>当Node.js应用程序以非阻塞方式来调用一个模块时，该应用程序会提供一个回调函数来处理结果。 如果主应用程序调用了<code>http.request()</code>，它就必须提供一个回调处理程序来处理HTTP响应消息。</p>
<p>如果主应用程序调用了一个调用了<code>http.request()</code>的函数，那就会有两个回调函数：</p>
<ol>
<li>自定义模块有一个回调函数，用于处理来自<code>http.request()</code>的HTTP响应消息</li>
<li>主营用程序有一个回调函数，用于处理第一个回调函数捕获的结果</li>
</ol>
<p>带回调的主应用程序：</p>
<pre><code class="language-js">let weather = require(&quot;./weather&quot;);
let location = &quot;KSFO&quot;;

weather.current(location, function(temp_f) &#123;
    console.log(temp_f);
&#125;);</code></pre>
<p>主程序调用<code>weather.current()</code>时，会传递一个匿名的回调函数来处理调用结果。</p>
<pre><code class="language-js">exports.current = function(location, resultCallback) &#123;
    // ...
    http.request(options, function(response) &#123;
        // ...
        response.on(&quot;end&quot;, function() &#123;
            resultCallback(...);
        &#125;);
    &#125;).end();
&#125;</code></pre>
<p>自定义的Node.js模块函数中的<code>resultCallback()</code>函数链接着主应用程序中<code>weather.current()</code>函数的匿名回调函数<code>function(temp_f)</code>。</p>
<p>通过回调返回结果：</p>
<pre><code class="language-js">exports.current = function(location, resultCallback) &#123;
    let option = &#123;
        host: &quot;w1.weather.gov&quot;,
        path: &quot;/xml/current_obs/&quot; + location + &quot;.xml&quot;
    &#125;;
    
    http.request(options, function(response) &#123;
        let buffer = &quot;&quot;;
        
        response.on(&quot;data&quot;, function(chunk) &#123;
            buffer += chunk;
        &#125;);
        
        response.on(&quot;end&quot;, function() &#123;
            parseString(buffer, function(error, result) &#123;
                // ...
                resultCallback(null, result.current_observation.temp_f[0]);
            &#125;);
        &#125;);
    &#125;).end();
&#125;</code></pre>
<p>另一个回调函数的例子：</p>
<pre><code class="language-js">const message = function() &#123;
    console.log(&quot;This message is shown after 3 seconds&quot;);
&#125;

setTimeout(message, 3000);</code></pre>
<p>JavaScript中有一个内置方法叫<code>setTimeout()</code>，它会在执行操作前等待指定的时间（以毫秒为单位）。在示例中，信息被传入<code>setTimeout()</code>函数。因此，在等待3秒后，<code>setTimeout()</code>会将消息写入控制台。</p>
<p>通常这些异步回调（简称async）都用于访问数据库中的数值、下载图像、读取文件等。</p>
<h4 id="223-回调地狱"><a class="markdownIt-Anchor" href="#223-回调地狱"></a> 2.2.3. 回调地狱</h4>
<p>回调地狱是指在异步编程中，回调函数嵌套过多，导致代码难以阅读和维护。每个回调函数都依赖于前一个回调函数，并等待前一个回调函数完成后才能执行。</p>
<pre><code class="language-js">firstFunction(args, function() &#123;
    secondFunction(args, function() &#123;
        thirdFunction(args, function() &#123;
            // And so on ...
        &#125;);
    &#125;);
&#125;);</code></pre>
<blockquote>
<p>这种结构有时也被称为“The Pyramid of Doom”（末日金字塔）。</p>
</blockquote>
<p>回调的另一个问题是IoC（控制反转）。当控制流（如指令的执行）处于代码的外部时，就会发生控制反转。很多时候，回调会将控制权转交给第三方，但是第三方代码的问题和错误可能很难被发现。这种情况下你不得不去信任第三方代码或者编写额外的代码来确保第三方代码不会在不应该的时候被调用、被调用的次数过多或过少、丢失上下文、传回错误的参数等。</p>
<p>要想缓解回调地狱和IoC的问题，你可以：</p>
<ul>
<li>写注释</li>
<li>使用Promise</li>
<li>将函数拆分成更小的函数</li>
<li>使用<code>async/await</code></li>
</ul>
<h2 id="23-promise"><a class="markdownIt-Anchor" href="#23-promise"></a> 2.3. Promise</h2>
<p>对于API请求、I/O操作和其他异步操作，Promise是一种更好的解决方案。</p>
<pre><code class="language-js">let prompt = require(&quot;prompt-sync&quot;);
let fs = require(&quot;fs&quot;);

const methCall = new Promise((resolve, reject) =&gt; &#123;
    setTimeout(() =&gt; &#123;
        let filename = prompt(&quot;What is the name of the file?&quot;);
        try &#123;
            const data = fs.readFileSync(filename, &#123;
                encoding: &quot;UTF-8&quot;,
            	flag: &quot;r&quot;
            &#125;);
            resolve(data);
        &#125; catch(err) &#123;
            reject(err);
        &#125;
    &#125;, 3000);
&#125;);</code></pre>
<h4 id="231-axios请求"><a class="markdownIt-Anchor" href="#231-axios请求"></a> 2.3.1. Axios请求</h4>
<p>HTTP请求在同步调用时可能会阻塞。Node.js生态系统中有许多包，它们将Promise封装在HTTP请求中，axios就是其中之一。</p>
<pre><code class="language-js">const axios = require(&quot;axios&quot;).default;

const connectToURL = (url) =&gt; &#123;
    const req = axios.get(url);  // the status of the promise until it hears back from the URL requested is pending
    console.log(req);
    req.then(resp =&gt; &#123;
        console.log(&quot;Fulfilling&quot;);
        console.log(resp.data);
    &#125;)
    .catch(err =&gt; &#123;
        console.log(&quot;Rejected&quot;);
    &#125;);
&#125;</code></pre>
<h2 id="24-json"><a class="markdownIt-Anchor" href="#24-json"></a> 2.4. JSON</h2>
<p>JSON是API数据交换的标准格式。</p>
<p>要将JSON字符串解析为JavaScript对象，可以使用方法<code>JSON.parse()</code>。而要将JavaScript对象转换为JSON字符串，可以使用方法<code>JSON.stringify()</code>。</p>
<h1 id="3-express网页开发框架"><a class="markdownIt-Anchor" href="#3-express网页开发框架"></a> 3. Express网页开发框架</h1>
<p>默认的Node.js框架为构建网页应用程序提供了一套有限的功能。</p>
<blockquote>
<p>例如，Node.js不提供XML消息的解析功能。在简单消息中，你可以使用JavaScript字符串函数来解析消息，也可以使用XML文档对象，但该对象解析XML数据流的效率并不高。</p>
</blockquote>
<p>开发人员往往依赖第三方软件包来扩展Node.js功能。</p>
<p>你可以将网络服务信息解析为字符串：</p>
<pre><code class="language-js">response.on(&quot;data&quot;, function(chunk) &#123;
    buffer += chunk;
&#125;);

response.on(&quot;end&quot;, function() &#123;
    let matches = buffer.match(/\&lt;temp_f\&gt;.+\&lt;\/temp_f\&gt;/g);
    if (null != matches || matches.length &gt; 0) &#123;
        let result = matches[0].replace(/\&lt;temp_f\&gt;/, &quot;&quot;).replace(/\&lt;\temp_f\&gt;/, &quot;&quot;);
    &#125;
    
    resultCallback(null, result);
&#125;);</code></pre>
<p>这种手动解析的方法有着许多缺点：</p>
<ul>
<li>字符串匹配忽略了XML数据的结构</li>
<li>信息体可能包含了畸形的XML数据</li>
<li>根据XML数据的复杂程度，字符串匹配可能要比构建数据的XML树更有效率</li>
<li>字符串匹配对XML数据结构变化的容忍度很低</li>
<li>如果信息添加或删除了任何XML元素，那就必须更改字符串匹配函数的正则表达式</li>
</ul>
<p>xml2js是一个流行的Node.js软件包，它可以将XML数据解析为JavaScript对象。与其他XML解析包不同，xml2js只使用JavaScript而不是其他语言。</p>
<blockquote>
<p>第三方软件包的软件许可可能与Node.js框架不同。在安装软件包之前，请确认许可条款是否适用于你的公司和应用程序。</p>
</blockquote>
<pre><code class="language-bash">npm install xml2js</code></pre>
<p>将软件包导入到Node.js应用程序中：</p>
<pre><code class="language-js">let parseString = require(&quot;xml2js&quot;).parseString;
exports.current = function(location, resultCallback) &#123;
    // ...
    let request = https.request(options, function(response) &#123;
        // ...
        response.on(&quot;end&quot;, function() &#123;
            parseString(buffer, function(error, result) &#123;
                if (error) &#123; ... &#125;
                
                // the result JavaScript variable represents the contents of the XML fragment in buffer
                resultCallback(null, result.current_observation.temp_f[0]);
            &#125;);
        &#125;);
    &#125;);
&#125;</code></pre>
<h2 id="31-网页框架"><a class="markdownIt-Anchor" href="#31-网页框架"></a> 3.1. 网页框架</h2>
<p>Node.js不是网页框架，而是在服务器上执行JavaScript的runtime环境。网页框架是支持网页应用程序的基本结构，因此要使用Node.js，就需要使用与之配合使用的网页框架。</p>
<p>与Node.js协同工作的框架被称为node网页框架。它们可采用两种方法构建后端：</p>
<ol>
<li>MVC（模型-视图-控制器）：将应用程序分解为三个部分，每个部分都有自己的职责</li>
<li>REST API</li>
</ol>
<h4 id="311-mvc"><a class="markdownIt-Anchor" href="#311-mvc"></a> 3.1.1. MVC</h4>
<p>MVC是一种设计模式，用于将应用程序分解为三个部分：</p>
<ol>
<li>模型：负责处理数据</li>
<li>视图：负责渲染模型传递的数据</li>
<li>控制器：负责管理数据流、处理用户提供的数据，并将数据发送给模型</li>
</ol>
<p>MVC框架一般用于开发需要将数据、数据的展示和操作数据的模块分开的应用程序。</p>
<p>MVC模式的框架包括Koa、Django、Express和NestJS。</p>
<h4 id="312-rest-api"><a class="markdownIt-Anchor" href="#312-rest-api"></a> 3.1.2. REST API</h4>
<p>REST API允许多个网络服务相互通信。但这会受到一些限制：客户端的代码必须完全独立于服务器端的代码；客户端代码的更新不会干扰服务器端代码的运行，反之亦然。</p>
<p>REST API是无状态的。这代表着客户端不需要知道服务器的状态，服务器也不需要知道客户端的状态。这种无状态的特性使得REST API非常适合用于构建分布式应用程序。</p>
<p>REST API通过对资源的操作进行通信，不依赖于API的特定实现。当客户端使用<code>GET</code>、<code>POST</code>、<code>PUT</code>和<code>DELETE</code>等HTTP方法与服务器通信时，服务器便会向客户端响应资源状态。</p>
<h4 id="313-express"><a class="markdownIt-Anchor" href="#313-express"></a> 3.1.3. Express</h4>
<p>Express.js是最流行的node网页框架之一。它用于路由和中间件、使用JavaScript进行直接编程，意味着学习曲线很低。</p>
<p>Express.js提供调试机制，有助于轻松找出应用程序中的错误。它采用异步编程方式，同时处理多个相互独立的操作请求，因此性能很好。</p>
<h4 id="314-koa"><a class="markdownIt-Anchor" href="#314-koa"></a> 3.1.4. Koa</h4>
<p>Koa是一个相对较新的网页框架，由设计Express的同一团队设计。它设计得更小巧、更具表现力，并为网页应用程序和API提供了更强大的基础。</p>
<p>Koa使用异步函数，因此不需要回调，这提高了处理错误的能力。该框架适合由经验丰富的大型团队开发高性能、高要求、复杂的应用程序。</p>
<h4 id="315-socketio"><a class="markdownIt-Anchor" href="#315-socketio"></a> 3.1.5. <a target="_blank" rel="noopener" href="http://Socket.IO">Socket.IO</a></h4>
<p>Socket.IO是开发在客户端和服务器之间实时交换双向数据的应用程序的绝佳选择。你可以开发利用Websocket而不是HTTP协议的应用程序。</p>
<p>它的服务器可以推送数据，而无需客户端调用数据，因此十分适用于聊天室、短信应用、视频会议和多人游戏等应用程序。</p>
<h4 id="316-hapijs"><a class="markdownIt-Anchor" href="#316-hapijs"></a> 3.1.6. Hapi.js</h4>
<p>Hapi.js是一个可靠的开源节点网页框架，内置了大量安全功能。它的插件系统使得开发人员可以轻松地扩展应用程序的功能。</p>
<p>它最著名的用途是开发代理和API服务器、HTTP代理用户程序、REST API以及其他桌面和应用程序。</p>
<h4 id="317-nestjs"><a class="markdownIt-Anchor" href="#317-nestjs"></a> 3.1.7. NestJS</h4>
<p>NestJS框架适合构建动态、可扩展的企业应用程序，其灵活性得益于大量的库。它采用了MVC架构。</p>
<p>NestJS构建在Express的基础之上，因此它们具有相似的功能。</p>
<p>NestJS与TypeScript兼容，还能与前端Angular框架结合使用。</p>
<blockquote>
<p>TypeScript是一种JavaScript的超集，它添加了类型和其他功能，以帮助开发人员编写更好的代码。</p>
</blockquote>
<p>NestJS结合了面向对象编程和函数式编程的优点，因此它的代码易于阅读和维护。</p>
<h2 id="32-express"><a class="markdownIt-Anchor" href="#32-express"></a> 3.2. Express</h2>
<p>Express主要用于两个目的：</p>
<ol>
<li>API</li>
<li>使用服务端渲染（SSR）来设置模板</li>
</ol>
<p>Express API设置了一个与应用程序数据层交互的HTTP接口。在API的情况下，数据会使用响应对象（简称<code>res</code>）以JSON格式返回给客户端。</p>
<p><code>res.json()</code>方法用于通知客户端发送数据的内容类型，如图像或文本。它还可用于对数据进行字符串化。</p>
<p>而在SSR中，Express用于设置模板。Express负责使用客户端通过HTTP请求的数据、结合模板动态编写HTML、CSS和/或JavaScript。</p>
<h4 id="321-nodejs应用程序框架"><a class="markdownIt-Anchor" href="#321-nodejs应用程序框架"></a> 3.2.1. Node.js应用程序框架</h4>
<p>Express实现了一个<code>app</code>类，你可以将其映射到网络资源路径。</p>
<pre><code class="language-js">const express = require(&quot;express&quot;);
const app = express();
const port = 3000;
// ...
let server = app.listen(port, function() &#123;
    console.log(`Listening on URL http://localhost:$&#123;port&#125;`);
&#125;);</code></pre>
<h4 id="322-express是如何工作的"><a class="markdownIt-Anchor" href="#322-express是如何工作的"></a> 3.2.2. Express是如何工作的</h4>
<ol>
<li>在Node.js项目的包文件中，将Express作为依赖项添加到<code>dependencies</code>属性中</li>
<li>运行<code>npm</code>命令来下载缺少的模块</li>
<li>导入Express模块并创建一个Express应用程序实例</li>
<li>创建一个新的路由处理程序</li>
<li>在指定端口号上启动HTTP服务器</li>
</ol>
<pre><code class="language-js">// mynodeserver.js
const express = require(&quot;express&quot;);
const app = express();
const port = 3000;
app.get(&#x27;/temperature/:location_code&#x27;, function(request, response) &#123;
    const varlocation = request.params.location_code;
    weather.current(location, function(error, temp_f) &#123;
        // ...
    &#125;);
&#125;);
let server = app.listen(port, function() &#123;
    console.log(`Listening on URL http://localhost:$&#123;port&#125;`);
&#125;);</code></pre>
<p>要处理网页应用程序请求，可将HTTP方法和网络资源路径映射到JavaScript函数。</p>
<h4 id="323-路由"><a class="markdownIt-Anchor" href="#323-路由"></a> 3.2.3. 路由</h4>
<p>路由是服务器端脚本的一个重要组成部分。对同一服务器的不同路由的请求必须由服务器处理。服务器必须处理对每个路由的请求，否则就会返回相应的错误信息。路由可在应用程序级或路由器级处理。</p>
<pre><code class="language-js">const express = require(&quot;express&quot;);
const app = new express();

app.get(&quot;user/about/:id&quot;, (req, res) =&gt; &#123;
    res.send(&quot;Response about user &quot; + req.params.id);
&#125;);

app.post(&quot;user/about/:id&quot;, (req, res) =&gt; &#123;
    res.send(&quot;Response about user &quot; + req.params.id);
&#125;);

app.get(&quot;item/about/:id&quot;, (req, res) =&gt; &#123;
    res.send(&quot;Response about user &quot; + req.params.id);
&#125;);

app.post(&quot;item/about/:id&quot;, (req, res) =&gt; &#123;
    res.send(&quot;Response about user &quot; + req.params.id);
&#125;);

app.listen(3333, () =&gt; &#123;
    console.log(`Listening at http://localhost:3333`);
&#125;);</code></pre>
<p>你需要在应用程序级别使用单独的方法来处理每个路由上的每个方法。当端点或路由较少时，这种方法很简单。但是，当端点或路由数量增加时，这种方法就会变得复杂。我们需要使用路由器来让我们的代码更加简洁、易于阅读和维护。</p>
<p>路由器本身用于处理分支查询，并以不同方法路由每个查询。</p>
<pre><code class="language-js">const express = require(&quot;express&quot;);
const app = new express();

let userRouter = express.Router();
let itemRouter = express.Router();

app.use(&quot;/item&quot;, itemRouter);
app.use(&quot;/user&quot;, userRouter);

userRouter.get(&quot;/about/:id&quot;, (req, res) =&gt; &#123;
    res.send(&quot;Response about user &quot; + req.params.id);
&#125;);

userRouter.get(&quot;/details/:id&quot;, (req, res) =&gt; &#123;
    res.send(&quot;Details about user &quot; + req.params.id);
&#125;);

itemRouter.get(&quot;/about/:id&quot;, (req, res) =&gt; &#123;
    res.send(&quot;Information about item &quot; + req.params.id);
&#125;);

itemRouter.get(&quot;/details/:id&quot;, (req, res) =&gt; &#123;
    res.send(&quot;Details about item &quot; + req.params.id);
&#125;);

app.listen(3333, () =&gt; &#123;
    console.log(`Listening at http://localhost:3333`);
&#125;);</code></pre>
<h4 id="324-中间件"><a class="markdownIt-Anchor" href="#324-中间件"></a> 3.2.4. 中间件</h4>
<p>中间件包括了可以访问请求和响应对象以及下一个函数的函数。下一个参数决定了函数执行后的操作。</p>
<p>一个Express应用程序可以有多个中间件，而且它们之间可以相互连接。</p>
<p>中间件根据目的、用途和功能分为不同的类型：</p>
<ol>
<li>应用程序级</li>
<li>路由器级</li>
<li>错误处理</li>
<li>内置</li>
<li>第三方</li>
</ol>
<p>应用程序级中间件可以使用<code>app.use()</code>方法绑定到应用程序上：</p>
<pre><code class="language-js">const express = require(&quot;express&quot;);
const app = new express();

app.use(function(req, res, next) &#123;
    if (req.query.password !== &quot;pwd123&quot;) &#123;
        return res.status(402).send(&quot;This user cannot login &quot;);
    &#125;
    console.log(&quot;Time:&quot;, Date.now());
&#125;);

app.get(&quot;/&quot;, (req, res) =&gt; &#123;
    return res.send(&quot;Hello World!&quot;);
&#125;);

app.listen(3333, () =&gt; &#123;
    console.log(`Listening at http://localhost:3333`);
&#125;);</code></pre>
<p>客户端向服务器应用程序发出的所有请求都会通过该中间件进行路由。这种路由对验证和检查会话信息等操作很有用。</p>
<p>路由器级中间件不与应用程序绑定。相反，它与<code>express.Router()</code>实例绑定。你可以为特定路由使用特定的中间件，而不是让所有请求都通过同一个中间件：</p>
<pre><code class="language-js">const express = require(&quot;express&quot;);
const app = new express();

let userRouter = express.Router();
let itemRouter = express.Router();

userRouter.use(function(req, res, next) &#123;
    console.log(&quot;User query Time: &quot;, Date());
    next();
&#125;);

userRouter.get(&quot;/:id&quot;, function(req, res, next) &#123;
    res.send(&quot;User &quot; + req.params.id + &quot; last successful login &quot; + Date());
&#125;);

itemRouter.use(function(req, res, next) &#123;
    console.log(&quot;Item query Time: &quot;, Date());
	next();
&#125;);

itemRouter.get(&quot;/:id&quot;, function(req, res, next) &#123;
    res.send(&quot;Item &quot; + req.params.id + &quot; last enquiry &quot; + Date());
&#125;);

app.use(&quot;/user&quot;, userRouter);
app.use(&quot;/item&quot;, itemRouter);

app.listen(3333, () =&gt; &#123;
    console.log(`Listening at http://localhost:3333`);
&#125;);</code></pre>
<ul>
<li>响应将根据客户端的请求路径而不同</li>
</ul>
<p>错误处理中间件既可以绑定到整个应用程序，也可以绑定到特定路由器：</p>
<pre><code class="language-js">const express = require(&quot;express&quot;);
const app = new express();

app.use(&quot;/user/:id&quot;, function(req, res, next) &#123;
    if (req.params.id == 1) &#123;
        throw new Error(&quot;Trying to access admin login&quot;);
    &#125; else &#123;
        next();
    &#125;
&#125;);

app.use(function(err, req, res, next) &#123;
    if (err != null) &#123;
        res.status(500).send(err.toString());
    &#125; else &#123;
        next();
    &#125;
&#125;);

app.get(&quot;/user/:id&quot;, (req, res) =&gt; &#123;
    return res.send(&quot;Hello! User Id &quot;, req.params.id);
&#125;);

app.listen(3333, () =&gt; &#123;
    console.log(`Listening at http://localhost:3333`);
&#125;);</code></pre>
<p>错误处理中间件总是需要四个参数：<code>error</code>、<code>request</code>、<code>response</code>和<code>next()</code>。不过，你可以省略<code>next()</code>参数；即使省略了，也可以在方法中定义。</p>
<p>内置中间件可以绑定到整个应用程序或者特定路由器上。内置中间件对于从服务器渲染HTML、解析来自前端的JSON输入和解析cookie等操作很有用。</p>
<pre><code class="language-js">const express = require(&quot;express&quot;);
const app = new express();

// define the static files that can be rendered from the cad220_staticfiles directory
app.use(express.static(&quot;cad220_staticfiles&quot;));

app.listen(3333, () =&gt; &#123;
    console.log(`Listening at http://localhost:3333`);
&#125;);</code></pre>
<p>你也可以定义自己的中间件或使用第三方中间件，这些中间件可以通过<code>npm install</code>命令安装。</p>
<p>创建中间件很简单。你可以定义一个包含三个参数的函数，然后将其与<code>app.use()</code>或者<code>router.use()</code>绑定。中间件的顺序取决于<code>.use()</code>方法用于绑定中间件的顺序。</p>
<pre><code class="language-js">const express = require(&quot;express&quot;);
const app = new express();

function myLogger(req, res, next) &#123;
    req.timeReceived = Date();
    next();
&#125;

app.use(myLogger);

app.get(&quot;/&quot;, (req, res) =&gt; &#123;
    res.send(&quot;Request received at &quot; + req.timeReceived + &quot; is a success!&quot;);
&#125;);

app.listen(3333, () =&gt; &#123;
    console.log(`Listening at http://localhost:3333`);
&#125;);</code></pre>
<h4 id="325-模板渲染"><a class="markdownIt-Anchor" href="#325-模板渲染"></a> 3.2.5. 模板渲染</h4>
<p>模板渲染是服务器在HTML模板中填充动态内容的能力。</p>
<pre><code class="language-js">const express = require(&quot;express&quot;);
const app = new express();
const expressReactViews = require(&quot;express-react-views&quot;);

const jsxEngine = expressReactViews.createEngine();

app.set(&quot;view engine&quot;, &#x27;jsx&#x27;);  // views are JSX code

app.set(&quot;views&quot;, &quot;myviews&quot;);  // the views are in a directory named myviews

app.engine(&quot;jsx&quot;, jsxEngine);

app.get(&quot;/:name&quot;, (req, res) =&gt; &#123;
   res.render(&quot;index&quot;, &#123;name: req.params.name&#125;);
&#125;);

app.listen(3333, () =&gt; &#123;
   console.log(`Listening at http://localhost:3333`);
&#125;);</code></pre>
<p>本代码示例使用了express-react-views软件包，它是一个用于渲染React视图的Express模板引擎。</p>
<h2 id="33-验证"><a class="markdownIt-Anchor" href="#33-验证"></a> 3.3. 验证</h2>
<p>身份验证是通过获取凭证并使用这些凭证验证用户身份的过程。身份验证的目的是识别用户身份，并根据其身份提供访问权限和内容。</p>
<p>身份验证可以通过以下方法实现：</p>
<ul>
<li>基于会话</li>
<li>基于令牌</li>
<li>无密码</li>
</ul>
<h4 id="331-基于令牌的身份验证"><a class="markdownIt-Anchor" href="#331-基于令牌的身份验证"></a> 3.3.1. 基于令牌的身份验证</h4>
<p>基于令牌的身份验证是在Node.js中实施身份验证的最常见方法。由于令牌只需存储在客户端，所以基于令牌的身份验证更具有可扩展性；服务器只需要验证令牌和用户信息，因此更容易处理多个用户；其灵活性能够在多个服务器上实现身份验证。基于令牌的身份验证中使用的JWT可以签名和加密，这意味着它们不会被篡改、没有私人加密密钥便无法读取。</p>
<p>让我们建立一个Express.js API服务器、根据使用权限访问员工信息。应用程序将有两个API，每个API都有自己的端点：</p>
<ol>
<li>使用<code>POST</code> API登录，通过在请求体中发送用户名和密码、返回网页令牌（对该应用程序接口端点的调用应当通过托管应用程序前端的网页服务器来进行）</li>
<li><code>GET</code> API将获取只有通过身份验证的用户才能访问的员工信息：<pre><code class="language-js">const express = require(&quot;express&quot;);
const myapp = express();

// creates a web server module by calling the express() function and assigning it to the constant myapp
// the myapp.get() function creates a GET API endpoint for the Employees API, and any call to this endpoint currently returns an HTTP status code of 401
// 401 means Not Authorized
myapp.get(&quot;/employees&quot;. (req, res) =&gt; &#123;
    return res.status(401).json(&#123;message: &quot;Please login to access this resource&quot;&#125;);
&#125;);

myapp.listen(5000, () =&gt; &#123;
    console.log(&quot;API Server is localhost:5000&quot;);
&#125;);</code></pre>
在代码的下一部分，只要用户名和密码正确，我们就允许用户登录，并返回经过验证生成的令牌。一般来说，用户名和密码都存储在数据库中。但是，为了简单起见，我们将在代码中使用“user”和“password”作为用户名和密码。<br>
要生成经过验证的JWT（JSON Web Token），要使用jsonwebtoken包：<pre><code class="language-js">const express = require(&quot;express&quot;);
const jsonwebtoken = require(&quot;jsonwebtoken&quot;);

const JWT_SECRET = &quot;aVeryVerySecretString&quot;;</code></pre>
通过<code>myapp.use()</code>方法，API方法可以返回JSON响应：<pre><code class="language-js">const myapp = express();
myapp.use(express.json());

myapp.post(&quot;/signin&quot;, (req, res) =&gt; &#123;
    const &#123;uname, pwd&#125; = req.body;
    // however, that the JWT Secret should always be generated using a password generator and stored in the config file as an environment variable and not hard coded in the API, as shown here
&#125;);</code></pre>
然后将请求正文中的用户名和密码与从数据库中获取的值进行比较：<pre><code class="language-js">if (uname === &quot;user&quot; &amp;&amp; pwd === &quot;password&quot;) &#123;
    return res.json(&#123;
        // Once the username and password match, the JWT is generated using the jsonwebstoken.sign() function by including the username and the JWT secret as parameters and is returned as a JSON response from the signin API
        token: jsonwebtoken.sign(&#123;user: &quot;user&quot;&#125;, JWT_SECRET)
    &#125;);
    // if the username and password match fails, then a HTTP status code of 401 is returned with the message &quot;Invalid username and/or password&quot;
    return res.status(401).json(&#123;message: &quot;Invalid username and/or password&quot;&#125;);
&#125;);</code></pre>
接着，我们用“employees”端点定义<code>GET</code> API方法：<pre><code class="language-js">myapp.get(&quot;/employees&quot;, (req, res) =&gt; &#123;
    let tkn = req.header(&quot;Authorization&quot;);
    if (!tkn) return res.status(401).send(&quot;No Token&quot;);
    if (tkn.startsWith(&quot;Bearer &quot;)) &#123;
        tokenValue = tkn.slice(7, tkn.length).trimLeft();
    &#125;
    // ...
&#125;);</code></pre>
从<code>signin</code> API调用中获取的令牌会在<code>Authorization</code>标头中传递。<code>GET</code> API（也就是“employees”）已更新，可以使用<code>req.header()</code>函数从传入的API请求中读取<code>Authorization</code>标头。值得注意的是，<code>Authorization</code>标头的值总是以<code>Bearer</code>开头，因此这个令牌也被称为Bearer令牌。<br>
获取的JWT可通过传递获取的令牌和JWT密钥、使用函数<code>jsonwebtoken.verify()</code>进行验证：<pre><code class="language-js">myapp.get(&quot;/employees&quot;, (req, res) =&gt; &#123;
    // ...
    const verificationStatus = jsonwebtoken.verify(tokenValue, &quot;aVeryVerySecretString&quot;);
    if (verificationStatus.user === &quot;user&quot;) &#123;
        return res.status(200).json(&#123;message: &quot;Access Successful to Employee Endpoint&quot;&#125;);
    &#125;
&#125;);</code></pre>
如果验证失败，则会将401状态码返回给客户端。</li>
</ol>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="948f.html">上一篇</a><a class="next" href="d011.html">下一篇</a></div><div class="copyright"><p>© 2022 - 2025 <a href="https://cytrogen.icu">Cytrogen</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/cytrogen/hexo-theme-ares" target="_blank">hexo-theme-ares</a>.</p></div></footer></div></div><a class="back-to-top" href="#top" aria-label="返回顶部"><svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path d="M3.293 9.707a1 1 0 010-1.414L9.586 2a2 2 0 012.828 0l6.293 6.293a1 1 0 01-1.414 1.414L11 3.414V17a1 1 0 11-2 0V3.414L2.707 9.707a1 1 0 01-1.414 0z"></path></svg></a><script>document.addEventListener('DOMContentLoaded', function() {
  const codeBlocks = document.querySelectorAll('figure.highlight');
  
  codeBlocks.forEach(block => {
    let caption = block.querySelector('figcaption');
    if (!caption) {
      caption = document.createElement('figcaption');
      block.insertBefore(caption, block.firstChild);
    }

    const info = document.createElement('div');
    info.className = 'info';
    
    const filename = caption.querySelector('span');
    if (filename) {
      filename.className = 'filename';
      info.appendChild(filename);
    }
    
    const lang = block.className.split(' ')[1];
    if (lang) {
      const langSpan = document.createElement('span');
      langSpan.className = 'lang-name';
      langSpan.textContent = lang;
      info.appendChild(langSpan);
    }

    const sourceLink = caption.querySelector('a');
    if (sourceLink) {
      sourceLink.className = 'source-link';
      info.appendChild(sourceLink);
    }

    const actions = document.createElement('div');
    actions.className = 'actions';

    const codeHeight = block.scrollHeight;
    const threshold = 300;

    if (codeHeight > threshold) {
      block.classList.add('folded');
      
      const toggleBtn = document.createElement('button');
      toggleBtn.textContent = '展开';
      toggleBtn.addEventListener('click', () => {
        block.classList.toggle('folded');
        toggleBtn.textContent = block.classList.contains('folded') ? '展开' : '折叠';
      });
      actions.appendChild(toggleBtn);
    }

    const copyBtn = document.createElement('button');
    copyBtn.textContent = '复制';
    copyBtn.addEventListener('click', async () => {
      const codeLines = block.querySelectorAll('.code .line');
      const code = Array.from(codeLines)
        .map(line => line.textContent)
        .join('\n')
        .replace(/\n\n/g, '\n');
      
      try {
        await navigator.clipboard.writeText(code);
        copyBtn.textContent = '已复制';
        copyBtn.classList.add('copied');
        
        setTimeout(() => {
          copyBtn.textContent = '复制';
          copyBtn.classList.remove('copied');
        }, 3000);
      } catch (err) {
        console.error('复制失败:', err);
        copyBtn.textContent = '复制失败';
        
        setTimeout(() => {
          copyBtn.textContent = '复制';
        }, 3000);
      }
    });
    actions.appendChild(copyBtn);

    caption.innerHTML = '';
    caption.appendChild(info);
    caption.appendChild(actions);

    const markedLines = block.getAttribute('data-marked-lines');
    if (markedLines) {
      const lines = markedLines.split(',');
      lines.forEach(range => {
        if (range.includes('-')) {
          const [start, end] = range.split('-').map(Number);
          for (let i = start; i <= end; i++) {
            const line = block.querySelector(`.line-${i}`);
            if (line) line.classList.add('marked');
          }
        } else {
          const line = block.querySelector(`.line-${range}`);
          if (line) line.classList.add('marked');
        }
      });
    }
  });
});</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=G-4PVPZXE0QQ"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-4PVPZXE0QQ');</script><script>(function() {
  // Wait for DOM to be ready
  document.addEventListener('DOMContentLoaded', function() {
    const themeToggle = document.querySelector('.theme-toggle');
    
    if (!themeToggle) return;
    
    // Get current theme
    const getCurrentTheme = () => {
      return document.documentElement.getAttribute('data-theme') || 'light';
    };
    
    // Update UI to match current theme
    const updateUI = (theme) => {
      const isDark = theme === 'dark';
      themeToggle.setAttribute('aria-pressed', isDark.toString());
    };
    
    // Simplified theme setter - CSS handles all animations
    const setTheme = (theme) => {
      document.documentElement.setAttribute('data-theme', theme);
      document.documentElement.style.colorScheme = theme; // Update native UI elements
      
      // Also update page-wrapper for animation support
      const pageWrapper = document.getElementById('page-wrapper');
      if (pageWrapper) {
        pageWrapper.setAttribute('data-theme', theme);
      }
      
      // Find and remove the temporary anti-flicker style tag if it exists.
      // This ensures the main stylesheet takes full control after the initial load.
      const antiFlickerStyle = document.getElementById('anti-flicker-style');
      if (antiFlickerStyle) {
        antiFlickerStyle.remove();
      }
      
      localStorage.setItem('theme', theme);
      updateUI(theme);
    };
    
    // Simple theme toggle - letting CSS handle the smooth transitions
    const toggleTheme = () => {
      const current = getCurrentTheme();
      const newTheme = current === 'light' ? 'dark' : 'light';
      setTheme(newTheme);
    };
    
    // Initialize UI on page load
    updateUI(getCurrentTheme());
    
    // Add click event listener
    themeToggle.addEventListener('click', toggleTheme);
    
    // Listen for system theme changes
    if (window.matchMedia) {
      const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
      mediaQuery.addEventListener('change', function(e) {
        // Only update if no manual preference is saved
        if (!localStorage.getItem('theme')) {
          const theme = e.matches ? 'dark' : 'light';
          setTheme(theme);
        }
      });
    }
  });
})();
</script><script>(function() {
  document.addEventListener('DOMContentLoaded', function() {
    const backToTopBtn = document.querySelector('.back-to-top');
    
    if (!backToTopBtn) return;
    
    // Show/hide button based on scroll position
    const toggleButtonVisibility = () => {
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      const shouldShow = scrollTop > 200; // Show after scrolling 200px
      
      if (shouldShow) {
        backToTopBtn.classList.add('is-visible');
      } else {
        backToTopBtn.classList.remove('is-visible');
      }
    };
    
    // Throttle scroll events for better performance
    let ticking = false;
    const handleScroll = () => {
      if (!ticking) {
        requestAnimationFrame(() => {
          toggleButtonVisibility();
          ticking = false;
        });
        ticking = true;
      }
    };
    
    // Smooth scroll to top when clicked
    const scrollToTop = (event) => {
      event.preventDefault();
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    };
    
    // Add event listeners
    window.addEventListener('scroll', handleScroll);
    backToTopBtn.addEventListener('click', scrollToTop);
    
    // Check initial scroll position
    toggleButtonVisibility();
  });
})();</script></body></html>