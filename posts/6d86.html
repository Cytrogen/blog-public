<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>React + NestJS购物平台练习【1】前端项目框架搭建 · Cytrogen 的个人博客</title><meta name="description" content="本文是 React + NestJS 全栈购物平台系列实践的第一篇，专注于从零开始搭建一个现代化的前端项目框架。教程详细记录了项目的初始化、ESLint 与 Prettier 的配置、以及 Tailwind CSS 与 daisyUI 组件库的集成。文章重点讲解了如何使用 react-router-dom 构建路由结构，并引入轻量级状态管理库 Zustand，深入探讨了其状态持久化、选择性订阅和自定义中间件等高级用法。本教程为启动一个健壮、可维护的 React + TypeScript 项目提供了完整的脚手架搭建指南。"><link rel="icon" href="../favicon.png"><link rel="preload" href="../fonts/opensans-regular-latin.woff2" as="font" type="font/woff2" crossorigin="anonymous"><style>@font-face {
  font-family: 'Open Sans';
  src: url('../fonts/opensans-regular-latin.woff2') format('woff2');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
  size-adjust: 107%;
  ascent-override: 97%;
  descent-override: 25%;
  line-gap-override: 0%;
}
</style><link rel="stylesheet" href="../css/ares.css"><script>(function() {
  const getInitialTheme = () => {
    const saved = localStorage.getItem('theme');
    if (saved && (saved === 'light' || saved === 'dark')) {
      return saved;
    }
    
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      return 'dark';
    }
    
    return 'light';
  };
  
  const theme = getInitialTheme();
  document.documentElement.setAttribute('data-theme', theme);
  
  document.documentElement.style.colorScheme = theme;
  
  // Add anti-flicker style for dark mode
  if (theme === 'dark') {
    const style = document.createElement('style');
    style.id = 'anti-flicker-style';
    style.innerHTML = `
      #page-wrapper[data-theme="dark"] {
        background-color: #0f172a;
        color: #f1f5f9;
      }
    `;
    document.head.appendChild(style);
  }
  
  document.addEventListener('DOMContentLoaded', function() {
    const pageWrapper = document.getElementById('page-wrapper');
    if (pageWrapper) {
      pageWrapper.setAttribute('data-theme', theme);
    }
  });
})();

</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="atom.xml" title="Cytrogen 的个人博客" type="application/atom+xml">
</head><body><div id="page-wrapper"><a class="skip-link" href="#main-content">跳到主要内容</a><div class="wrap"><header><a class="logo-link" href="../index.html"><img src="../favicon.png" alt="logo"></a><nav class="site-nav"><div class="nav-main"><div class="nav-primary"><ul class="nav-list hidden-mobile"><li class="nav-item"><a class="nav-link" href="../index.html">首页</a></li></ul><div class="nav-tools"><div class="language-menu"><button class="language-toggle" type="button"><svg class="icon icon-globe" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true" focusable="false"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8zm7.5-6.923c-.67.204-1.335.82-1.887 1.855A7.97 7.97 0 0 0 5.145 4H7.5V1.077zM4.09 4a9.267 9.267 0 0 1 .64-1.539 6.7 6.7 0 0 1 .597-.933A7.025 7.025 0 0 0 2.255 4H4.09zm-.582 3.5c.03-.877.138-1.718.312-2.5H1.674a6.958 6.958 0 0 0-.656 2.5h2.49zM4.847 5a12.5 12.5 0 0 0-.338 2.5H7.5V5H4.847zM8.5 5v2.5h2.99a12.495 12.495 0 0 0-.337-2.5H8.5zM4.51 8.5a12.5 12.5 0 0 0 .337 2.5H7.5V8.5H4.51zm3.99 0V11h2.653c.187-.765.306-1.608.338-2.5H8.5zM5.145 12c.138.386.295.744.468 1.068.552 1.035 1.218 1.65 1.887 1.855V12H5.145zm.182 2.472a6.696 6.696 0 0 1-.597-.933A9.268 9.268 0 0 1 4.09 12H2.255a7.024 7.024 0 0 0 3.072 2.472zM3.82 11a13.652 13.652 0 0 1-.312-2.5h-2.49c.062.89.291 1.733.656 2.5H3.82zm6.853 3.472A7.024 7.024 0 0 0 13.745 12H11.91a9.27 9.27 0 0 1-.64 1.539 6.688 6.688 0 0 1-.597.933zM8.5 12v2.923c.67-.204 1.335-.82 1.887-1.855A7.97 7.97 0 0 0 10.855 12H8.5zm3.68-1h2.146c.365-.767.594-1.61.656-2.5h-2.49a13.65 13.65 0 0 1-.312 2.5zm2.802-3.5a6.959 6.959 0 0 0-.656-2.5H12.18c.174.782.282 1.623.312 2.5h2.49zM11.27 2.461c.247.464.462.98.64 1.539h1.835a7.024 7.024 0 0 0-3.072-2.472c.218.284.418.598.597.933zM10.855 4a7.966 7.966 0 0 0-.468-1.068C9.835 1.897 9.17 1.282 8.5 1.077V4h2.355z"></path></svg><span>中文</span></button><div class="language-dropdown"></div></div></div><div class="nav-controls"><div class="more-menu hidden-mobile"><button class="more-toggle" type="button"><span>更多</span><svg class="icon icon-chevron-down" width="12" height="12" viewBox="0 0 12 12" fill="currentColor" aria-hidden="true" focusable="false"><path d="M6 8.825c-.2 0-.4-.1-.5-.2l-3.3-3.3c-.3-.3-.3-.8 0-1.1s.8-.3 1.1 0l2.7 2.7 2.7-2.7c.3-.3.8-.3 1.1 0s.3.8 0 1.1l-3.3 3.3c-.1.1-.3.2-.5.2z"></path></svg></button><div class="more-dropdown"><ul class="dropdown-list"><li class="dropdown-item"><a class="nav-link" href="../archives">归档</a></li><li class="dropdown-item"><a class="nav-link" href="../categories">分类</a></li><li class="dropdown-item"><a class="nav-link" href="../tags">标签</a></li><li class="dropdown-item"><a class="nav-link" href="../about">关于</a></li><li class="dropdown-item"><a class="nav-link" href="../friends">友链</a></li><li class="dropdown-item"><a class="nav-link" href="../atom.xml">RSS订阅</a></li><li class="dropdown-item"><a class="dropdown-link" href="https://portfolio.cytrogen.icu" target="_blank" rel="noopener noreferrer">作品集<svg class="icon icon-external-link" width="14" height="14" viewBox="0 0 14 14" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8.636 2.364A1 1 0 0 1 10 1h3a1 1 0 0 1 1 1v3a1 1 0 0 1-2 0V3.414l-4.293 4.293a1 1 0 0 1-1.414-1.414L10.586 2H9a1 1 0 0 1-1.364-1.636zM2 3a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V9a1 1 0 1 1 2 0v3a3 3 0 0 1-3 3H2a3 3 0 0 1-3-3V4a3 3 0 0 1 3-3h3a1 1 0 1 1 0 2H2z"></path></svg></a></li><li class="dropdown-item"><a class="dropdown-link" href="https://github.com/cytrogen" target="_blank" rel="noopener noreferrer">GitHub<svg class="icon icon-external-link" width="14" height="14" viewBox="0 0 14 14" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8.636 2.364A1 1 0 0 1 10 1h3a1 1 0 0 1 1 1v3a1 1 0 0 1-2 0V3.414l-4.293 4.293a1 1 0 0 1-1.414-1.414L10.586 2H9a1 1 0 0 1-1.364-1.636zM2 3a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V9a1 1 0 1 1 2 0v3a3 3 0 0 1-3 3H2a3 3 0 0 1-3-3V4a3 3 0 0 1 3-3h3a1 1 0 1 1 0 2H2z"></path></svg></a></li></ul></div></div><div class="theme-switcher"><button class="theme-toggle" type="button" role="switch" aria-pressed="false" aria-label="切换主题"><div class="theme-icon moon-icon"><svg class="icon icon-moon" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true" focusable="false"><path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"></path></svg></div><div class="theme-icon sun-icon"><svg class="icon icon-sun" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0 1a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"></path></svg></div></button></div><details class="mobile-menu-details hidden-desktop"><summary class="hamburger-menu" aria-label="nav.menu"><svg class="icon icon-bars" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true" focusable="false"><path d="M2.5 12a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5z"></path></svg><span class="menu-text">nav.menu</span></summary><div class="mobile-menu-dropdown"><ul class="mobile-nav-list"><li class="mobile-nav-item"><a class="mobile-nav-link" href="../index.html">首页</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../archives">归档</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../categories">分类</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../tags">标签</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../about">关于</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../friends">友链</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../atom.xml">RSS订阅</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="https://portfolio.cytrogen.icu" target="_blank" rel="noopener noreferrer">作品集<svg class="icon icon-external-link" width="14" height="14" viewBox="0 0 14 14" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8.636 2.364A1 1 0 0 1 10 1h3a1 1 0 0 1 1 1v3a1 1 0 0 1-2 0V3.414l-4.293 4.293a1 1 0 0 1-1.414-1.414L10.586 2H9a1 1 0 0 1-1.364-1.636zM2 3a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V9a1 1 0 1 1 2 0v3a3 3 0 0 1-3 3H2a3 3 0 0 1-3-3V4a3 3 0 0 1 3-3h3a1 1 0 1 1 0 2H2z"></path></svg></a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="https://github.com/cytrogen" target="_blank" rel="noopener noreferrer">GitHub<svg class="icon icon-external-link" width="14" height="14" viewBox="0 0 14 14" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8.636 2.364A1 1 0 0 1 10 1h3a1 1 0 0 1 1 1v3a1 1 0 0 1-2 0V3.414l-4.293 4.293a1 1 0 0 1-1.414-1.414L10.586 2H9a1 1 0 0 1-1.364-1.636zM2 3a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V9a1 1 0 1 1 2 0v3a3 3 0 0 1-3 3H2a3 3 0 0 1-3-3V4a3 3 0 0 1 3-3h3a1 1 0 1 1 0 2H2z"></path></svg></a></li></ul></div></details></div></div></div></nav></header><main class="container" id="main-content" tabindex="-1"><div class="post"><article class="post-block"><h1 class="post-title">React + NestJS购物平台练习【1】前端项目框架搭建</h1><div class="post-info">10/29/2024</div><div class="post-content"><p>在现代电子商务发展迅速的今天，构建一个高效、易用的购物平台是开发者的一项关键技能。</p>
<p>该系列是全栈实践新坑，使用 React 和 NestJS 的技术栈、从零开始开发一个完整的购物平台（其实是先前开的几个全栈实践坑都让我意识到自己基础实力不足）。</p>
<span id="more"></span>
<h1 id="1-初始化-react-typescript-项目"><a class="markdownIt-Anchor" href="#1-初始化-react-typescript-项目"></a> 1. 初始化 React + TypeScript 项目</h1>
<ol>
<li>
<p>使用以下命令创建 React 项目：</p>
 <pre><code class="language-bash">yarn create react-app shopping-nest --template typescript</code></pre>
</li>
<li>
<p>导航至 <code>shopping-nest</code> 目录：</p>
 <pre><code class="language-bash">cd shopping-nest</code></pre>
</li>
<li>
<p>使用 Yarn 安装依赖：</p>
 <pre><code class="language-bash">// 安装 ESLint 和 Prettier 相关依赖
yarn add @typescript-eslint/eslint-plugin @typescript-eslint/parser
yarn add -D eslint prettier eslint-config-prettier eslint-plugin-prettier
yarn add -D eslint-config-react-app

// 安装 react-router-dom
yarn add react-router-dom @types/react-router-dom

// 安装 axios
yarn add axios

// 安装 TailwindCSS 相关依赖
yarn add tailwindcss postcss autoprefixer

// 安装 UI 组件和图标库
yarn add @headlessui/react
yarn add lucide-react</code></pre>
</li>
<li>
<p>运行 <code>yarn run start</code> 检查一下是否会出问题。</p>
</li>
</ol>
<h1 id="2-配置-eslint-和-prettier"><a class="markdownIt-Anchor" href="#2-配置-eslint-和-prettier"></a> 2. 配置 ESLint 和 Prettier</h1>
<div class="danger">
<ul>
<li>我使用的是 Jetbrains WebStorm，记得要更新到 2024 的版本喔。</li>
<li>ESLint 的版本为 <code>9.13.0</code>。</li>
<li>Prettier 的版本为 <code>3.3.3</code>。</li>
</ul>
</div>
<h2 id="21-配置-eslint"><a class="markdownIt-Anchor" href="#21-配置-eslint"></a> 2.1. 配置 ESLint</h2>
<ol>
<li>
<p>运行以下命令：</p>
 <pre><code class="language-bash">npx eslint --init</code></pre>
</li>
<li>
<p>根据自己的习惯选择。</p>
</li>
<li>
<p>生成的 <code>mjs</code> 配置文件差不多如下，我自己修改了 <code>files</code> 值为 <code>src</code> 目录下的文件。</p>
 <pre><code class="language-mjs">import globals from &quot;globals&quot;;
import pluginJs from &quot;@eslint/js&quot;;
import tseslint from &quot;typescript-eslint&quot;;
import pluginReact from &quot;eslint-plugin-react&quot;;


export default [
  &#123;files: [&quot;src/**/*.&#123;js,mjs,cjs,ts,jsx,tsx&#125;&quot;]&#125;,
  &#123;languageOptions: &#123; globals: globals.browser &#125;&#125;,
  pluginJs.configs.recommended,
  ...tseslint.configs.recommended,
  pluginReact.configs.flat.recommended,
];</code></pre>
<p>可以查看 <a target="_blank" rel="noopener" href="https://eslint.org/docs/latest/use/configure/">ESLint 官方文档</a>或者 <a target="_blank" rel="noopener" href="https://typescript-eslint.io/users/configs">TypeScript-ESLint 文档</a>自行修改。我自己就保留默认的了。</p>
</li>
</ol>
<h2 id="22-配置-prettier"><a class="markdownIt-Anchor" href="#22-配置-prettier"></a> 2.2. 配置 Prettier</h2>
<ol>
<li>
<p>在项目目录处创建 <code>.prettierrc</code> 文件一个（项目目录这里默认为 <code>package.json</code> 所在的目录）。</p>
</li>
<li>
<p>除了查看 <a target="_blank" rel="noopener" href="https://prettier.io/docs/en/configuration.html">Prettier 官方文档</a>自己填写外，还可以使用一些工具生成 Prettier 配置内容。</p>
<p>我这里用了 <a target="_blank" rel="noopener" href="https://michelelarson.com/prettier-config/">Prettier Config Generator</a> 生成：</p>
 <pre><code class="language-json">&#123;
  &quot;printWidth&quot;: 120,
  &quot;tabWidth&quot;: 2,
  &quot;useTabs&quot;: false,
  &quot;semi&quot;: true,
  &quot;singleQuote&quot;: true,
  &quot;trailingComma&quot;: &quot;none&quot;,
  &quot;bracketSpacing&quot;:true,
  &quot;bracketSameLine&quot;: true,
  &quot;arrowParens&quot;: &quot;avoid&quot;
&#125;</code></pre>
</li>
</ol>
<h1 id="3-配置-tailwind-css"><a class="markdownIt-Anchor" href="#3-配置-tailwind-css"></a> 3. 配置 Tailwind CSS</h1>
<h2 id="31-安装并初始化-tailwind-css-配置"><a class="markdownIt-Anchor" href="#31-安装并初始化-tailwind-css-配置"></a> 3.1. 安装并初始化 TailWind CSS 配置</h2>
<p>在项目目录下使用以下命令来生成 <code>tailwind.config.js</code> 和 <code>postcss.config.js</code>：</p>
<pre><code class="language-bash">npx tailwindcss init -p</code></pre>
<p>然后修改 <code>tailwind.config.js</code> 的内容，将 <code>content</code> 配置为监控 <code>src</code> 文件夹下的所有文件，以便在这些文件中应用 TailWind 的样式：</p>
<pre><code class="language-js">/** @type &#123;import(&#x27;tailwindcss&#x27;).Config&#125; */
export default &#123;
  content: [],
  theme: &#123;
    extend: &#123;&#125;,
  &#125;,
  plugins: []
&#125;;</code></pre>
<p>在 <code>src/index.css</code> 文件的顶部添加以下内容，导入 TailWind 的核心样式、组件和工具：</p>
<pre><code class="language-css">@tailwind base;
@tailwind components;
@tailwind utilities;</code></pre>
<h2 id="32-安装并配置-daisyui-组件库"><a class="markdownIt-Anchor" href="#32-安装并配置-daisyui-组件库"></a> 3.2. 安装并配置 daisyUI 组件库</h2>
<p>为了方便开发，安装 <code>daisyUI</code> 组件库，它提供了丰富的组件和自定义主题功能：</p>
<pre><code class="language-bash">yarn add daisyui</code></pre>
<p>然后在 <code>tailwind.config.js</code> 文件中引入 <code>daisyUI</code> 插件：</p>
<pre><code class="language-js">import daisyui from &quot;daisyui&quot;;

// ...

export default &#123;
  // ...
  plugins: [
    daisyui,
  ],
  daisyui: &#123;&#125;
&#125;</code></pre>
<p>对于 <code>daisyUI</code> 的配置，可以根据其<a target="_blank" rel="noopener" href="https://daisyui.com/docs/config/">文档</a>进行修改。</p>
<p>我安装 <code>daisyUI</code> 还有一个目的，那就是其自定义主题的功能。</p>
<p>在 <code>daisyUI</code> 的<a target="_blank" rel="noopener" href="https://daisyui.com/theme-generator/">主题生成器</a>里，你可以选择自己设计一套颜色方案，或者说随机出一套颜色方案。该页面中还有预览页面可供参考。</p>
<p>我对颜色不敏感，设计能力也很遭殃。这是我随机出的：</p>
<pre><code class="language-js">export default &#123;
  // ...
  daisyui: &#123;
    themes: [
      &#123;
        mytheme: &#123;
          &quot;primary&quot;: &quot;#60a5fa&quot;,
          &quot;primary-content&quot;: &quot;#030a15&quot;,
          &quot;secondary&quot;: &quot;#00b7ac&quot;,
          &quot;secondary-content&quot;: &quot;#000c0b&quot;,
          &quot;accent&quot;: &quot;#d68900&quot;,
          &quot;accent-content&quot;: &quot;#100700&quot;,
          &quot;neutral&quot;: &quot;#182f19&quot;,
          &quot;neutral-content&quot;: &quot;#ccd1cc&quot;,
          &quot;base-100&quot;: &quot;#32253a&quot;,
          &quot;base-200&quot;: &quot;#2a1f31&quot;,
          &quot;base-300&quot;: &quot;#221928&quot;,
          &quot;base-content&quot;: &quot;#d2cfd4&quot;,
          &quot;info&quot;: &quot;#00a7c9&quot;,
          &quot;info-content&quot;: &quot;#000a0f&quot;,
          &quot;success&quot;: &quot;#67c400&quot;,
          &quot;success-content&quot;: &quot;#040e00&quot;,
          &quot;warning&quot;: &quot;#f97316&quot;,
          &quot;warning-content&quot;: &quot;#150500&quot;,
          &quot;error&quot;: &quot;#dc2626&quot;,
          &quot;error-content&quot;: &quot;#ffd9d4&quot;,
        &#125;
      &#125;
    ]
  &#125;
&#125;</code></pre>
<h2 id="33-配置-postcss"><a class="markdownIt-Anchor" href="#33-配置-postcss"></a> 3.3. 配置 PostCSS</h2>
<p>根据 <a target="_blank" rel="noopener" href="https://postcss.org/docs/">PostCSS 官方</a>说的：</p>
<blockquote>
<p>PostCSS 是一种利用 JS 插件转换样式的工具。</p>
<p>这些插件可以检查 CSS、支持变量和混合体、转译未来的 CSS 语法、内联图片等。</p>
</blockquote>
<p><code>postcss.config.js</code> 的初始配置如下：</p>
<pre><code class="language-js">export default &#123;
  plugins: &#123;
    tailwindcss: &#123;&#125;,
    autoprefixer: &#123;&#125;,
  &#125;,
&#125;;</code></pre>
<p>目前这是基本的配置。如果需要更多 PostCSS 功能，可以根据需求进一步配置。</p>
<h1 id="4-设置路由基础结构"><a class="markdownIt-Anchor" href="#4-设置路由基础结构"></a> 4. 设置路由基础结构</h1>
<p>路由系统是管理不同 URL 对应显示不同页面内容的机制。</p>
<h2 id="41-创建统一布局"><a class="markdownIt-Anchor" href="#41-创建统一布局"></a> 4.1. 创建统一布局</h2>
<p>作为开发者，在构建 Web 应用时，创建一个统一的布局非常重要。因为它能够为用户提供一致的界面的导航体验。</p>
<p>在大多数应用中，我们会有一些固定的部分，比方说导航栏、页脚，以及一个用于动态展示内容的区域。</p>
<pre><code class="language-tsx">import React from &#x27;react&#x27;;
import &#123; Outlet &#125; from &#x27;react-router-dom&#x27;;</code></pre>
<p>首先引入 <code>Outlet</code>，它是 <code>react-router-dom</code> 提供的一个工具，允许在布局中插入不同的内容。</p>
<p>通过 <code>Outlet</code>，我们可以渲染由路由定义的组件，也就是首页啦、关于页这些，也不需要每次都重写导航和布局。</p>
<pre><code class="language-tsx">const MainLayout = () =&gt; &#123;
  return (
    &lt;div&gt;
      &lt;header className=&quot;bg-primary shadow&quot;&gt;
        &lt;nav className=&quot;max-w-7xl mx-auto px-4 sm:px-6 lg:px-8&quot;&gt;
          &#123;/* TODO: 导航内容 */&#125;
        &lt;/nav&gt;
      &lt;/header&gt;</code></pre>
<p>用 <code>&lt;header&gt;</code> 标签来定义页面的头部，这里我之后会引入导航栏组件，先放个 <code>TODO</code> 马克一下。</p>
<pre><code class="language-tsx">      &lt;main&gt;
        &lt;div className=&quot;max-w-7xl mx-auto px-4 sm:px-6 lg:px-8&quot;&gt;
          &lt;Outlet /&gt;
        &lt;/div&gt;
      &lt;/main&gt;
    &lt;/div&gt;
  );
&#125;;</code></pre>
<p>接下来是 <code>&lt;main&gt;</code> 标签，它是页面的核心内容区域。</p>
<p><code>&lt;Outlet /&gt;</code> 会根据当前路由，动态渲染不同的组件。在开发中，这个设计的好处是我们可以轻松地切换页面，并保持一致的布局框架。</p>
<h2 id="42-路由配置"><a class="markdownIt-Anchor" href="#42-路由配置"></a> 4.2. 路由配置</h2>
<p>在单页面应用，也就是 SPA 中，路由是关键。它决定了用户访问某个路径时应该显示哪个组件。</p>
<p>我们现在需要一个机制，让用户能够在不同页面之间切换，比如从首页切换到用户账户信息页。路由能够帮助我们将 URL 和组件相互关联，确保用户在访问特定路径时，看到对应的页面。</p>
<pre><code class="language-tsx">import &#123; createBrowserRouter &#125; from &#x27;react-router-dom&#x27;;
import MainLayout from &#x27;./layouts/MainLayout&#x27;;</code></pre>
<p>首先导入 <code>createBrowserRouter</code>，用它可以创建一个支持浏览器历史记录的路由系统。接着我们将先前定义好的 <code>MainLayout</code> 引入作为根布局。</p>
<pre><code class="language-tsx">const router = createBrowserRouter([
  &#123;
    path: &#x27;/&#x27;,
    element: &lt;MainLayout /&gt;
  &#125;
]);</code></pre>
<p>这意味着，无论用户访问的子页面是什么，<code>MainLayout</code> 的结构都会保持一致，而页面主体部分会根据路由变化而动态加载。</p>
<h2 id="43-设置应用入口"><a class="markdownIt-Anchor" href="#43-设置应用入口"></a> 4.3. 设置应用入口</h2>
<p><code>App</code> 组件是整个应用的入口。它负责将路由系统注入到 React 的组件树中，这样其他组件才能知道根据不同的路径应该显示什么内容。</p>
<p>为了加载整个路由配置，我们需要一个统一的入口，因此需要用到 <code>RouterProvider</code>。它将之前配置的路由传递给应用，让各个子组件能够根据 URL 做出相应的渲染。</p>
<pre><code class="language-tsx">import &#123; RouterProvider &#125; from &#x27;react-router-dom&#x27;;
import router from &#x27;./router&#x27;;</code></pre>
<p>引入 <code>RouterProvider</code> 和先前定义好的 <code>router</code> 配置。</p>
<pre><code class="language-tsx">const App = () =&gt; &#123;
  return &lt;RouterProvider router=&#123;router&#125; /&gt;;
&#125;;</code></pre>
<p>用 <code>RouterProvider</code> 包裹住应用的根组件，并把 <code>router</code> 传递给它。通过这种方式，整个应用的路由系统就生效了。</p>
<p>虽然话是这么说，但因为内部什么组件都没写好，运行时还是什么都看不到的……</p>
<h1 id="5-配置状态管理工具"><a class="markdownIt-Anchor" href="#5-配置状态管理工具"></a> 5. 配置状态管理工具</h1>
<p>在开发中，状态管理是前端应用的核心部分之一，尤其是在涉及到用户登录、登出、数据持久化等功能时。</p>
<p>Zustand 是一个轻量级的状态管理库，它相比于 Redux 等传统工具更加简洁易用。因为是个练习项目，我便选择了这个更小巧的状态管理库。</p>
<h2 id="51-简单的例子"><a class="markdownIt-Anchor" href="#51-简单的例子"></a> 5.1. 简单的例子</h2>
<h4 id="511-初始化-zustand-状态管理器"><a class="markdownIt-Anchor" href="#511-初始化-zustand-状态管理器"></a> 5.1.1. 初始化 Zustand 状态管理器</h4>
<p>在 <code>src</code> 目录下创建一个 <code>stores</code> 目录，用于存放状态管理相关的文件。</p>
<p>在本例子中，代码结构分为三部分：状态定义和处理（<code>UserState</code>、<code>actions.ts</code>），Zustand 状态创建和持久化（<code>index.ts</code>），以及一些辅助函数（<code>api.ts</code>、<code>log.ts</code> 和 <code>selector.ts</code>）。</p>
<p>使用以下命令安装 Zustand：</p>
<pre><code class="language-bash">yarn add zustand</code></pre>
<p><code>stores</code> 目录下创建 <code>index.ts</code>，用作状态管理的入口，这样在应用的其他部分就可以方便地引入状态管理逻辑。</p>
<pre><code class="language-ts">import useUserStore from &#x27;./user&#x27;;</code></pre>
<p>作为一个大致的参考，我选择去写一个用户状态。这里先引入一下这个还未开始写的自定义钩子，理想情况下，它应当允许我们访问和操作与用户相关的状态。</p>
<p>在整个应用中，我们将通过这个钩子获取当前用户信息或调用登录操作。</p>
<h4 id="512-定义用户状态类型和接口"><a class="markdownIt-Anchor" href="#512-定义用户状态类型和接口"></a> 5.1.2. 定义用户状态类型和接口</h4>
<p><code>stores</code> 目录下创建 <code>user</code> 目录，接着又在 <code>user</code> 目录下创建 <code>types.ts</code>。</p>
<pre><code class="language-ts">export interface User &#123;
  id: string;
  name: string;
  email: string;
&#125;

export interface UserState &#123;
  user: User | null;
  isLoading: boolean;
  error: string | null;
&#125;</code></pre>
<ul>
<li>TypeScript 中的 <code>interface</code> 用于定义用户状态的结构。使用 <code>interface</code> 能更直观地展示用户状态中的各项属性，同时在项目扩展时易于维护</li>
</ul>
<p>这里定义了 <code>User</code> 和 <code>UserState</code>，这两个接口分别描述了用户对象的结构和与用户相关的状态。</p>
<blockquote>
<p>当然，作为一个参考，这些值后续一定会进行修改或者扩展。</p>
</blockquote>
<ul>
<li>
<p><code>User</code> 接口不用多说。<code>UserState</code> 接口包括了：</p>
<ul>
<li><code>user</code>：当前登录的用户信息；没有用户登录的话就是 <code>null</code></li>
<li><code>isLoading</code>：是否正在进行异步操作，比如登录请求</li>
<li><code>error</code>：当然是错误信息啦</li>
</ul>
</li>
<li>
<p><code>setUser</code> 是一个函数属性，接收一个 <code>User</code> 或者 <code>null</code> 类型的参数</p>
</li>
<li>
<p><code>login</code> 函数属性接收 <code>LoginCredentials</code> 参数，并返回一个 <code>Promise&lt;User&gt;</code>（使用 TypeScript 的时候这样写有助于检查函数的参数和返回值类型，减少类型错误）</p>
</li>
</ul>
<h4 id="513-创建-zustand-状态管理器"><a class="markdownIt-Anchor" href="#513-创建-zustand-状态管理器"></a> 5.1.3. 创建 Zustand 状态管理器</h4>
<p><code>user</code> 目录下创建 <code>index.ts</code>。</p>
<p>我们通过 Zustand 来创建一个用户状态管理器。</p>
<pre><code class="language-ts">import &#123; create &#125; from &#x27;zustand&#x27;;
import &#123; devtools, persist &#125; from &#x27;zustand/middleware&#x27;;
import &#123; UserState &#125; from &#x27;./types&#x27;;
import createUserSlice from &#x27;./actions&#x27;;

const useUserStore = create&lt;UserState&gt;()(
  devtools(
    persist(
      createUserSlice,
      &#123;
        name: &#x27;user-storage&#x27;
      &#125;
    )
  )
);

export default useUserStore;</code></pre>
<p>这里我们引入了 Zustand 的两个中间件：<code>devtools</code> 和 <code>persist</code>。</p>
<ul>
<li><code>devtools</code> 允许我们在开发时使用 Redux DevTools 进行状态调试，方便查看状态的变化</li>
<li><code>persist</code> 实现状态的持久化，将用户状态保存在 <code>localStorage</code> 中（先前使用 Redux 的时候，都是要手动使用 <code>localStorage</code> 进行持久性保存。Zustand 则可以直接使用 <code>persist</code> 中间件实现状态的持久化）。这样即使用户刷新页面，用户信息依然保留
<ul>
<li><code>name: 'user-storage'</code> 指定了持久化状态的存储键名</li>
</ul>
</li>
</ul>
<h4 id="514-定义用户状态的操作与异步行为"><a class="markdownIt-Anchor" href="#514-定义用户状态的操作与异步行为"></a> 5.1.4. 定义用户状态的操作与异步行为</h4>
<p><code>user</code> 目录下创建 <code>actions.ts</code>，定义状态和异步操作。</p>
<pre><code class="language-ts">import &#123; StateCreator &#125; from &#x27;zustand&#x27;;
import &#123; User, UserState &#125; from &#x27;./types&#x27;;

const createUserSlice: StateCreator&lt;UserState&gt; = (set) =&gt; (&#123;
  user: null,
  isLoading: false,
  error: null,

  setUser: (user: User | null) =&gt; set(&#123; user &#125;),

  login: async (credentials: &#123; email: string; password: string &#125;) =&gt; &#123;
    set(&#123; isLoading: true, error: null &#125;);
    try &#123;
      // TODO: 调用API
      set(&#123; isLoading: false, user: response.data &#125;);
    &#125; catch (error) &#123;
      set(&#123; isLoading: false, error: error.message &#125;);
    &#125;
  &#125;
&#125;);

export default createUserSlice;</code></pre>
<p>在这个文件中，我们定义了用户状态的操作逻辑和异步操作。</p>
<p>对于大多数应用来说，登录是一个异步过程，我们需要在发起请求时更新 <code>isLoading</code> 状态，同时在请求失败时记录错误信息。</p>
<ol>
<li>
<p>初始状态，也就是用户未登录时，<code>user</code> 设为 <code>null</code>、<code>isLoading</code> 为 <code>false</code>，<code>error</code> 也为空。</p>
</li>
<li>
<p><code>setUser</code> 是一个简单的同步方法，用于手动设置用户信息。</p>
</li>
<li>
<p><code>login</code> 是一个异步函数，用于处理登录逻辑。</p>
<p>开发中，典型的流程是：</p>
<ol>
<li>设置 <code>isLoading</code> 为 <code>true</code>，以便显示加载状态</li>
<li>发起登录请求（因为还没写，就用 <code>TODO</code> 标记了。注意哈，现在这个时候跑指定报错）</li>
<li>请求成功后，将返回的用户信息存储到状态中，并重置 <code>isLoading</code> 为 <code>false</code></li>
<li>如果请求失败，捕获错误，并更新 <code>error</code> 状态，用户可看到错误提示（现在当然不行）</li>
</ol>
</li>
</ol>
<h2 id="52-进阶配置"><a class="markdownIt-Anchor" href="#52-进阶配置"></a> 5.2. 进阶配置</h2>
<p>我们已经配置了 Zustand 的基本用户状态管理。接下来，我们将借助 TypeScript，进一步优化和扩展状态管理的功能，包括状态持久化、自定义中间件和选择器等。</p>
<h4 id="521-状态持久化与部分存储"><a class="markdownIt-Anchor" href="#521-状态持久化与部分存储"></a> 5.2.1. 状态持久化与部分存储</h4>
<p>在生产环境中，为了提升用户体验，状态持久化是一个常见需求。Zustand 提供了 <code>persist</code> 中间件，帮助我们将部分状态保存在 <code>localStorage</code> 或其他存储中，以确保页面刷新后状态不会丢失。</p>
<p>在 <code>stores/user/index.ts</code> 中，我们定义了 <code>persistOptions</code>，并在其中使用了 <code>partialize</code> 功能，将状态中关键的部分（如用户信息和更新时间）持久化：</p>
<pre><code class="language-ts">import &#123; create &#125; from &#x27;zustand&#x27;;
import &#123; devtools, persist, subscribeWithSelector &#125; from &#x27;zustand/middleware&#x27;;
import type &#123; PersistOptions &#125; from &#x27;zustand/middleware&#x27;;
import &#123; UserState &#125; from &#x27;./types&#x27;;
import createUserSlice from &#x27;./actions&#x27;;
import &#123; log &#125; from &#x27;../common/log&#x27;;
import &#123; createSelectors &#125; from &#x27;../common/selector&#x27;;

type UserPersist = Pick&lt;UserState, &#x27;user&#x27; | &#x27;lastUpdated&#x27;&gt;;

const persistOptions: PersistOptions&lt;UserState, UserPersist&gt; = &#123;
  name: &#x27;user-storage&#x27;,
  partialize: (state) =&gt; (&#123;
    user: state.user,
    lastUpdated: state.lastUpdated,
  &#125;),
&#125;;</code></pre>
<ul>
<li><code>Pick&lt;UserState, 'user' | 'lastUpdated'&gt;</code>：使用 <code>Pick</code> 类型将 <code>UserState</code> 中的 <code>user</code> 和 <code>lastUpdated</code> 属性挑选出来，简化了持久化的内容</li>
<li><code>PersistOptions</code> 类型：类型声明让我们清楚地知道哪些状态会被持久化，避免错误持久化不必要的数据
<ul>
<li><code>partialize</code> 是一个用于选择性地存储状态对象中部分属性的函数。在我们的 <code>persistOptions</code> 里，它的作用是从 <code>UserState</code> 状态中挑出 <code>user</code> 和 <code>lastUpdated</code> 这两个属性，并将其存储到持久化的存储中</li>
</ul>
</li>
</ul>
<h4 id="522-订阅特定的状态"><a class="markdownIt-Anchor" href="#522-订阅特定的状态"></a> 5.2.2. 订阅特定的状态</h4>
<p><code>subscribeWithSelector</code> 允许我们订阅特定的状态属性变化。与直接订阅整个状态的变化不同，它可以细化到仅在某些具体属性更新时触发回调，从而减少不必要的订阅响应。</p>
<p>继续写 <code>stores/user/index.ts</code>：</p>
<pre><code class="language-ts">const useUserStoreBase = create&lt;UserState&gt;()(
  devtools(
    persist(
      subscribeWithSelector(
        log(createUserSlice),
      ),
      persistOptions,
    )
  )
);</code></pre>
<p>通过组合其他的 Zustand 插件，我们创建了一个订阅机制。这样做的好处是提高性能、避免不必要的渲染。</p>
<p>接下来这段代码订阅了 <code>useUserStoreBase</code> 中的 <code>user</code> 属性：</p>
<pre><code class="language-ts">useUserStoreBase.subscribe(
  (state) =&gt; state.user,
  (user) =&gt; &#123;
    if (user) &#123;
      console.log(&#x27;User logged in: &#x27;, user.name);
    &#125; else &#123;
      console.log(&#x27;User logged out&#x27;);
    &#125;
  &#125;
)

export const useUserStore = createSelectors(useUserStoreBase);</code></pre>
<ul>
<li><code>(state) =&gt; state.user</code> 是一个选择器函数，只返回 <code>state</code> 中的 <code>user</code> 属性，从而使订阅仅响应 <code>user</code> 的变化</li>
<li>当 <code>user</code> 属性变化时，回调触发。回调会根据 <code>user</code> 是否存在（如 <code>user</code> 为 <code>null</code>，或者用户登陆了新的信息）来输出不同的登录状态信息</li>
</ul>
<h4 id="523-自定义日志中间件"><a class="markdownIt-Anchor" href="#523-自定义日志中间件"></a> 5.2.3. 自定义日志中间件</h4>
<p>为了方便调试，我们可以创建一个日志中间件。这个中间件会在每次状态更新时，记录状态变化信息。</p>
<p>在 <code>stores/common/log.ts</code> 中定义 <code>log</code> 函数，扩展 Zustand 的 <code>set</code> 方法，使其在应用状态变化时输出变更详情。</p>
<p>先写一个泛型类型，用于定义 <code>set</code> 函数所接收的各种更新方式：</p>
<pre><code class="language-ts">import &#123; StateCreator &#125; from &#x27;zustand&#x27;;

type SetStateAction&lt;T&gt; = T | Partial&lt;T&gt; | ((state: T) =&gt; T | Partial&lt;T&gt;);</code></pre>
<ul>
<li><code>SetStateAction&lt;T&gt;</code> 的作用是确保状态的更新类型符合期望，允许直接提供新的状态值、部分更新或基于当前状态的更新函数
<ul>
<li><code>T</code>：泛型参数，表示整个状态对象的类型，例如 <code>UserState</code></li>
<li>类型定义：
<ul>
<li><code>T</code>：可以直接传入整个状态对象，用于完全替换现有状态</li>
<li><code>Partial&lt;T&gt;</code>：可以传入部分状态对象，即只更新部分属性。<code>Partial&lt;T&gt;</code> 将状态对象的所有属性变为可选</li>
<li><code>(state: T) =&gt; T | Partial&lt;T&gt;</code>：可以传入一个函数，这个函数接收当前状态作为参数，并返回新的状态或部分状态。这种方式允许在回调中基于现有状态动态生成更新值</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这样写的目的是为了更灵活的状态更新方式，不仅可以直接替换状态，也可以部分更新或在回调函数中动态更新。</p>
<pre><code class="language-ts">export const log = &lt;T extends object&gt;(
  config: StateCreator&lt;T, [], [], T&gt;
): StateCreator&lt;T, [], [], T&gt; =&gt;
  (set, get, api) =&gt; config(
    (partial: SetStateAction&lt;T&gt;, replace?: boolean) =&gt; &#123;
      console.log(&#x27;Applying&#x27;, &#123; partial, replace &#125;);
      if (replace) &#123;
        set(partial as T | ((state: T) =&gt; T), true);
      &#125; else &#123;
        set(partial as SetStateAction&lt;T&gt;);
      &#125;
      console.log(&#x27;New state: &#x27;, get());
    &#125;,
    get,
    api
  );</code></pre>
<p><code>log</code> 是一个高阶函数（也就是 HOC），接受一个 Zustand 的 <code>StateCreator</code> 配置函数，并返回一个经过增强的 <code>StateCreator</code>，用于记录状态的变化。</p>
<p><code>log</code> 的作用是对传入的 <code>config</code> 配置函数进行包装，以便在状态更新时打印更新的内容和更新后的状态，用于调试。</p>
<ul>
<li>
<p><code>log</code> 的内部逻辑：</p>
<ol>
<li>
<p>参数：</p>
<ul>
<li><code>config</code>：一个 Zustand 的 <code>StateCreator</code> 函数，负责创建状态。此函数会调用 <code>set</code> 函数来更新状态</li>
</ul>
</li>
<li>
<p>返回值：一个增强的 <code>StateCreator</code> 函数，用于替代原始 <code>config</code> 函数</p>
</li>
<li>
<p>内部逻辑：</p>
<ul>
<li>
<p>包装 <code>set</code> 函数：调用 <code>config</code> 时，将自定义的 <code>set</code> 函数传入</p>
<ul>
<li>
<p>自定义的 <code>set</code> 函数接收 <code>partial</code> 和 <code>replace</code> 两个参数：</p>
<ul>
<li><code>partial</code>：可以是新的状态值、部分状态值，也可以是一个返回状态的函数</li>
<li><code>replace</code>：布尔值，表示是否完全替换现有状态</li>
</ul>
</li>
<li>
<p>日志输出：</p>
<ul>
<li><code>console.log('Applying', &#123; partial, replace &#125;)</code> 在更新前输出即将应用的部分状态或新状态</li>
<li><code>console.log('New state: ', get())</code> 在更新后输出新的</li>
</ul>
</li>
</ul>
</li>
<li>
<p>更新逻辑：</p>
<ol>
<li>若 <code>replace</code> 为 <code>true</code>，则完全替换当前状态；否则只应用部分更新</li>
<li>调用 <code>get</code> 获取新的状态并打印日志</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="524-状态选择器"><a class="markdownIt-Anchor" href="#524-状态选择器"></a> 5.2.4. 状态选择器</h4>
<p>在状态管理中，我们通常需要对状态进行选择，以便在不同组件中访问特定的状态字段。</p>
<p><code>createSelectors</code> 帮助我们自动生成访问器，减少在不同组件中冗余的状态逻辑。</p>
<p><code>stores/common/selector.ts</code> 中定义 <code>createSelectors</code>，它会为状态中的每个字段创建一个 <code>getter</code> 函数，便于状态的解耦：</p>
<pre><code class="language-ts">import &#123; StoreApi, UseBoundStore &#125; from &#x27;zustand&#x27;;

type WithSelectors&lt;S&gt; = S extends &#123; getState: () =&gt; infer T &#125;
  ? S &amp; &#123; use: &#123; [K in keyof T]: () =&gt; T[K] &#125; &#125;
  : never;</code></pre>
<ul>
<li><code>WithSelectors&lt;S&gt;</code> 定义了一个条件类型，用于增强传入的 <code>store</code> 类型 <code>S</code>
<ul>
<li><code>S extends &#123; getState: () =&gt; infer T &#125;</code> 检查 <code>S</code> 是否包含 <code>getState</code> 方法，并从中推断出 <code>T</code> 类型（状态对象的类型）</li>
<li>返回：
<ul>
<li>若 <code>S</code> 满足条件，则返回 <code>S</code> 并附加一个 <code>use</code> 属性
<ul>
<li><code>use</code> 是一个对象，包含状态对象中每个键对应的 <code>getter</code> 方法，这些方法返回 <code>T[K]</code>，即每个状态属性的值</li>
</ul>
</li>
<li>若 <code>S</code> 不满足条件，则返回 <code>never</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-ts">export const createSelectors = &lt;
  S extends UseBoundStore&lt;StoreApi&lt;T&gt;&gt;,
  T extends object
&gt;(_store: S) =&gt; &#123;
  const store = _store as WithSelectors&lt;S&gt;;
  store.use = &#123;&#125; as &#123; [K in keyof T]: () =&gt; T[K] &#125;;
  const state = store.getState();

  for (const k of Object.keys(state) as Array&lt;keyof T&gt;) &#123;
    store.use[k] = () =&gt; state[k];
  &#125;

  return store;
&#125;</code></pre>
<p><code>createSelectors</code> 函数：</p>
<ul>
<li>参数：接收一个 Zustand store 实例 <code>_store</code></li>
<li>类型约束：
<ul>
<li><code>S extends UseBoundStore&lt;StoreApi&lt;T&gt;&gt;</code>：约束 <code>S</code> 必须是一个 <code>UseBoundStore</code> 类型的 store</li>
<li><code>T extends object</code>：状态对象 <code>T</code> 必须是一个对象</li>
</ul>
</li>
<li>逻辑：
<ol>
<li>将传入的 store <code>_store</code> 进行类型转换，以便使用 <code>WithSelectors</code> 增强后的类型</li>
<li>为 <code>store</code> 增加 <code>use</code> 属性（一个空对象），作为存放每个状态属性 <code>getter</code> 方法的容器</li>
<li>获取当前 store 的 <code>state</code> 对象</li>
<li><code>for</code> 循环遍历 <code>state</code> 对象的键（即状态对象的属性）
<ul>
<li>对每个键 <code>k</code>，在 <code>store.use</code> 中创建一个对应的 <code>getter</code> 方法 <code>store.use[k]</code>，返回 <code>state[k]</code> 的值</li>
</ul>
</li>
<li>返回增强后的 store 实例 <code>store</code>，其中包含 <code>use</code> 对象和对应的 <code>getter</code> 方法</li>
</ol>
</li>
</ul>
<p>假设 store 的状态对象如下：</p>
<pre><code class="language-ts">const useStore = createSelectors(
  create((set) =&gt; (&#123;
    user: &#123; name: &quot;Alice&quot;, age: 30 &#125;,
    loggedIn: true
  &#125;))
);</code></pre>
<p>那么调用 <code>useStore.use.user()</code> 就会返回：</p>
<pre><code class="language-plaintext">&#123; name: &quot;Alice&quot;, age: 30 &#125;</code></pre>
<h4 id="525-api-请求的配置和错误处理"><a class="markdownIt-Anchor" href="#525-api-请求的配置和错误处理"></a> 5.2.5. API 请求的配置和错误处理</h4>
<p>在前端状态管理中，一般会包含 API 请求的逻辑。</p>
<p>我们在 <code>stores/user/actions</code> 中，定义一个 <code>createUserSlice</code> 函数，它是 Zustand 中 <code>UserState</code> 的部分实现，用于管理用户相关的状态和操作。</p>
<p>首先导入依赖：</p>
<pre><code class="language-ts">import &#123; StateCreator &#125; from &#x27;zustand&#x27;;
import &#123; AxiosResponse &#125; from &#x27;axios&#x27;;
import &#123; User, UserState, LoginCredentials &#125; from &#x27;./types&#x27;;
import api from &#x27;../common/api&#x27;;</code></pre>
<p>定义状态和操作：</p>
<pre><code class="language-ts">const createUserSlice: StateCreator&lt;UserState&gt; = (set) =&gt; (&#123;
  user: null,
  isLoading: false,
  error: null,
  lastUpdated: null,

  // ...</code></pre>
<ul>
<li><code>user</code>：存储当前用户信息</li>
<li><code>isLoading</code>：指示登录操作是否正在进行中</li>
<li><code>error</code>：保存登录过程中发生的错误信息</li>
<li><code>lastUpdated</code>：记录上次用户数据更新的时间戳</li>
</ul>
<pre><code class="language-ts">// ...
setUser: (user: User | null) =&gt; set(&#123; user &#125;),
// ...</code></pre>
<ul>
<li><code>setUser</code>：一个同步方法，用于直接设置 <code>user</code> 状态。接收一个 <code>User</code> 对象或者 <code>null</code>，并调用 <code>set</code> 更新状态</li>
</ul>
<pre><code class="language-ts">// ...
login: async (credentials: LoginCredentials) =&gt; &#123;
  set(&#123; isLoading: true, error: null &#125;);
  try &#123;
    const response: AxiosResponse&lt;User&gt; = await api.post&lt;User&gt;(&#x27;/auth/login&#x27;, credentials);
    const user = response.data;

    set(&#123;
      user,
      isLoading: false,
      lastUpdated: Date.now(),
      error: null
    &#125;);

    return user;
  &#125; catch (error) &#123;
    const errorMessage = error instanceof Error
      ? error.message
      : &#x27;An unexpected error occurred during login&#x27;;

    set(&#123;
      isLoading: false,
      error: errorMessage,
      user: null
    &#125;);

    throw error;
  &#125;
&#125;,
// ...</code></pre>
<p><code>login</code> 方法：</p>
<ul>
<li>启动加载状态：调用 <code>set(&#123; isLoading: true, error: null &#125;)</code> 将 <code>isLoading</code> 设置为 <code>true</code>，并清除之前的错误</li>
<li>API 请求：<code>await api.post&lt;User&gt;('/auth/login', credentials)</code> 向服务器发送登录请求。返回的 <code>response.data</code> 包含了用户信息</li>
<li>成功处理：
<ol>
<li>若请求成功，<code>set</code> 更新状态，存储用户数据、停止加载、设置 <code>lastUpdated</code> 时间戳，并清除错误</li>
<li>返回 <code>user</code>，便于在调用 <code>login</code> 的地方使用</li>
</ol>
</li>
<li>错误处理：
<ol>
<li>如果请求失败，捕获 <code>error</code> 并生成错误消息</li>
<li>更新 <code>set</code> 将 <code>isLoading</code> 设置为 <code>false</code>，保存 <code>error</code> 信息，并将 <code>user</code> 设置为 <code>null</code></li>
<li>抛出错误，以便调用 <code>login</code> 的组件也能捕获并处理该错误</li>
</ol>
</li>
</ul>
<pre><code class="language-ts">  // ...
  logout: () =&gt; &#123;
    set(&#123;
      user: null,
      error: null,
      lastUpdated: null
    &#125;);
  &#125;
&#125;);

export default createUserSlice;</code></pre>
<p><code>logout</code> 方法是登出功能，说白了就是将所有的状态设置为 <code>null</code>，从而达到清除当前用户信息和错误的效果。</p>
<h1 id="6-设置-api-请求封装"><a class="markdownIt-Anchor" href="#6-设置-api-请求封装"></a> 6. 设置 API 请求封装</h1>
<p>至于 API 嘛，写在了 <code>stores/common/api.ts</code> 中：</p>
<pre><code class="language-ts">import axios from &#x27;axios&#x27;;

const api = axios.create(&#123;
  baseURL: process.env.REACT_APP_API_URL,
  timeout: 10000
&#125;);</code></pre>
<p><code>axios</code> 配置了一个 API 实例 <code>api</code>，设置了基本的请求和响应拦截器。</p>
<ul>
<li><code>baseURL</code> 为环境变量 <code>REACT_APP_API_URL</code>，还设置了 10 秒的超时时间</li>
</ul>
<pre><code class="language-ts">api.interceptors.request.use(
  (config) =&gt; &#123;
    // TODO: 添加认证信息
    return config;
  &#125;,
  (error) =&gt; Promise.reject(error)
);</code></pre>
<ol>
<li>
<p>请求拦截器 <code>api.interceptors.request.use</code> 提供了请求发送前的自定义逻辑处理。可以在 <code>config</code> 中添加认证信息（也就是老生常谈的 JWT <code>Authorization</code> 头）。</p>
</li>
<li>
<p>如果请求在发送前就失败了，那么拦截器将直接拒绝该错误</p>
</li>
</ol>
<pre><code class="language-ts">api.interceptors.response.use(
  (response) =&gt; response,
  (error) =&gt; &#123;
    // TODO: 统一错误信息
    return Promise.reject(error);
  &#125;
);

export default api;</code></pre>
<p>响应拦截器 <code>api.interceptors.response.use</code> 允许在接收到响应时进行自定义处理。</p>
<ol>
<li>响应成功会直接返回数据</li>
<li>请求出错，<code>error</code> 就会被统一处理，然后传递给调用方处理</li>
</ol>
<p>有很多功能先放 <code>TODO</code> 了，能差不多 GET 到意思就好。</p>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="8e94.html">上一篇</a><a class="next" href="8386.html">下一篇</a></div><div class="copyright"><p>© 2022 - 2025 <a href="https://cytrogen.icu">Cytrogen</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/cytrogen/hexo-theme-ares" target="_blank">hexo-theme-ares</a>.</p></div></footer></div></div><a class="back-to-top" href="#top" aria-label="返回顶部"><svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path d="M3.293 9.707a1 1 0 010-1.414L9.586 2a2 2 0 012.828 0l6.293 6.293a1 1 0 01-1.414 1.414L11 3.414V17a1 1 0 11-2 0V3.414L2.707 9.707a1 1 0 01-1.414 0z"></path></svg></a><script>document.addEventListener('DOMContentLoaded', function() {
  const codeBlocks = document.querySelectorAll('figure.highlight');
  
  codeBlocks.forEach(block => {
    let caption = block.querySelector('figcaption');
    if (!caption) {
      caption = document.createElement('figcaption');
      block.insertBefore(caption, block.firstChild);
    }

    const info = document.createElement('div');
    info.className = 'info';
    
    const filename = caption.querySelector('span');
    if (filename) {
      filename.className = 'filename';
      info.appendChild(filename);
    }
    
    const lang = block.className.split(' ')[1];
    if (lang) {
      const langSpan = document.createElement('span');
      langSpan.className = 'lang-name';
      langSpan.textContent = lang;
      info.appendChild(langSpan);
    }

    const sourceLink = caption.querySelector('a');
    if (sourceLink) {
      sourceLink.className = 'source-link';
      info.appendChild(sourceLink);
    }

    const actions = document.createElement('div');
    actions.className = 'actions';

    const codeHeight = block.scrollHeight;
    const threshold = 300;

    if (codeHeight > threshold) {
      block.classList.add('folded');
      
      const toggleBtn = document.createElement('button');
      toggleBtn.textContent = '展开';
      toggleBtn.addEventListener('click', () => {
        block.classList.toggle('folded');
        toggleBtn.textContent = block.classList.contains('folded') ? '展开' : '折叠';
      });
      actions.appendChild(toggleBtn);
    }

    const copyBtn = document.createElement('button');
    copyBtn.textContent = '复制';
    copyBtn.addEventListener('click', async () => {
      const codeLines = block.querySelectorAll('.code .line');
      const code = Array.from(codeLines)
        .map(line => line.textContent)
        .join('\n')
        .replace(/\n\n/g, '\n');
      
      try {
        await navigator.clipboard.writeText(code);
        copyBtn.textContent = '已复制';
        copyBtn.classList.add('copied');
        
        setTimeout(() => {
          copyBtn.textContent = '复制';
          copyBtn.classList.remove('copied');
        }, 3000);
      } catch (err) {
        console.error('复制失败:', err);
        copyBtn.textContent = '复制失败';
        
        setTimeout(() => {
          copyBtn.textContent = '复制';
        }, 3000);
      }
    });
    actions.appendChild(copyBtn);

    caption.innerHTML = '';
    caption.appendChild(info);
    caption.appendChild(actions);

    const markedLines = block.getAttribute('data-marked-lines');
    if (markedLines) {
      const lines = markedLines.split(',');
      lines.forEach(range => {
        if (range.includes('-')) {
          const [start, end] = range.split('-').map(Number);
          for (let i = start; i <= end; i++) {
            const line = block.querySelector(`.line-${i}`);
            if (line) line.classList.add('marked');
          }
        } else {
          const line = block.querySelector(`.line-${range}`);
          if (line) line.classList.add('marked');
        }
      });
    }
  });
});</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=G-4PVPZXE0QQ"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-4PVPZXE0QQ');</script><script>(function() {
  // Wait for DOM to be ready
  document.addEventListener('DOMContentLoaded', function() {
    const themeToggle = document.querySelector('.theme-toggle');
    
    if (!themeToggle) return;
    
    // Get current theme
    const getCurrentTheme = () => {
      return document.documentElement.getAttribute('data-theme') || 'light';
    };
    
    // Update UI to match current theme
    const updateUI = (theme) => {
      const isDark = theme === 'dark';
      themeToggle.setAttribute('aria-pressed', isDark.toString());
    };
    
    // Simplified theme setter - CSS handles all animations
    const setTheme = (theme) => {
      document.documentElement.setAttribute('data-theme', theme);
      document.documentElement.style.colorScheme = theme; // Update native UI elements
      
      // Also update page-wrapper for animation support
      const pageWrapper = document.getElementById('page-wrapper');
      if (pageWrapper) {
        pageWrapper.setAttribute('data-theme', theme);
      }
      
      // Find and remove the temporary anti-flicker style tag if it exists.
      // This ensures the main stylesheet takes full control after the initial load.
      const antiFlickerStyle = document.getElementById('anti-flicker-style');
      if (antiFlickerStyle) {
        antiFlickerStyle.remove();
      }
      
      localStorage.setItem('theme', theme);
      updateUI(theme);
    };
    
    // Simple theme toggle - letting CSS handle the smooth transitions
    const toggleTheme = () => {
      const current = getCurrentTheme();
      const newTheme = current === 'light' ? 'dark' : 'light';
      setTheme(newTheme);
    };
    
    // Initialize UI on page load
    updateUI(getCurrentTheme());
    
    // Add click event listener
    themeToggle.addEventListener('click', toggleTheme);
    
    // Listen for system theme changes
    if (window.matchMedia) {
      const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
      mediaQuery.addEventListener('change', function(e) {
        // Only update if no manual preference is saved
        if (!localStorage.getItem('theme')) {
          const theme = e.matches ? 'dark' : 'light';
          setTheme(theme);
        }
      });
    }
  });
})();
</script><script>(function() {
  document.addEventListener('DOMContentLoaded', function() {
    const backToTopBtn = document.querySelector('.back-to-top');
    
    if (!backToTopBtn) return;
    
    // Show/hide button based on scroll position
    const toggleButtonVisibility = () => {
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      const shouldShow = scrollTop > 200; // Show after scrolling 200px
      
      if (shouldShow) {
        backToTopBtn.classList.add('is-visible');
      } else {
        backToTopBtn.classList.remove('is-visible');
      }
    };
    
    // Throttle scroll events for better performance
    let ticking = false;
    const handleScroll = () => {
      if (!ticking) {
        requestAnimationFrame(() => {
          toggleButtonVisibility();
          ticking = false;
        });
        ticking = true;
      }
    };
    
    // Smooth scroll to top when clicked
    const scrollToTop = (event) => {
      event.preventDefault();
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    };
    
    // Add event listeners
    window.addEventListener('scroll', handleScroll);
    backToTopBtn.addEventListener('click', scrollToTop);
    
    // Check initial scroll position
    toggleButtonVisibility();
  });
})();</script></body></html>