<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Hexo源代码分析【1】：入口文件 · Cytrogen 的个人博客</title><meta name="description" content="本文深入分析了 Hexo 7.2.0 的源代码，从入口文件 dist/hexo/index.js 入手，详细剖析了核心 Hexo 类的构造函数、属性和关键方法。文章逐一解读了路径管理、配置加载、渲染、路由、插件机制、数据模型等核心模块的实现原理，帮助你理解 Hexo 的底层工作机制，为深度定制或插件开发打下坚实基础。"><link rel="icon" href="../favicon.png"><link rel="preload" href="../fonts/opensans-regular-latin.woff2" as="font" type="font/woff2" crossorigin="anonymous"><style>@font-face {
  font-family: 'Open Sans';
  src: url('../fonts/opensans-regular-latin.woff2') format('woff2');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
  size-adjust: 107%;
  ascent-override: 97%;
  descent-override: 25%;
  line-gap-override: 0%;
}
</style><link rel="stylesheet" href="../css/ares.css"><script>(function() {
  const getInitialTheme = () => {
    const saved = localStorage.getItem('theme');
    if (saved && (saved === 'light' || saved === 'dark')) {
      return saved;
    }
    
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      return 'dark';
    }
    
    return 'light';
  };
  
  const theme = getInitialTheme();
  document.documentElement.setAttribute('data-theme', theme);
  
  document.documentElement.style.colorScheme = theme;
  
  // Add anti-flicker style for dark mode
  if (theme === 'dark') {
    const style = document.createElement('style');
    style.id = 'anti-flicker-style';
    style.innerHTML = `
      #page-wrapper[data-theme="dark"] {
        background-color: #0f172a;
        color: #f1f5f9;
      }
    `;
    document.head.appendChild(style);
  }
  
  document.addEventListener('DOMContentLoaded', function() {
    const pageWrapper = document.getElementById('page-wrapper');
    if (pageWrapper) {
      pageWrapper.setAttribute('data-theme', theme);
    }
  });
})();

</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="atom.xml" title="Cytrogen 的个人博客" type="application/atom+xml">
</head><body><div id="page-wrapper"><a class="skip-link" href="#main-content">跳到主要内容</a><div class="wrap"><header><a class="logo-link" href="../index.html"><img src="../favicon.png" alt="logo"></a><nav class="site-nav"><div class="nav-main"><div class="nav-primary"><ul class="nav-list hidden-mobile"><li class="nav-item"><a class="nav-link" href="../index.html">首页</a></li></ul><div class="nav-tools"><div class="language-menu"><button class="language-toggle" type="button"><svg class="icon icon-globe" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true" focusable="false"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8zm7.5-6.923c-.67.204-1.335.82-1.887 1.855A7.97 7.97 0 0 0 5.145 4H7.5V1.077zM4.09 4a9.267 9.267 0 0 1 .64-1.539 6.7 6.7 0 0 1 .597-.933A7.025 7.025 0 0 0 2.255 4H4.09zm-.582 3.5c.03-.877.138-1.718.312-2.5H1.674a6.958 6.958 0 0 0-.656 2.5h2.49zM4.847 5a12.5 12.5 0 0 0-.338 2.5H7.5V5H4.847zM8.5 5v2.5h2.99a12.495 12.495 0 0 0-.337-2.5H8.5zM4.51 8.5a12.5 12.5 0 0 0 .337 2.5H7.5V8.5H4.51zm3.99 0V11h2.653c.187-.765.306-1.608.338-2.5H8.5zM5.145 12c.138.386.295.744.468 1.068.552 1.035 1.218 1.65 1.887 1.855V12H5.145zm.182 2.472a6.696 6.696 0 0 1-.597-.933A9.268 9.268 0 0 1 4.09 12H2.255a7.024 7.024 0 0 0 3.072 2.472zM3.82 11a13.652 13.652 0 0 1-.312-2.5h-2.49c.062.89.291 1.733.656 2.5H3.82zm6.853 3.472A7.024 7.024 0 0 0 13.745 12H11.91a9.27 9.27 0 0 1-.64 1.539 6.688 6.688 0 0 1-.597.933zM8.5 12v2.923c.67-.204 1.335-.82 1.887-1.855A7.97 7.97 0 0 0 10.855 12H8.5zm3.68-1h2.146c.365-.767.594-1.61.656-2.5h-2.49a13.65 13.65 0 0 1-.312 2.5zm2.802-3.5a6.959 6.959 0 0 0-.656-2.5H12.18c.174.782.282 1.623.312 2.5h2.49zM11.27 2.461c.247.464.462.98.64 1.539h1.835a7.024 7.024 0 0 0-3.072-2.472c.218.284.418.598.597.933zM10.855 4a7.966 7.966 0 0 0-.468-1.068C9.835 1.897 9.17 1.282 8.5 1.077V4h2.355z"></path></svg><span>中文</span></button><div class="language-dropdown"></div></div></div><div class="nav-controls"><div class="more-menu hidden-mobile"><button class="more-toggle" type="button"><span>更多</span><svg class="icon icon-chevron-down" width="12" height="12" viewBox="0 0 12 12" fill="currentColor" aria-hidden="true" focusable="false"><path d="M6 8.825c-.2 0-.4-.1-.5-.2l-3.3-3.3c-.3-.3-.3-.8 0-1.1s.8-.3 1.1 0l2.7 2.7 2.7-2.7c.3-.3.8-.3 1.1 0s.3.8 0 1.1l-3.3 3.3c-.1.1-.3.2-.5.2z"></path></svg></button><div class="more-dropdown"><ul class="dropdown-list"><li class="dropdown-item"><a class="nav-link" href="../archives">归档</a></li><li class="dropdown-item"><a class="nav-link" href="../categories">分类</a></li><li class="dropdown-item"><a class="nav-link" href="../tags">标签</a></li><li class="dropdown-item"><a class="nav-link" href="../about">关于</a></li><li class="dropdown-item"><a class="nav-link" href="../friends">友链</a></li><li class="dropdown-item"><a class="nav-link" href="../atom.xml">RSS订阅</a></li><li class="dropdown-item"><a class="dropdown-link" href="https://portfolio.cytrogen.icu" target="_blank" rel="noopener noreferrer">作品集<svg class="icon icon-external-link" width="14" height="14" viewBox="0 0 14 14" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8.636 2.364A1 1 0 0 1 10 1h3a1 1 0 0 1 1 1v3a1 1 0 0 1-2 0V3.414l-4.293 4.293a1 1 0 0 1-1.414-1.414L10.586 2H9a1 1 0 0 1-1.364-1.636zM2 3a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V9a1 1 0 1 1 2 0v3a3 3 0 0 1-3 3H2a3 3 0 0 1-3-3V4a3 3 0 0 1 3-3h3a1 1 0 1 1 0 2H2z"></path></svg></a></li><li class="dropdown-item"><a class="dropdown-link" href="https://github.com/cytrogen" target="_blank" rel="noopener noreferrer">GitHub<svg class="icon icon-external-link" width="14" height="14" viewBox="0 0 14 14" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8.636 2.364A1 1 0 0 1 10 1h3a1 1 0 0 1 1 1v3a1 1 0 0 1-2 0V3.414l-4.293 4.293a1 1 0 0 1-1.414-1.414L10.586 2H9a1 1 0 0 1-1.364-1.636zM2 3a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V9a1 1 0 1 1 2 0v3a3 3 0 0 1-3 3H2a3 3 0 0 1-3-3V4a3 3 0 0 1 3-3h3a1 1 0 1 1 0 2H2z"></path></svg></a></li></ul></div></div><div class="theme-switcher"><button class="theme-toggle" type="button" role="switch" aria-pressed="false" aria-label="切换主题"><div class="theme-icon moon-icon"><svg class="icon icon-moon" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true" focusable="false"><path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"></path></svg></div><div class="theme-icon sun-icon"><svg class="icon icon-sun" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0 1a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"></path></svg></div></button></div><details class="mobile-menu-details hidden-desktop"><summary class="hamburger-menu" aria-label="nav.menu"><svg class="icon icon-bars" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true" focusable="false"><path d="M2.5 12a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5z"></path></svg><span class="menu-text">nav.menu</span></summary><div class="mobile-menu-dropdown"><ul class="mobile-nav-list"><li class="mobile-nav-item"><a class="mobile-nav-link" href="../index.html">首页</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../archives">归档</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../categories">分类</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../tags">标签</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../about">关于</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../friends">友链</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../atom.xml">RSS订阅</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="https://portfolio.cytrogen.icu" target="_blank" rel="noopener noreferrer">作品集<svg class="icon icon-external-link" width="14" height="14" viewBox="0 0 14 14" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8.636 2.364A1 1 0 0 1 10 1h3a1 1 0 0 1 1 1v3a1 1 0 0 1-2 0V3.414l-4.293 4.293a1 1 0 0 1-1.414-1.414L10.586 2H9a1 1 0 0 1-1.364-1.636zM2 3a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V9a1 1 0 1 1 2 0v3a3 3 0 0 1-3 3H2a3 3 0 0 1-3-3V4a3 3 0 0 1 3-3h3a1 1 0 1 1 0 2H2z"></path></svg></a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="https://github.com/cytrogen" target="_blank" rel="noopener noreferrer">GitHub<svg class="icon icon-external-link" width="14" height="14" viewBox="0 0 14 14" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8.636 2.364A1 1 0 0 1 10 1h3a1 1 0 0 1 1 1v3a1 1 0 0 1-2 0V3.414l-4.293 4.293a1 1 0 0 1-1.414-1.414L10.586 2H9a1 1 0 0 1-1.364-1.636zM2 3a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V9a1 1 0 1 1 2 0v3a3 3 0 0 1-3 3H2a3 3 0 0 1-3-3V4a3 3 0 0 1 3-3h3a1 1 0 1 1 0 2H2z"></path></svg></a></li></ul></div></details></div></div></div></nav></header><main class="container" id="main-content" tabindex="-1"><div class="post"><article class="post-block"><h1 class="post-title">Hexo源代码分析【1】：入口文件</h1><div class="post-info">5/26/2024</div><div class="post-content"><p>使用 Hexo，痛骂 Hexo，理解 Hexo，成为 Hexo。</p>
<p>这篇文章是用来记录我阅读 Hexo 源代码的过程和分析。</p>
<span id="more"></span>
<h1 id="版本号"><a class="markdownIt-Anchor" href="#版本号"></a> 版本号</h1>
<p>文章写的时候，Hexo 的版本为 <strong>7.2.0</strong>：</p>
<pre><code class="language-json">&#123;
  &quot;name&quot;: &quot;hexo&quot;,
  &quot;version&quot;: &quot;7.2.0&quot;,
  &quot;description&quot;: &quot;A fast, simple &amp; powerful blog framework, powered by Node.js.&quot;,
  &quot;main&quot;: &quot;dist/hexo&quot;,
  &quot;bin&quot;: &#123;
    &quot;hexo&quot;: &quot;./bin/hexo&quot;
  &#125;,
  &quot;scripts&quot;: &#123;
    &quot;prepublishOnly&quot;: &quot;npm install &amp;&amp; npm run clean &amp;&amp; npm run build&quot;,
    &quot;build&quot;: &quot;tsc -b&quot;,
    &quot;clean&quot;: &quot;tsc -b --clean&quot;,
    &quot;eslint&quot;: &quot;eslint lib test&quot;,
    &quot;pretest&quot;: &quot;npm run clean &amp;&amp; npm run build&quot;,
    &quot;test&quot;: &quot;mocha test/scripts/**/*.ts --require ts-node/register&quot;,
    &quot;test-cov&quot;: &quot;c8 --reporter=lcovonly npm test -- --no-parallel&quot;,
    &quot;prepare&quot;: &quot;husky install&quot;
  &#125;,
  &quot;files&quot;: [
    &quot;dist/&quot;,
    &quot;bin/&quot;
  ],
  &quot;types&quot;: &quot;./dist/hexo/index.d.ts&quot;,
  &quot;repository&quot;: &quot;hexojs/hexo&quot;,
  &quot;homepage&quot;: &quot;https://hexo.io/&quot;,
  &quot;funding&quot;: &#123;
    &quot;type&quot;: &quot;opencollective&quot;,
    &quot;url&quot;: &quot;https://opencollective.com/hexo&quot;
  &#125;,
  &quot;keywords&quot;: [
    &quot;website&quot;,
    &quot;blog&quot;,
    &quot;cms&quot;,
    &quot;framework&quot;,
    &quot;hexo&quot;
  ],
  &quot;author&quot;: &quot;Tommy Chen &lt;tommy351@gmail.com&gt; (https://zespia.tw)&quot;,
  &quot;maintainers&quot;: [
    &quot;Abner Chou &lt;hi@abnerchou.me&gt; (https://abnerchou.me)&quot;
  ],
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;dependencies&quot;: &#123;
    &quot;abbrev&quot;: &quot;^2.0.0&quot;,
    &quot;archy&quot;: &quot;^1.0.0&quot;,
    &quot;bluebird&quot;: &quot;^3.7.2&quot;,
    &quot;hexo-cli&quot;: &quot;^4.3.2&quot;,
    &quot;hexo-front-matter&quot;: &quot;^4.2.1&quot;,
    &quot;hexo-fs&quot;: &quot;^4.1.3&quot;,
    &quot;hexo-i18n&quot;: &quot;^2.0.0&quot;,
    &quot;hexo-log&quot;: &quot;^4.0.1&quot;,
    &quot;hexo-util&quot;: &quot;^3.3.0&quot;,
    &quot;js-yaml&quot;: &quot;^4.1.0&quot;,
    &quot;js-yaml-js-types&quot;: &quot;^1.0.0&quot;,
    &quot;micromatch&quot;: &quot;^4.0.4&quot;,
    &quot;moize&quot;: &quot;^6.1.6&quot;,
    &quot;moment&quot;: &quot;^2.29.1&quot;,
    &quot;moment-timezone&quot;: &quot;^0.5.34&quot;,
    &quot;nunjucks&quot;: &quot;^3.2.3&quot;,
    &quot;picocolors&quot;: &quot;^1.0.0&quot;,
    &quot;pretty-hrtime&quot;: &quot;^1.0.3&quot;,
    &quot;resolve&quot;: &quot;^1.22.0&quot;,
    &quot;strip-ansi&quot;: &quot;^6.0.0&quot;,
    &quot;text-table&quot;: &quot;^0.2.0&quot;,
    &quot;tildify&quot;: &quot;^2.0.0&quot;,
    &quot;titlecase&quot;: &quot;^1.1.3&quot;,
    &quot;warehouse&quot;: &quot;^5.0.1&quot;
  &#125;,
  &quot;devDependencies&quot;: &#123;
    &quot;0x&quot;: &quot;^5.1.2&quot;,
    &quot;@types/abbrev&quot;: &quot;^1.1.3&quot;,
    &quot;@types/bluebird&quot;: &quot;^3.5.37&quot;,
    &quot;@types/chai&quot;: &quot;^4.3.11&quot;,
    &quot;@types/js-yaml&quot;: &quot;^4.0.9&quot;,
    &quot;@types/mocha&quot;: &quot;^10.0.6&quot;,
    &quot;@types/node&quot;: &quot;^18.11.8 &lt;18.19.9&quot;,
    &quot;@types/nunjucks&quot;: &quot;^3.2.2&quot;,
    &quot;@types/rewire&quot;: &quot;^2.5.30&quot;,
    &quot;@types/sinon&quot;: &quot;^17.0.3&quot;,
    &quot;@types/text-table&quot;: &quot;^0.2.4&quot;,
    &quot;c8&quot;: &quot;^9.0.0&quot;,
    &quot;chai&quot;: &quot;^4.3.6&quot;,
    &quot;cheerio&quot;: &quot;0.22.0&quot;,
    &quot;decache&quot;: &quot;^4.6.1&quot;,
    &quot;eslint&quot;: &quot;^8.48.0&quot;,
    &quot;eslint-config-hexo&quot;: &quot;^5.0.0&quot;,
    &quot;hexo-renderer-marked&quot;: &quot;^6.0.0&quot;,
    &quot;husky&quot;: &quot;^8.0.1&quot;,
    &quot;lint-staged&quot;: &quot;^15.2.0&quot;,
    &quot;mocha&quot;: &quot;^10.0.0&quot;,
    &quot;rewire&quot;: &quot;^7.0.0&quot;,
    &quot;sinon&quot;: &quot;^17.0.1&quot;,
    &quot;ts-node&quot;: &quot;^10.9.1&quot;,
    &quot;typescript&quot;: &quot;^5.3.2&quot;
  &#125;,
  &quot;engines&quot;: &#123;
    &quot;node&quot;: &quot;&gt;=14&quot;
  &#125;
&#125;</code></pre>
<p>Hexo 的入口文件是 <code>dist/hexo/index.js</code>，我们来看看这个文件：</p>
<div class="danger">
<p>部分代码因为太长了，所以先注释掉，后续会拿出来说。</p>
</div>
<pre><code class="language-javascript">&quot;use strict&quot;;
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) &#123;
  return (mod &amp;&amp; mod.__esModule) ? mod : &#123; &quot;default&quot;: mod &#125;;
&#125;;
const bluebird_1 = __importDefault(require(&quot;bluebird&quot;));
const path_1 = require(&quot;path&quot;);
const tildify_1 = __importDefault(require(&quot;tildify&quot;));
const warehouse_1 = __importDefault(require(&quot;warehouse&quot;));
const picocolors_1 = require(&quot;picocolors&quot;);
const events_1 = require(&quot;events&quot;);
const hexo_fs_1 = require(&quot;hexo-fs&quot;);
const module_1 = __importDefault(require(&quot;module&quot;));
const vm_1 = require(&quot;vm&quot;);
const &#123; version &#125; = require(&#x27;../../package.json&#x27;);
const hexo_log_1 = __importDefault(require(&quot;hexo-log&quot;));
const extend_1 = require(&quot;../extend&quot;);
const render_1 = __importDefault(require(&quot;./render&quot;));
const register_models_1 = __importDefault(require(&quot;./register_models&quot;));
const post_1 = __importDefault(require(&quot;./post&quot;));
const scaffold_1 = __importDefault(require(&quot;./scaffold&quot;));
const source_1 = __importDefault(require(&quot;./source&quot;));
const router_1 = __importDefault(require(&quot;./router&quot;));
const theme_1 = __importDefault(require(&quot;../theme&quot;));
const locals_1 = __importDefault(require(&quot;./locals&quot;));
const default_config_1 = __importDefault(require(&quot;./default_config&quot;));
const load_database_1 = __importDefault(require(&quot;./load_database&quot;));
const multi_config_path_1 = __importDefault(require(&quot;./multi_config_path&quot;));
const hexo_util_1 = require(&quot;hexo-util&quot;);
let resolveSync; // = require(&#x27;resolve&#x27;);
const libDir = (0, path_1.dirname)(__dirname);
const dbVersion = 1;
const stopWatcher = (box) =&gt; &#123; if (box.isWatching())
  box.unwatch(); &#125;;
const routeCache = new WeakMap();
const castArray = (obj) =&gt; &#123; return Array.isArray(obj) ? obj : [obj]; &#125;;
const mergeCtxThemeConfig = (ctx) =&gt; &#123; ... &#125;;
const createLoadThemeRoute = function (generatorResult, locals, ctx) &#123; ... &#125;;
function debounce(func, wait) &#123; ... &#125;
class Hexo extends events_1.EventEmitter &#123; ... &#125;
Hexo.lib_dir = libDir + path_1.sep;
Hexo.prototype.lib_dir = Hexo.lib_dir;
Hexo.core_dir = (0, path_1.dirname)(libDir) + path_1.sep;
Hexo.prototype.core_dir = Hexo.core_dir;
Hexo.version = version;
Hexo.prototype.version = Hexo.version;
module.exports = Hexo;
//# sourceMappingURL=index.js.map</code></pre>
<h1 id="hexo类"><a class="markdownIt-Anchor" href="#hexo类"></a> <code>Hexo</code>类</h1>
<p>重点来看<code>Hexo</code>类的定义：</p>
<pre><code class="language-javascript">class Hexo extends events_1.EventEmitter &#123;
  constructor(base = process.cwd(), args = &#123;&#125;) &#123; ... &#125;
  _bindLocals() &#123; ... &#125;
  init() &#123; ... &#125;
  call(name, args, callback) &#123; ... &#125;
  model(name, schema) &#123; ... &#125;
  resolvePlugin(name, basedir) &#123; ... &#125;
  loadPlugin(path, callback) &#123; ... &#125;
  _showDrafts() &#123; ... &#125;
  load(callback) &#123; ... &#125;
  watch(callback) &#123; ... &#125;
  unwatch() &#123; ... &#125;
  _generateLocals() &#123; ... &#125;
  _runGenerators() &#123; ... &#125;
  _routerRefresh(runningGenerators, useCache) &#123; ... &#125;
  _generate(options = &#123;&#125;) &#123; ... &#125;
  exit(err) &#123; ... &#125;
  execFilter(type, data, options) &#123; ... &#125;
  execFilterSync(type, data, options) &#123; ... &#125;
&#125;</code></pre>
<h2 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h2>
<pre><code class="language-javascript">constructor(base = process.cwd(), args = &#123;&#125;) &#123;
  super();
  this.base_dir = base + path_1.sep;
  this.public_dir = (0, path_1.join)(base, &#x27;public&#x27;) + path_1.sep;
  this.source_dir = (0, path_1.join)(base, &#x27;source&#x27;) + path_1.sep;
  this.plugin_dir = (0, path_1.join)(base, &#x27;node_modules&#x27;) + path_1.sep;
  this.script_dir = (0, path_1.join)(base, &#x27;scripts&#x27;) + path_1.sep;
  this.scaffold_dir = (0, path_1.join)(base, &#x27;scaffolds&#x27;) + path_1.sep;
  this.theme_dir = (0, path_1.join)(base, &#x27;themes&#x27;, default_config_1.default.theme) + path_1.sep;
  this.theme_script_dir = (0, path_1.join)(this.theme_dir, &#x27;scripts&#x27;) + path_1.sep;
  this.env = &#123;
    args,
    debug: Boolean(args.debug),
    safe: Boolean(args.safe),
    silent: Boolean(args.silent),
    env: process.env.NODE_ENV || &#x27;development&#x27;,
    version,
    cmd: args._ ? args._[0] : &#x27;&#x27;,
    init: false
  &#125;;
  this.extend = &#123;
    console: new extend_1.Console(),
    deployer: new extend_1.Deployer(),
    filter: new extend_1.Filter(),
    generator: new extend_1.Generator(),
    helper: new extend_1.Helper(),
    highlight: new extend_1.Highlight(),
    injector: new extend_1.Injector(),
    migrator: new extend_1.Migrator(),
    processor: new extend_1.Processor(),
    renderer: new extend_1.Renderer(),
    tag: new extend_1.Tag()
  &#125;;
  this.config = Object.assign(&#123;&#125;, default_config_1.default);
  this.log = (0, hexo_log_1.default)(this.env);
  this.render = new render_1.default(this);
  this.route = new router_1.default();
  this.post = new post_1.default(this);
  this.scaffold = new scaffold_1.default(this);
  this._dbLoaded = false;
  this._isGenerating = false;
  const dbPath = args.output || base;
  if (/^(init|new|g|publish|s|deploy|render|migrate)/.test(this.env.cmd)) &#123;
    this.log.d(`Writing database to $&#123;(0, path_1.join)(dbPath, &#x27;db.json&#x27;)&#125;`);
  &#125;
  this.database = new warehouse_1.default(&#123;
    version: dbVersion,
    path: (0, path_1.join)(dbPath, &#x27;db.json&#x27;)
  &#125;);
  const mcp = (0, multi_config_path_1.default)(this);
  this.config_path = args.config ? mcp(base, args.config, args.output)
    : (0, path_1.join)(base, &#x27;_config.yml&#x27;);
  (0, register_models_1.default)(this);
  this.source = new source_1.default(this);
  this.theme = new theme_1.default(this);
  this.locals = new locals_1.default();
  this._bindLocals();
&#125;</code></pre>
<h4 id="路径"><a class="markdownIt-Anchor" href="#路径"></a> 路径</h4>
<pre><code class="language-javascript">this.base_dir = base + path_1.sep;
this.public_dir = (0, path_1.join)(base, &#x27;public&#x27;) + path_1.sep;
this.source_dir = (0, path_1.join)(base, &#x27;source&#x27;) + path_1.sep;
this.plugin_dir = (0, path_1.join)(base, &#x27;node_modules&#x27;) + path_1.sep;
this.script_dir = (0, path_1.join)(base, &#x27;scripts&#x27;) + path_1.sep;
this.scaffold_dir = (0, path_1.join)(base, &#x27;scaffolds&#x27;) + path_1.sep;
this.theme_dir = (0, path_1.join)(base, &#x27;themes&#x27;, default_config_1.default.theme) + path_1.sep;
this.theme_script_dir = (0, path_1.join)(this.theme_dir, &#x27;scripts&#x27;) + path_1.sep;</code></pre>
<ul>
<li><code>base_dir</code>：项目的基础目录</li>
<li><code>public_dir</code>：项目生成的静态文件存放的目录（<code>./public</code>），当运行<code>hexo generate</code>时生成的所有静态文件都会被放在这个目录下</li>
<li><code>source_dir</code>：Markdown文章（<code>./source</code>）</li>
<li><code>plugin_dir</code>：插件（<code>./node_modules</code>），Hexo的插件机制基于Node.js的模块系统</li>
<li><code>script_dir</code>：脚本（<code>./scripts</code>），Hexo启动时会自动执行这些JavaScript文件</li>
<li><code>scaffold_dir</code>：脚手架（<code>./scaffolds</code>）是一种模板，可以用它快速创建新的文章</li>
<li><code>theme_dir</code>：主题（<code>./themes</code>）
<ul>
<li><code>theme_script_dir</code>：类似于脚本（<code>./themes/scripts</code>）</li>
</ul>
</li>
</ul>
<h4 id="环境信息"><a class="markdownIt-Anchor" href="#环境信息"></a> 环境信息</h4>
<pre><code class="language-javascript">this.env = &#123;
  args,
  debug: Boolean(args.debug),
  safe: Boolean(args.safe),
  silent: Boolean(args.silent),
  env: process.env.NODE_ENV || &#x27;development&#x27;,
  version,
  cmd: args._ ? args._[0] : &#x27;&#x27;,
  init: false
&#125;;</code></pre>
<p>包含了关于 Hexo 运行环境的信息，如调试模式、安全模式、静默模式、环境变量、版本号、命令、是否初始化等。</p>
<h4 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h4>
<pre><code class="language-javascript">this.extend = &#123;
  console: new extend_1.Console(),
  deployer: new extend_1.Deployer(),
  filter: new extend_1.Filter(),
  generator: new extend_1.Generator(),
  helper: new extend_1.Helper(),
  highlight: new extend_1.Highlight(),
  injector: new extend_1.Injector(),
  migrator: new extend_1.Migrator(),
  processor: new extend_1.Processor(),
  renderer: new extend_1.Renderer(),
  tag: new extend_1.Tag()
&#125;;</code></pre>
<p>这些是 Hexo 的核心组件，以后会详细介绍。</p>
<blockquote>
<p>其实可以先行阅读 <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/api/">Hexo 官方文档</a>，虽然初次看可能很难看懂，但是看了总是会在未来的某个时刻头脑一亮埋下伏笔。</p>
</blockquote>
<h4 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h4>
<pre><code class="language-javascript">this.config = Object.assign(&#123;&#125;, default_config_1.default);</code></pre>
<p>默认配置的内容：</p>
<pre><code class="language-javascript">&quot;use strict&quot;;
module.exports = &#123;
    title: &#x27;Hexo&#x27;,
    subtitle: &#x27;&#x27;,
    description: &#x27;&#x27;,
    author: &#x27;John Doe&#x27;,
    language: &#x27;en&#x27;,
    timezone: &#x27;&#x27;,

    url: &#x27;http://example.com&#x27;,
    root: &#x27;/&#x27;,
    permalink: &#x27;:year/:month/:day/:title/&#x27;,
    permalink_defaults: &#123;&#125;,
    pretty_urls: &#123;
        trailing_index: true,
        trailing_html: true
    &#125;,

    source_dir: &#x27;source&#x27;,
    public_dir: &#x27;public&#x27;,
    tag_dir: &#x27;tags&#x27;,
    archive_dir: &#x27;archives&#x27;,
    category_dir: &#x27;categories&#x27;,
    code_dir: &#x27;downloads/code&#x27;,
    i18n_dir: &#x27;:lang&#x27;,
    skip_render: [],

    new_post_name: &#x27;:title.md&#x27;,
    default_layout: &#x27;post&#x27;,
    titlecase: false,
    external_link: &#123;
        enable: true,
        field: &#x27;site&#x27;,
        exclude: &#x27;&#x27;
    &#125;,
    filename_case: 0,
    render_drafts: false,
    post_asset_folder: false,
    relative_link: false,
    future: true,
    syntax_highlighter: &#x27;highlight.js&#x27;,
    highlight: &#123;
        auto_detect: false,
        line_number: true,
        tab_replace: &#x27;&#x27;,
        wrap: true,
        exclude_languages: [],
        language_attr: false,
        hljs: false,
        line_threshold: 0,
        first_line_number: &#x27;always1&#x27;,
        strip_indent: true
    &#125;,
    prismjs: &#123;
        preprocess: true,
        line_number: true,
        tab_replace: &#x27;&#x27;,
        exclude_languages: [],
        strip_indent: true
    &#125;,

    default_category: &#x27;uncategorized&#x27;,
    category_map: &#123;&#125;,
    tag_map: &#123;&#125;,

    date_format: &#x27;YYYY-MM-DD&#x27;,
    time_format: &#x27;HH:mm:ss&#x27;,
    updated_option: &#x27;mtime&#x27;,

    per_page: 10,
    pagination_dir: &#x27;page&#x27;,

    theme: &#x27;landscape&#x27;,
    server: &#123;
        cache: false
    &#125;,

    deploy: &#123;&#125;,

    ignore: [],

    meta_generator: true
&#125;;
//# sourceMappingURL=default_config.js.map</code></pre>
<p>看着很熟悉吧，这些配置项都是我们初始化 Hexo 项目时，出现在根目录的 <code>_config.yml</code> 内的配置项。</p>
<blockquote>
<p>可见 <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/configuration">Hexo 官方文档</a>。</p>
</blockquote>
<h4 id="日志"><a class="markdownIt-Anchor" href="#日志"></a> 日志</h4>
<pre><code class="language-javascript">this.log = (0, hexo_log_1.default)(this.env);</code></pre>
<p>这里的 <code>hexo_log_1</code> 是：</p>
<pre><code class="language-javascript">const hexo_log_1 = __importDefault(require(&quot;hexo-log&quot;));</code></pre>
<p><a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo-log"><img src="https://gh-card.dev/repos/hexojs/hexo-log.svg" alt="hexojs/hexo-log - GitHub"></a></p>
<p><code>index.js</code> 中大量的导入变量都是这样命名的。</p>
<h4 id="渲染"><a class="markdownIt-Anchor" href="#渲染"></a> 渲染</h4>
<pre><code class="language-javascript">this.render = new render_1.default(this);</code></pre>
<blockquote>
<p>可见 <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/api/rendering">Hexo 官方文档</a>。</p>
</blockquote>
<pre><code class="language-javascript">&quot;use strict&quot;;
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) &#123;
    return (mod &amp;&amp; mod.__esModule) ? mod : &#123; &quot;default&quot;: mod &#125;;
&#125;;
const path_1 = require(&quot;path&quot;);
const bluebird_1 = __importDefault(require(&quot;bluebird&quot;));
const hexo_fs_1 = require(&quot;hexo-fs&quot;);
const getExtname = (str) =&gt; &#123;
    if (typeof str !== &#x27;string&#x27;)
        return &#x27;&#x27;;
    const ext = (0, path_1.extname)(str);
    return ext.startsWith(&#x27;.&#x27;) ? ext.slice(1) : ext;
&#125;;
const toString = (result, options) =&gt; &#123;
    if (!Object.prototype.hasOwnProperty.call(options, &#x27;toString&#x27;) || typeof result === &#x27;string&#x27;)
        return result;
    if (typeof options.toString === &#x27;function&#x27;) &#123;
        return options.toString(result);
    &#125;
    else if (typeof result === &#x27;object&#x27;) &#123;
        return JSON.stringify(result);
    &#125;
    else if (result.toString) &#123;
        return result.toString();
    &#125;
    return result;
&#125;;
class Render &#123;
    constructor(ctx) &#123;
        this.context = ctx;
        this.renderer = ctx.extend.renderer;
    &#125;
    isRenderable(path) &#123;
        return this.renderer.isRenderable(path);
    &#125;
    isRenderableSync(path) &#123;
        return this.renderer.isRenderableSync(path);
    &#125;
    getOutput(path) &#123;
        return this.renderer.getOutput(path);
    &#125;
    getRenderer(ext, sync) &#123;
        return this.renderer.get(ext, sync);
    &#125;
    getRendererSync(ext) &#123;
        return this.getRenderer(ext, true);
    &#125;
    render(data, options, callback) &#123;
        if (!callback &amp;&amp; typeof options === &#x27;function&#x27;) &#123;
            callback = options;
            options = &#123;&#125;;
        &#125;
        const ctx = this.context;
        let ext = &#x27;&#x27;;
        let promise;
        if (!data)
            return bluebird_1.default.reject(new TypeError(&#x27;No input file or string!&#x27;));
        if (data.text != null) &#123;
            promise = bluebird_1.default.resolve(data.text);
        &#125;
        else if (!data.path) &#123;
            return bluebird_1.default.reject(new TypeError(&#x27;No input file or string!&#x27;));
        &#125;
        else &#123;
            promise = (0, hexo_fs_1.readFile)(data.path);
        &#125;
        return promise.then(text =&gt; &#123;
            data.text = text;
            ext = data.engine || getExtname(data.path);
            if (!ext || !this.isRenderable(ext))
                return text;
            const renderer = this.getRenderer(ext);
            return Reflect.apply(renderer, ctx, [data, options]);
        &#125;).then(result =&gt; &#123;
            result = toString(result, data);
            if (data.onRenderEnd) &#123;
                return data.onRenderEnd(result);
            &#125;
            return result;
        &#125;).then(result =&gt; &#123;
            const output = this.getOutput(ext) || ext;
            return ctx.execFilter(`after_render:$&#123;output&#125;`, result, &#123;
                context: ctx,
                args: [data]
            &#125;);
        &#125;).asCallback(callback);
    &#125;
    renderSync(data, options = &#123;&#125;) &#123;
        if (!data)
            throw new TypeError(&#x27;No input file or string!&#x27;);
        const ctx = this.context;
        if (data.text == null) &#123;
            if (!data.path)
                throw new TypeError(&#x27;No input file or string!&#x27;);
            data.text = (0, hexo_fs_1.readFileSync)(data.path);
        &#125;
        if (data.text == null)
            throw new TypeError(&#x27;No input file or string!&#x27;);
        const ext = data.engine || getExtname(data.path);
        let result;
        if (ext &amp;&amp; this.isRenderableSync(ext)) &#123;
            const renderer = this.getRendererSync(ext);
            result = Reflect.apply(renderer, ctx, [data, options]);
        &#125;
        else &#123;
            result = data.text;
        &#125;
        const output = this.getOutput(ext) || ext;
        result = toString(result, data);
        if (data.onRenderEnd) &#123;
            result = data.onRenderEnd(result);
        &#125;
        return ctx.execFilterSync(`after_render:$&#123;output&#125;`, result, &#123;
            context: ctx,
            args: [data]
        &#125;);
    &#125;
&#125;
module.exports = Render;
//# sourceMappingURL=render.js.map</code></pre>
<blockquote>
<p><code>bluebird</code> 库是一个流行的 JavaScript Promise 库，它提供了一种更加健壮、高效和优雅的方式来处理异步操作。</p>
<p>在传统的基于回调函数的异步编程中，存在着回调地狱、代码耦合等问题。Promise 的出现解决了这些问题，使着异步代码更加易于理解和维护。而 <code>bluebird</code> 在 Promise 的基础上提供了更多的增强功能和优化。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/petkaantonov/bluebird"><img src="https://gh-card.dev/repos/petkaantonov/bluebird.svg" alt="petkaantonov/bluebird - GitHub"></a></p>
<p><code>Render</code> 类包含两个主要方法：<code>render</code> 和 <code>renderSync</code>。</p>
<ol>
<li><code>render</code> 方法是一个异步方法，首先检查文件是否可根据其扩展名进行渲染。如果可以，它会获取相应的渲染器并将其应用于数据。渲染后的结果将通过一个过滤器，并在回调函数中返回。</li>
<li><code>renderSync</code> 方法是 <code>render</code> 的同步版本。工作方式类似，但使用同步文件读取，并使用异常代替回调和 Promise 处理错误。</li>
</ol>
<p>其他部分包括：</p>
<ul>
<li><code>getExtname</code> 是一个辅助函数，用于从文件路径中提取文件扩展名。</li>
<li><code>toString</code> 是一个辅助函数，根据提供的选项将结果对象转换为字符串表示。</li>
<li><code>Render</code> 类的构造函数接收 <code>Hexo</code> 上下文 <code>ctx</code>，并从中初始化 <code>renderer</code> 属性。</li>
<li><code>isRenderable</code> 和 <code>isRenderableSync</code> 方法检查给定扩展名的文件是否可渲染。</li>
<li><code>getOutput</code> 方法获取给定输入扩展名的输出扩展名。</li>
<li><code>getRenderer</code> 和 <code>getRendererSync</code> 方法获取给定扩展名的相应渲染器。</li>
</ul>
<p>这段代码为 Hexo 提供了一种基于文件扩展名渲染文件的方式,使用每种扩展名对应的渲染器。</p>
<h4 id="路由"><a class="markdownIt-Anchor" href="#路由"></a> 路由</h4>
<pre><code class="language-javascript">this.route = new router_1.default();</code></pre>
<p>这行代码实例化了 <code>Router</code> 类的对象，用于管理路由。在 <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/api/router">Hexo 官方文档</a>中，路由是 <strong>存储了网站中所用到的所有路径</strong>。</p>
<pre><code class="language-javascript">&quot;use strict&quot;;
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) &#123;
    return (mod &amp;&amp; mod.__esModule) ? mod : &#123; &quot;default&quot;: mod &#125;;
&#125;;
const events_1 = require(&quot;events&quot;);
const bluebird_1 = __importDefault(require(&quot;bluebird&quot;));
const stream_1 = __importDefault(require(&quot;stream&quot;));
const &#123; Readable &#125; = stream_1.default;
class RouteStream extends Readable &#123;
    constructor(data) &#123;
        super(&#123; objectMode: true &#125;);
        this._data = data.data;
        this._ended = false;
        this.modified = data.modified;
    &#125;
    // Assume we only accept Buffer, plain object, or string
    _toBuffer(data) &#123;
        if (data instanceof Buffer) &#123;
            return data;
        &#125;
        if (typeof data === &#x27;object&#x27;) &#123;
            data = JSON.stringify(data);
        &#125;
        if (typeof data === &#x27;string&#x27;) &#123;
            return Buffer.from(data); // Assume string is UTF-8 encoded string
        &#125;
        return null;
    &#125;
    _read() &#123;
        const data = this._data;
        if (typeof data !== &#x27;function&#x27;) &#123;
            const bufferData = this._toBuffer(data);
            if (bufferData) &#123;
                this.push(bufferData);
            &#125;
            this.push(null);
            return;
        &#125;
        // Don&#x27;t read it twice!
        if (this._ended)
            return false;
        this._ended = true;
        data().then(data =&gt; &#123;
            if (data instanceof stream_1.default &amp;&amp; data.readable) &#123;
                data.on(&#x27;data&#x27;, d =&gt; &#123;
                    this.push(d);
                &#125;);
                data.on(&#x27;end&#x27;, () =&gt; &#123;
                    this.push(null);
                &#125;);
                data.on(&#x27;error&#x27;, err =&gt; &#123;
                    this.emit(&#x27;error&#x27;, err);
                &#125;);
            &#125;
            else &#123;
                const bufferData = this._toBuffer(data);
                if (bufferData) &#123;
                    this.push(bufferData);
                &#125;
                this.push(null);
            &#125;
        &#125;).catch(err =&gt; &#123;
            this.emit(&#x27;error&#x27;, err);
            this.push(null);
        &#125;);
    &#125;
&#125;
const _format = (path) =&gt; &#123;
    path = path || &#x27;&#x27;;
    if (typeof path !== &#x27;string&#x27;)
        throw new TypeError(&#x27;path must be a string!&#x27;);
    path = path
        .replace(/^\/+/, &#x27;&#x27;) // Remove prefixed slashes
        .replace(/\\/g, &#x27;/&#x27;) // Replaces all backslashes
        .replace(/\?.*$/, &#x27;&#x27;); // Remove query string
    // Appends `index.html` to the path with trailing slash
    if (!path || path.endsWith(&#x27;/&#x27;)) &#123;
        path += &#x27;index.html&#x27;;
    &#125;
    return path;
&#125;;
class Router extends events_1.EventEmitter &#123;
    constructor() &#123;
        super();
        this.routes = &#123;&#125;;
    &#125;
    list() &#123;
        const &#123; routes &#125; = this;
        return Object.keys(routes).filter(key =&gt; routes[key]);
    &#125;
    format(path) &#123;
        return _format(path);
    &#125;
    get(path) &#123;
        if (typeof path !== &#x27;string&#x27;)
            throw new TypeError(&#x27;path must be a string!&#x27;);
        const data = this.routes[this.format(path)];
        if (data == null)
            return;
        return new RouteStream(data);
    &#125;
    isModified(path) &#123;
        if (typeof path !== &#x27;string&#x27;)
            throw new TypeError(&#x27;path must be a string!&#x27;);
        const data = this.routes[this.format(path)];
        return data ? data.modified : false;
    &#125;
    set(path, data) &#123;
        if (typeof path !== &#x27;string&#x27;)
            throw new TypeError(&#x27;path must be a string!&#x27;);
        if (data == null)
            throw new TypeError(&#x27;data is required!&#x27;);
        let obj;
        if (typeof data === &#x27;object&#x27; &amp;&amp; data.data != null) &#123;
            obj = data;
        &#125;
        else &#123;
            obj = &#123;
                data,
                modified: true
            &#125;;
        &#125;
        if (typeof obj.data === &#x27;function&#x27;) &#123;
            if (obj.data.length) &#123;
                obj.data = bluebird_1.default.promisify(obj.data);
            &#125;
            else &#123;
                obj.data = bluebird_1.default.method(obj.data);
            &#125;
        &#125;
        path = this.format(path);
        this.routes[path] = &#123;
            data: obj.data,
            modified: obj.modified == null ? true : obj.modified
        &#125;;
        this.emit(&#x27;update&#x27;, path);
        return this;
    &#125;
    remove(path) &#123;
        if (typeof path !== &#x27;string&#x27;)
            throw new TypeError(&#x27;path must be a string!&#x27;);
        path = this.format(path);
        this.routes[path] = null;
        this.emit(&#x27;remove&#x27;, path);
        return this;
    &#125;
&#125;
module.exports = Router;
//# sourceMappingURL=router.js.map</code></pre>
<p>这段代码定义了一个名为 <code>Router</code> 的类和一个名为 <code>RouteStream</code> 的类。它们在 Hexo 框架中用于管理路由和从路由读取数据流。</p>
<p><code>RouteStream</code> 类：</p>
<ul>
<li>继承自 Node.js 内置的 <code>stream.Readable</code> 类，因此它是一个可读流。</li>
<li>构造函数接收一个 <code>data</code> 对象,该对象包含 <code>data</code> 属性和 <code>modified</code> 属性。</li>
<li><code>_read()</code> 方法是可读流的实现。如果 <code>data</code> 是一个函数，它会尝试从该函数中获取数据。否则，它会将 <code>data</code> 推送到流中。</li>
<li><code>_toBuffer()</code> 是一个内部方法，用于将数据转换为 <code>Buffer</code>。</li>
</ul>
<p><code>Router</code> 类:</p>
<ul>
<li>继承自 <code>EventEmitter</code>，因此可以发射和监听事件。</li>
<li><code>routes</code> 属性是一个对象，用于存储路径及其对应的数据。</li>
<li><code>list()</code> 方法返回所有已注册路径的列表。</li>
<li><code>format(path)</code> 方法用于格式化路径，移除前导斜杠、替换反斜杠，并为以斜杠结尾的路径添加 <code>index.html</code>。</li>
<li><code>get(path)</code> 方法用于获取给定路径的数据流。如果路径不存在或数据为 <code>null</code>，则返回 <code>undefined</code>。</li>
<li><code>isModified(path)</code> 方法用于检查给定路径的数据是否已修改。</li>
<li><code>set(path, data)</code> 方法用于设置给定路径的数据。如果 <code>data</code> 是一个函数，它会使用 <code>Bluebird</code> 库将其转换为 Promise。该方法还会触发 <code>update</code> 事件。</li>
<li><code>remove(path)</code> 方法用于移除给定路径的数据。它会将路径对应的值设置为 <code>null</code>，并触发 <code>remove</code> 事件。</li>
</ul>
<blockquote>
<p>Node.js 的 <code>EventEmitter</code> 是一个模块，提供基于事件驱动的编程方式，是 Node.js 很多核心模块和第三方模块的基础，也是 Node.js 中非常重要的一个概念和设计模式。</p>
<p><code>EventEmitter</code> 是一个构造函数，可以创建一个新的事件发射器对象。这个对象可以发射命名事件，并且可以通过添加事件监听器来监听特定事件。当事件被发射时，所有监听该事件的函数回调都会被同步地调用。</p>
<p><code>EventEmitter</code> 对象有以下常用方法：</p>
<ol>
<li><code>emitter.on(eventName, listener)</code> 为指定事件注册一个监听器。</li>
<li><code>emitter.once(eventName, listener)</code> 为指定事件注册一个一次性的监听器，触发后就会被移除。</li>
<li><code>emitter.off(eventName, listener)</code> 移除指定事件的监听器。</li>
<li><code>emitter.emit(eventName, [...args])</code> 发射指定事件，传递参数给监听器回调函数。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/api/events">Hexo 官方文档</a> 中也提到了 <code>EventEmitter</code>。</p>
</blockquote>
<h4 id="博客文章"><a class="markdownIt-Anchor" href="#博客文章"></a> 博客文章</h4>
<pre><code class="language-javascript">this.post = new post_1.default(this);</code></pre>
<blockquote>
<p>可见 <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/api/posts">Hexo 官方文档</a>。</p>
</blockquote>
<div class="danger">
<p><code>post.js</code> 很长，因此将部分代码分开讲解。</p>
</div>
<pre><code class="language-javascript">&quot;use strict&quot;;
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) &#123;
    return (mod &amp;&amp; mod.__esModule) ? mod : &#123; &quot;default&quot;: mod &#125;;
&#125;;
const assert_1 = __importDefault(require(&quot;assert&quot;));
const moment_1 = __importDefault(require(&quot;moment&quot;));
const bluebird_1 = __importDefault(require(&quot;bluebird&quot;));
const path_1 = require(&quot;path&quot;);
const picocolors_1 = require(&quot;picocolors&quot;);
const js_yaml_1 = require(&quot;js-yaml&quot;);
const hexo_util_1 = require(&quot;hexo-util&quot;);
const hexo_fs_1 = require(&quot;hexo-fs&quot;);
const hexo_front_matter_1 = require(&quot;hexo-front-matter&quot;);
const preservedKeys = [&#x27;title&#x27;, &#x27;slug&#x27;, &#x27;path&#x27;, &#x27;layout&#x27;, &#x27;date&#x27;, &#x27;content&#x27;];
const rHexoPostRenderEscape = /&lt;hexoPostRenderCodeBlock&gt;([\s\S]+?)&lt;\/hexoPostRenderCodeBlock&gt;/g;
const rSwigPlaceHolder = /(?:&lt;|&amp;lt;)!--swig\uFFFC(\d+)--(?:&gt;|&amp;gt;)/g;
const rCodeBlockPlaceHolder = /(?:&lt;|&amp;lt;)!--code\uFFFC(\d+)--(?:&gt;|&amp;gt;)/g;
const STATE_PLAINTEXT = Symbol(&#x27;plaintext&#x27;);
const STATE_SWIG_VAR = Symbol(&#x27;swig_var&#x27;);
const STATE_SWIG_COMMENT = Symbol(&#x27;swig_comment&#x27;);
const STATE_SWIG_TAG = Symbol(&#x27;swig_tag&#x27;);
const STATE_SWIG_FULL_TAG = Symbol(&#x27;swig_full_tag&#x27;);
const isNonWhiteSpaceChar = (char) =&gt; char !== &#x27;\r&#x27;
    &amp;&amp; char !== &#x27;\n&#x27;
    &amp;&amp; char !== &#x27;\t&#x27;
    &amp;&amp; char !== &#x27;\f&#x27;
    &amp;&amp; char !== &#x27;\v&#x27;
    &amp;&amp; char !== &#x27; &#x27;;</code></pre>
<p><code>PostRenderEscape</code> 类用于处理 Swig/Nunjucks 标签和代码块的转义和还原：</p>
<blockquote>
<p>Swig 和 Nunjucks 是两种流行的模板引擎。</p>
<p>主要语法包括：</p>
<ul>
<li><code>&#123;% ... %&#125;</code>：用于执行语句，如条件语句和循环语句。</li>
<li><code>&#123;&#123; ... &#125;&#125;</code>：用于输出变量值。</li>
</ul>
<p>在渲染文章内容时，Hexo 需要先对 Swig/Nunjucks 标签和代码块进行转义，防止被误解析，然后再使用相应的渲染器（如 Markdown）进行渲染。渲染完成后，需要将转义的内容还原回来。</p>
</blockquote>
<pre><code class="language-javascript">class PostRenderEscape &#123;
    constructor() &#123;
        this.stored = [];
    &#125;
    static escapeContent(cache, flag, str) &#123;
        return `&lt;!--$&#123;flag&#125;\uFFFC$&#123;cache.push(str) - 1&#125;--&gt;`;
    &#125;
    static restoreContent(cache) &#123;
        return (_, index) =&gt; &#123;
            (0, assert_1.default)(cache[index]);
            const value = cache[index];
            cache[index] = null;
            return value;
        &#125;;
    &#125;
    restoreAllSwigTags(str) &#123;
        const restored = str.replace(rSwigPlaceHolder, PostRenderEscape.restoreContent(this.stored));
        return restored;
    &#125;
    restoreCodeBlocks(str) &#123;
        return str.replace(rCodeBlockPlaceHolder, PostRenderEscape.restoreContent(this.stored));
    &#125;
    escapeCodeBlocks(str) &#123;
        return str.replace(rHexoPostRenderEscape, (_, content) =&gt; PostRenderEscape.escapeContent(this.stored, &#x27;code&#x27;, content));
    &#125;
    /**
     * @param &#123;string&#125; str
     * @returns string
     */
    escapeAllSwigTags(str) &#123;
        if (!/(\&#123;\&#123;.+?\&#125;\&#125;)|(\&#123;#.+?#\&#125;)|(\&#123;%.+?%\&#125;)/s.test(str)) &#123;
            return str;
        &#125;
        let state = STATE_PLAINTEXT;
        let buffer = &#x27;&#x27;;
        let output = &#x27;&#x27;;
        let swig_tag_name_begin = false;
        let swig_tag_name_end = false;
        let swig_tag_name = &#x27;&#x27;;
        let swig_full_tag_start_buffer = &#x27;&#x27;;
        const &#123; length &#125; = str;
        for (let idx = 0; idx &lt; length; idx++) &#123;
            const char = str[idx];
            const next_char = str[idx + 1];
            if (state === STATE_PLAINTEXT) &#123; // From plain text to swig
                if (char === &#x27;&#123;&#x27;) &#123;
                    // check if it is a complete tag &#123;&#123; &#125;&#125;
                    if (next_char === &#x27;&#123;&#x27;) &#123;
                        state = STATE_SWIG_VAR;
                        idx++;
                    &#125;
                    else if (next_char === &#x27;#&#x27;) &#123;
                        state = STATE_SWIG_COMMENT;
                        idx++;
                    &#125;
                    else if (next_char === &#x27;%&#x27;) &#123;
                        state = STATE_SWIG_TAG;
                        idx++;
                        swig_tag_name = &#x27;&#x27;;
                        swig_full_tag_start_buffer = &#x27;&#x27;;
                        swig_tag_name_begin = false; // Mark if it is the first non white space char in the swig tag
                        swig_tag_name_end = false;
                    &#125;
                    else &#123;
                        output += char;
                    &#125;
                &#125;
                else &#123;
                    output += char;
                &#125;
            &#125;
            else if (state === STATE_SWIG_TAG) &#123;
                if (char === &#x27;%&#x27; &amp;&amp; next_char === &#x27;&#125;&#x27;) &#123; // From swig back to plain text
                    idx++;
                    if (swig_tag_name !== &#x27;&#x27; &amp;&amp; str.includes(`end$&#123;swig_tag_name&#125;`)) &#123;
                        state = STATE_SWIG_FULL_TAG;
                    &#125;
                    else &#123;
                        swig_tag_name = &#x27;&#x27;;
                        state = STATE_PLAINTEXT;
                        output += PostRenderEscape.escapeContent(this.stored, &#x27;swig&#x27;, `&#123;%$&#123;buffer&#125;%&#125;`);
                    &#125;
                    buffer = &#x27;&#x27;;
                &#125;
                else &#123;
                    buffer = buffer + char;
                    swig_full_tag_start_buffer = swig_full_tag_start_buffer + char;
                    if (isNonWhiteSpaceChar(char)) &#123;
                        if (!swig_tag_name_begin &amp;&amp; !swig_tag_name_end) &#123;
                            swig_tag_name_begin = true;
                        &#125;
                        if (swig_tag_name_begin) &#123;
                            swig_tag_name += char;
                        &#125;
                    &#125;
                    else &#123;
                        if (swig_tag_name_begin === true) &#123;
                            swig_tag_name_begin = false;
                            swig_tag_name_end = true;
                        &#125;
                    &#125;
                &#125;
            &#125;
            else if (state === STATE_SWIG_VAR) &#123;
                if (char === &#x27;&#125;&#x27; &amp;&amp; next_char === &#x27;&#125;&#x27;) &#123;
                    idx++;
                    state = STATE_PLAINTEXT;
                    output += PostRenderEscape.escapeContent(this.stored, &#x27;swig&#x27;, `&#123;&#123;$&#123;buffer&#125;&#125;&#125;`);
                    buffer = &#x27;&#x27;;
                &#125;
                else &#123;
                    buffer = buffer + char;
                &#125;
            &#125;
            else if (state === STATE_SWIG_COMMENT) &#123; // From swig back to plain text
                if (char === &#x27;#&#x27; &amp;&amp; next_char === &#x27;&#125;&#x27;) &#123;
                    idx++;
                    state = STATE_PLAINTEXT;
                    buffer = &#x27;&#x27;;
                &#125;
            &#125;
            else if (state === STATE_SWIG_FULL_TAG) &#123;
                if (char === &#x27;&#123;&#x27; &amp;&amp; next_char === &#x27;%&#x27;) &#123;
                    let swig_full_tag_end_buffer = &#x27;&#x27;;
                    let _idx = idx + 2;
                    for (; _idx &lt; length; _idx++) &#123;
                        const _char = str[_idx];
                        const _next_char = str[_idx + 1];
                        if (_char === &#x27;%&#x27; &amp;&amp; _next_char === &#x27;&#125;&#x27;) &#123;
                            _idx++;
                            break;
                        &#125;
                        swig_full_tag_end_buffer = swig_full_tag_end_buffer + _char;
                    &#125;
                    if (swig_full_tag_end_buffer.includes(`end$&#123;swig_tag_name&#125;`)) &#123;
                        state = STATE_PLAINTEXT;
                        output += PostRenderEscape.escapeContent(this.stored, &#x27;swig&#x27;, `&#123;%$&#123;swig_full_tag_start_buffer&#125;%&#125;$&#123;buffer&#125;&#123;%$&#123;swig_full_tag_end_buffer&#125;%&#125;`);
                        idx = _idx;
                        swig_full_tag_start_buffer = &#x27;&#x27;;
                        swig_full_tag_end_buffer = &#x27;&#x27;;
                        buffer = &#x27;&#x27;;
                    &#125;
                    else &#123;
                        buffer += char;
                    &#125;
                &#125;
                else &#123;
                    buffer += char;
                &#125;
            &#125;
        &#125;
        return output;
    &#125;
&#125;</code></pre>
<ul>
<li><code>escapeContent</code>：用于将给定的字符串转义为占位符，并存储在缓存数组中。
<ul>
<li>转义后的占位符格式为：<code>&lt;!--flag\uFFFC$&#123;index&#125;--&gt;</code>。</li>
</ul>
</li>
<li><code>restoreContent</code>：用于将占位符还原为原始字符串。</li>
<li><code>restoreAllSwigTags</code>：使用正则表达式替换所有 Swig 标签占位符，调用 <code>restoreContent</code> 方法还原原始内容。</li>
<li><code>restoreCodeBlocks</code>：使用正则表达式替换所有代码块占位符,调用 <code>restoreContent</code> 方法还原原始内容。</li>
<li><code>escapeCodeBlocks</code>：使用正则表达式匹配所有 Markdown 代码块，调用 <code>escapeContent</code> 方法将它们转义为占位符。</li>
<li><code>escapeAllSwigTags</code>：用于转义 Swig 模板标签。首先检查输入字符串是否包含 Swig 标签，然后使用有限状态机的方式遍历每个字符，识别出 Swig 标签的类型和内容，并调用 <code>escapeContent</code> 进行转义。</li>
</ul>
<blockquote>
<p>有限状态机（Finite State Machine；FSM）是一种数学计算模型，用于描述具有有限个状态以及基于事件进行状态转移的系统。</p>
<p>一个有限状态机包含以下几个基本组成部分：</p>
<ul>
<li>有限状态集合（States）。</li>
<li>输入事件/符号集合（Input Events/Symbols）。</li>
<li>一个初始状态（Initial State）。</li>
<li>状态转移函数（State Transition Function）。</li>
<li>终止状态集合（Final States）。</li>
</ul>
<p>有限状态机的工作原理：</p>
<ol>
<li>机器初始处于一个确定的初始状态。</li>
<li>机器接收一个输入事件/符号。</li>
<li>根据当前状态和输入事件/符号，机器按照状态转移函数进行状态转移。</li>
<li>机器进入新的状态，等待下一个输入事件/符号。</li>
<li>重复以上过程，直到进入某个终止状态或发生无法处理的输入事件/符号。</li>
</ol>
<p><code>escapeAllSwigTags</code> 使用了一个有限状态机来精确识别和处理各种 Swig 标签。它定义了五种状态，通过遍历输入字符串，根据当前状态和字符进行状态转移，从而正确处理嵌套、注释等复杂情况。</p>
</blockquote>
<pre><code class="language-javascript">const prepareFrontMatter = (data, jsonMode) =&gt; &#123;
    for (const [key, item] of Object.entries(data)) &#123;
        if (moment_1.default.isMoment(item)) &#123;
            data[key] = item.utc().format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;);
        &#125;
        else if (moment_1.default.isDate(item)) &#123;
            data[key] = moment_1.default.utc(item).format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;);
        &#125;
        else if (typeof item === &#x27;string&#x27;) &#123;
            if (jsonMode || item.includes(&#x27;:&#x27;) || item.startsWith(&#x27;#&#x27;) || item.startsWith(&#x27;!!&#x27;)
                || item.includes(&#x27;&#123;&#x27;) || item.includes(&#x27;&#125;&#x27;) || item.includes(&#x27;[&#x27;) || item.includes(&#x27;]&#x27;)
                || item.includes(&#x27;\&#x27;&#x27;) || item.includes(&#x27;&quot;&#x27;))
                data[key] = `&quot;$&#123;item.replace(/&quot;/g, &#x27;\\&quot;&#x27;)&#125;&quot;`;
        &#125;
    &#125;
    return data;
&#125;;
const removeExtname = (str) =&gt; &#123;
    return str.substring(0, str.length - (0, path_1.extname)(str).length);
&#125;;
const createAssetFolder = (path, assetFolder) =&gt; &#123;
    if (!assetFolder)
        return bluebird_1.default.resolve();
    const target = removeExtname(path);
    if ((0, path_1.basename)(target) === &#x27;index&#x27;)
        return bluebird_1.default.resolve();
    return (0, hexo_fs_1.exists)(target).then(exist =&gt; &#123;
        if (!exist)
            return (0, hexo_fs_1.mkdirs)(target);
    &#125;);
&#125;;</code></pre>
<ul>
<li>
<p><code>prepareFrontMatter</code> 方法用于处理文章的 Front Matter 元数据。</p>
<blockquote>
<p>Front Matter 是指在 Markdown 或其他 markup 文件的头部添加的一组元数据。它通常被包裹在两组连续的三短横线之间，例如：</p>
<pre><code class="language-markdown">---
title: My Blog Post
date: 2023-05-26
tags: [blog, coding]
---

# My Blog Post

This is the content of the blog post...</code></pre>
<p>Front Matter通常采用 YAML 或 JSON 格式来表示键值对的元数据。Front Matter 中的数据可以在渲染 markdown 文件时被解析和使用，例如在博客系统中用于生成文章的元数据、URL等。不同的静态站点生成器和 markdown 渲染器支持不同的 Front Matter 语法和元数据项。</p>
</blockquote>
<p>它遍历 <code>data</code> 对象的每个键值对。如果值是 <code>moment</code> 对象或 <code>Date</code> 对象，则将其转换为 UTC 时区的 <code>YYYY-MM-DD HH:mm:ss</code> 格式的字符串。如果值是字符串，并且符合某些条件（包含特殊字符或需要转义），则将其用双引号包裹起来，并对双引号进行转义。</p>
<p>这个函数主要用于在生成文章时正确处理 Front Matter 中的日期和特殊字符。</p>
</li>
<li>
<p><code>removeExtname</code> 方法用于从文件路径中移除扩展名。它使用 <code>path.extname</code> 获取扩展名，然后从原始路径中截取并返回不包含扩展名的部分。</p>
</li>
<li>
<p><code>createAssetFolder</code> 方法用于在生成文章时创建与文章相关联的资源文件夹（如果配置启用了该选项）。</p>
<ul>
<li>如果 <code>assetFolder</code> 为 <code>false</code>，则直接返回一个已解决的 Promise。否则它会调用 <code>removeExtname</code> 来获取不包含扩展名的文件路径。</li>
<li>如果这个路径的基础名称是 <code>index</code>，则直接返回一个已解决的 Promise（因为 <code>index</code> 通常是默认文件名,不需要创建文件夹）。否则,它会检查该路径是否存在，如果不存在，则创建该路径作为文件夹。</li>
</ul>
</li>
</ul>
<pre><code class="language-javascript">class Post &#123;
    constructor(context) &#123;
        this.context = context;
    &#125;
    create(data, replace, callback) &#123;
        if (!callback &amp;&amp; typeof replace === &#x27;function&#x27;) &#123;
            callback = replace;
            replace = false;
        &#125;
        const ctx = this.context;
        const &#123; config &#125; = ctx;
        data.slug = (0, hexo_util_1.slugize)((data.slug || data.title).toString(), &#123; transform: config.filename_case &#125;);
        data.layout = (data.layout || config.default_layout).toLowerCase();
        data.date = data.date ? (0, moment_1.default)(data.date) : (0, moment_1.default)();
        return bluebird_1.default.all([
            // Get the post path
            ctx.execFilter(&#x27;new_post_path&#x27;, data, &#123;
                args: [replace],
                context: ctx
            &#125;),
            this._renderScaffold(data)
        ]).spread((path, content) =&gt; &#123;
            const result = &#123; path, content &#125;;
            return bluebird_1.default.all([
                // Write content to file
                (0, hexo_fs_1.writeFile)(path, content),
                // Create asset folder
                createAssetFolder(path, config.post_asset_folder)
            ]).then(() =&gt; &#123;
                ctx.emit(&#x27;new&#x27;, result);
                return result;
            &#125;);
        &#125;).asCallback(callback);
    &#125;
    _getScaffold(layout) &#123;
        const ctx = this.context;
        return ctx.scaffold.get(layout).then(result =&gt; &#123;
            if (result != null)
                return result;
            return ctx.scaffold.get(&#x27;normal&#x27;);
        &#125;);
    &#125;
    _renderScaffold(data) &#123;
        const &#123; tag &#125; = this.context.extend;
        let splitted;
        return this._getScaffold(data.layout).then(scaffold =&gt; &#123;
            splitted = (0, hexo_front_matter_1.split)(scaffold);
            const jsonMode = splitted.separator.startsWith(&#x27;;&#x27;);
            const frontMatter = prepareFrontMatter(Object.assign(&#123;&#125;, data), jsonMode);
            return tag.render(splitted.data, frontMatter);
        &#125;).then(frontMatter =&gt; &#123;
            const &#123; separator &#125; = splitted;
            const jsonMode = separator.startsWith(&#x27;;&#x27;);
            // Parse front-matter
            const obj = jsonMode ? JSON.parse(`&#123;$&#123;frontMatter&#125;&#125;`) : (0, js_yaml_1.load)(frontMatter);
            Object.keys(data)
                .filter(key =&gt; !preservedKeys.includes(key) &amp;&amp; obj[key] == null)
                .forEach(key =&gt; &#123;
                    obj[key] = data[key];
                &#125;);
            let content = &#x27;&#x27;;
            // Prepend the separator
            if (splitted.prefixSeparator)
                content += `$&#123;separator&#125;\n`;
            content += (0, hexo_front_matter_1.stringify)(obj, &#123;
                mode: jsonMode ? &#x27;json&#x27; : &#x27;&#x27;
            &#125;);
            // Concat content
            content += splitted.content;
            if (data.content) &#123;
                content += `\n$&#123;data.content&#125;`;
            &#125;
            return content;
        &#125;);
    &#125;
    publish(data, replace, callback) &#123;
        if (!callback &amp;&amp; typeof replace === &#x27;function&#x27;) &#123;
            callback = replace;
            replace = false;
        &#125;
        if (data.layout === &#x27;draft&#x27;)
            data.layout = &#x27;post&#x27;;
        const ctx = this.context;
        const &#123; config &#125; = ctx;
        const draftDir = (0, path_1.join)(ctx.source_dir, &#x27;_drafts&#x27;);
        const slug = (0, hexo_util_1.slugize)(data.slug.toString(), &#123; transform: config.filename_case &#125;);
        data.slug = slug;
        const regex = new RegExp(`^$&#123;(0, hexo_util_1.escapeRegExp)(slug)&#125;(?:[^\\/\\\\]+)`);
        let src = &#x27;&#x27;;
        const result = &#123;&#125;;
        data.layout = (data.layout || config.default_layout).toLowerCase();
        // Find the draft
        return (0, hexo_fs_1.listDir)(draftDir).then(list =&gt; &#123;
            const item = list.find(item =&gt; regex.test(item));
            if (!item)
                throw new Error(`Draft &quot;$&#123;slug&#125;&quot; does not exist.`);
            // Read the content
            src = (0, path_1.join)(draftDir, item);
            return (0, hexo_fs_1.readFile)(src);
        &#125;).then(content =&gt; &#123;
            // Create post
            Object.assign(data, (0, hexo_front_matter_1.parse)(content));
            data.content = data._content;
            data._content = undefined;
            return this.create(data, replace);
        &#125;).then(post =&gt; &#123;
            result.path = post.path;
            result.content = post.content;
            return (0, hexo_fs_1.unlink)(src);
        &#125;).then(() =&gt; &#123;
            if (!config.post_asset_folder)
                return;
            // Copy assets
            const assetSrc = removeExtname(src);
            const assetDest = removeExtname(result.path);
            return (0, hexo_fs_1.exists)(assetSrc).then(exist =&gt; &#123;
                if (!exist)
                    return;
                return (0, hexo_fs_1.copyDir)(assetSrc, assetDest).then(() =&gt; (0, hexo_fs_1.rmdir)(assetSrc));
            &#125;);
        &#125;).thenReturn(result).asCallback(callback);
    &#125;
    render(source, data = &#123;&#125;, callback) &#123;
        const ctx = this.context;
        const &#123; config &#125; = ctx;
        const &#123; tag &#125; = ctx.extend;
        const ext = data.engine || (source ? (0, path_1.extname)(source) : &#x27;&#x27;);
        let promise;
        if (data.content != null) &#123;
            promise = bluebird_1.default.resolve(data.content);
        &#125;
        else if (source) &#123;
            // Read content from files
            promise = (0, hexo_fs_1.readFile)(source);
        &#125;
        else &#123;
            return bluebird_1.default.reject(new Error(&#x27;No input file or string!&#x27;)).asCallback(callback);
        &#125;
        // Files like js and css are also processed by this function, but they do not require preprocessing like markdown
        // data.source does not exist when tag plugins call the markdown renderer
        const isPost = !data.source || [&#x27;html&#x27;, &#x27;htm&#x27;].includes(ctx.render.getOutput(data.source));
        if (!isPost) &#123;
            return promise.then(content =&gt; &#123;
                data.content = content;
                ctx.log.debug(&#x27;Rendering file: %s&#x27;, (0, picocolors_1.magenta)(source));
                return ctx.render.render(&#123;
                    text: data.content,
                    path: source,
                    engine: data.engine,
                    toString: true
                &#125;);
            &#125;).then(content =&gt; &#123;
                data.content = content;
                return data;
            &#125;).asCallback(callback);
        &#125;
        // disable Nunjucks when the renderer specify that.
        let disableNunjucks = ext &amp;&amp; ctx.render.renderer.get(ext) &amp;&amp; !!ctx.render.renderer.get(ext).disableNunjucks;
        // front-matter overrides renderer&#x27;s option
        if (typeof data.disableNunjucks === &#x27;boolean&#x27;)
            disableNunjucks = data.disableNunjucks;
        const cacheObj = new PostRenderEscape();
        return promise.then(content =&gt; &#123;
            data.content = content;
            // Run &quot;before_post_render&quot; filters
            return ctx.execFilter(&#x27;before_post_render&#x27;, data, &#123; context: ctx &#125;);
        &#125;).then(() =&gt; &#123;
            data.content = cacheObj.escapeCodeBlocks(data.content);
            // Escape all Nunjucks/Swig tags
            if (disableNunjucks === false) &#123;
                data.content = cacheObj.escapeAllSwigTags(data.content);
            &#125;
            const options = data.markdown || &#123;&#125;;
            if (!config.syntax_highlighter)
                options.highlight = null;
            ctx.log.debug(&#x27;Rendering post: %s&#x27;, (0, picocolors_1.magenta)(source));
            // Render with markdown or other renderer
            return ctx.render.render(&#123;
                text: data.content,
                path: source,
                engine: data.engine,
                toString: true,
                onRenderEnd(content) &#123;
                    // Replace cache data with real contents
                    data.content = cacheObj.restoreAllSwigTags(content);
                    // Return content after replace the placeholders
                    if (disableNunjucks)
                        return data.content;
                    // Render with Nunjucks
                    return tag.render(data.content, data);
                &#125;
            &#125;, options);
        &#125;).then(content =&gt; &#123;
            data.content = cacheObj.restoreCodeBlocks(content);
            // Run &quot;after_post_render&quot; filters
            return ctx.execFilter(&#x27;after_post_render&#x27;, data, &#123; context: ctx &#125;);
        &#125;).asCallback(callback);
    &#125;
&#125;
module.exports = Post;
//# sourceMappingURL=post.js.map</code></pre>
<p><code>Post</code> 类包含了在 Hexo 框架中创建、发布和渲染文章的和新方法。</p>
<ul>
<li><code>create(data, replace, callback)</code>：创建一篇新文章。
<ol>
<li>首先根据配置和传入的数据准备文章的 slug、布局和日期。</li>
<li>然后通过执行 <code>new_post_path</code> 过滤器获取文章路径，并调用 <code>_renderScaffold</code> 方法渲染文章内容。</li>
<li>最后将渲染后的内容写入文件，并根据配置创建相关的资源文件夹。</li>
</ol>
</li>
<li><code>_getScaffold(layout)</code> 和 <code>_renderScaffold(data)</code>：
<ul>
<li><code>_getScaffold</code> 方法用于获取指定布局的脚手架。</li>
<li><code>_renderScaffold</code> 方法用于渲染脚手架，并将传入的数据合并到模板中。
<ul>
<li>先解析 Front Matter，然后使用标签插件渲染 Front Matter。最后将渲染后的 Front Matter 和原始内容合并，返回最终的文章内容。</li>
</ul>
</li>
</ul>
</li>
<li><code>publish(data, replace, callback)</code>：将草稿文章发布为正式文章。
<ol>
<li>首先从 <code>_drafts</code> 目录查找对应的草稿文件，读取其内容。</li>
<li>然后将草稿内容与传入的数据合并，调用 <code>create</code> 方法创建正式文章。</li>
<li>最后删除原始的草稿文件，并根据配置复制相关的资源文件夹。</li>
</ol>
</li>
<li><code>render(source, data, callback)</code>：渲染文章内容。
<ol>
<li>首先读取源文件或使用传入的内容。</li>
<li>然后执行 <code>before_post_render</code> 过滤器。</li>
<li>接着对代码块和 Swig/Nunjucks 标签进行转义，使用 Markdown 或其他渲染器渲染文章内容。</li>
<li>渲染完成后，将转义的内容还原，并执行 <code>after_post_render</code> 过滤器。</li>
<li>如果禁用了 Nunjucks，则返回渲染后的内容；否则使用标签插件渲染一次。</li>
</ol>
</li>
</ul>
<h4 id="脚手架"><a class="markdownIt-Anchor" href="#脚手架"></a> 脚手架</h4>
<p>脚手架文件是创建新文章或页面时使用的模板文件。</p>
<blockquote>
<p>可见 <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/api/scaffolds">Hexo 官方文档</a>。</p>
</blockquote>
<pre><code class="language-javascript">this.scaffold = new scaffold_1.default(this);</code></pre>
<pre><code class="language-javascript">&quot;use strict&quot;;
const path_1 = require(&quot;path&quot;);
const hexo_fs_1 = require(&quot;hexo-fs&quot;);
class Scaffold &#123;
    constructor(context) &#123;
        this.context = context;
        this.scaffoldDir = context.scaffold_dir;
        this.defaults = &#123;
            normal: [
                &#x27;---&#x27;,
                &#x27;layout: &#123;&#123; layout &#125;&#125;&#x27;,
                &#x27;title: &#123;&#123; title &#125;&#125;&#x27;,
                &#x27;date: &#123;&#123; date &#125;&#125;&#x27;,
                &#x27;tags:&#x27;,
                &#x27;---&#x27;
            ].join(&#x27;\n&#x27;)
        &#125;;
    &#125;
    _listDir() &#123;
        const &#123; scaffoldDir &#125; = this;
        return (0, hexo_fs_1.exists)(scaffoldDir).then(exist =&gt; &#123;
            if (!exist)
                return [];
            return (0, hexo_fs_1.listDir)(scaffoldDir, &#123;
                ignorePattern: /^_|\/_/
            &#125;);
        &#125;).map(item =&gt; (&#123;
            name: item.substring(0, item.length - (0, path_1.extname)(item).length),
            path: (0, path_1.join)(scaffoldDir, item)
        &#125;));
    &#125;
    _getScaffold(name) &#123;
        return this._listDir().then(list =&gt; list.find(item =&gt; item.name === name));
    &#125;
    get(name, callback) &#123;
        return this._getScaffold(name).then(item =&gt; &#123;
            if (item) &#123;
                return (0, hexo_fs_1.readFile)(item.path);
            &#125;
            return this.defaults[name];
        &#125;).asCallback(callback);
    &#125;
    set(name, content, callback) &#123;
        const &#123; scaffoldDir &#125; = this;
        return this._getScaffold(name).then(item =&gt; &#123;
            let path = item ? item.path : (0, path_1.join)(scaffoldDir, name);
            if (!(0, path_1.extname)(path))
                path += &#x27;.md&#x27;;
            return (0, hexo_fs_1.writeFile)(path, content);
        &#125;).asCallback(callback);
    &#125;
    remove(name, callback) &#123;
        return this._getScaffold(name).then(item =&gt; &#123;
            if (!item)
                return;
            return (0, hexo_fs_1.unlink)(item.path);
        &#125;).asCallback(callback);
    &#125;
&#125;
module.exports = Scaffold;
//# sourceMappingURL=scaffold.js.map</code></pre>
<p><code>Scaffold</code> 类在 Hexo 框架中用于管理 Scaffold 模板文件，也就是脚手架文件。脚手架是用于生成新文章或页面的默认模板。</p>
<ul>
<li><code>constructor(context)</code>：初始化了 <code>scaffoldDir</code> 属性，指定脚手架文件所在的目录。它还定义了一个 <code>defaults</code> 对象，包含了默认的脚手架内容。</li>
<li><code>_listDir()</code>：用于列出 <code>scaffoldDir</code> 目录下的所有脚手架文件。它会忽略以下划线开头的文件或目录。</li>
<li><code>_getScaffold(name)</code>：根据给定的名称获取对应的脚手架文件信息。
<ul>
<li>先调用 <code>_listDir()</code> 方法获取所有脚手架文件，然后查找名称匹配的文件。</li>
</ul>
</li>
<li><code>get(name, callback)</code>：用于获取指定名称的脚手架内容。
<ul>
<li>如果找到对应的文件，它会读取并返回文件内容。如果没有找到，它会返回 <code>defaults</code> 对象中对应的默认脚手架内容。</li>
</ul>
</li>
<li><code>set(name, content, callback)</code>：用于设置或创建一个新的脚手架文件。
<ul>
<li>首先检查是否已经存在同名的文件，如果存在就使用原有路径，否则就在 <code>scaffoldDir</code> 目录下创建新文件（文件扩展名默认为 <code>.md</code>）。</li>
</ul>
</li>
<li><code>remove(name, callback)</code>：用于删除一个脚手架文件。它会查找对应名称的文件，如果存在则将其删除。</li>
</ul>
<h4 id="数据库"><a class="markdownIt-Anchor" href="#数据库"></a> 数据库</h4>
<pre><code class="language-javascript">this._dbLoaded = false;
this._isGenerating = false;
// If `output` is provided, use that as the
// root for saving the db. Otherwise default to `base`.
const dbPath = args.output || base;
if (/^(init|new|g|publish|s|deploy|render|migrate)/.test(this.env.cmd)) &#123;
  this.log.d(`Writing database to $&#123;(0, path_1.join)(dbPath, &#x27;db.json&#x27;)&#125;`);
&#125;</code></pre>
<ol>
<li>初始化两个内部状态标志，用于跟踪数据库是否已经加载（<code>_dbLoaded</code>）和网站是否正在生成（<code>_isGenerating</code>）。</li>
<li>确定数据库文件将要被保存在的路径。如果执行 Hexo 命令时提供了 <code>output</code> 参数，那么数据库就会被保存在该输出路径下；不然就保存在项目根目录下。</li>
<li>接着检查当前执行的 Hexo 命令是否属于 <code>init</code>、<code>new</code>、<code>g</code>、<code>publish</code>、<code>deploy</code>、<code>render</code> 或者 <code>migrate</code>。如果是，就打印说数据库文件被写入到哪里去了。</li>
</ol>
<pre><code class="language-javascript">this.database = new warehouse_1.default(&#123;
  version: dbVersion,
  path: (0, path_1.join)(dbPath, &#x27;db.json&#x27;)
&#125;);</code></pre>
<p>Hexo 初始化和配置数据库，实例化过程中传入了一个配置对象：</p>
<ul>
<li><code>version</code>：数据库的版本号。在 <code>index.js</code> 的最上方能找到：<pre><code class="language-javascript">const dbVersion = 1;</code></pre>
</li>
<li><code>path</code>：数据库文件的保存路径，由先前定义的 <code>dbPath</code> 和文件名 <code>db.json</code> 拼接而成。</li>
</ul>
<p>此处实例化用到了 <code>warehouse</code> 库。这是一个轻量级的数据存储库，主要用于 Node.js 应用程序中处理 JSON 数据。它提供了一种简单的方式来定义、存储和检索模型数据，类似于一个迷你数据库或 ORM（对象关系映射）。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/dundalek/warehouse"><img src="https://gh-card.dev/repos/dundalek/warehouse.svg" alt="dundalek/warehouse - GitHub"></a></p>
<h4 id="多配置文件路径管理"><a class="markdownIt-Anchor" href="#多配置文件路径管理"></a> 多配置文件路径管理</h4>
<pre><code class="language-javascript">const mcp = (0, multi_config_path_1.default)(this);</code></pre>
<pre><code class="language-javascript">&quot;use strict&quot;;
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) &#123;
    return (mod &amp;&amp; mod.__esModule) ? mod : &#123; &quot;default&quot;: mod &#125;;
&#125;;
const path_1 = require(&quot;path&quot;);
const hexo_fs_1 = require(&quot;hexo-fs&quot;);
const js_yaml_1 = __importDefault(require(&quot;js-yaml&quot;));
const hexo_util_1 = require(&quot;hexo-util&quot;);
module.exports = (ctx) =&gt; function multiConfigPath(base, configPaths, outputDir) &#123;
    const &#123; log &#125; = ctx;
    const defaultPath = (0, path_1.join)(base, &#x27;_config.yml&#x27;);
    if (!configPaths) &#123;
        log.w(&#x27;No config file entered.&#x27;);
        return (0, path_1.join)(base, &#x27;_config.yml&#x27;);
    &#125;
    let paths;
    // determine if comma or space separated
    if (configPaths.includes(&#x27;,&#x27;)) &#123;
        paths = configPaths.replace(&#x27; &#x27;, &#x27;&#x27;).split(&#x27;,&#x27;);
    &#125;
    else &#123;
        // only one config
        let configPath = (0, path_1.isAbsolute)(configPaths) ? configPaths : (0, path_1.resolve)(base, configPaths);
        if (!(0, hexo_fs_1.existsSync)(configPath)) &#123;
            log.w(`Config file $&#123;configPaths&#125; not found, using default.`);
            configPath = defaultPath;
        &#125;
        return configPath;
    &#125;
    const numPaths = paths.length;
    // combine files
    let combinedConfig = &#123;&#125;;
    let count = 0;
    for (let i = 0; i &lt; numPaths; i++) &#123;
        const configPath = (0, path_1.isAbsolute)(paths[i]) ? paths[i] : (0, path_1.join)(base, paths[i]);
        if (!(0, hexo_fs_1.existsSync)(configPath)) &#123;
            log.w(`Config file $&#123;paths[i]&#125; not found.`);
            continue;
        &#125;
        // files read synchronously to ensure proper overwrite order
        const file = (0, hexo_fs_1.readFileSync)(configPath);
        const ext = (0, path_1.extname)(paths[i]).toLowerCase();
        if (ext === &#x27;.yml&#x27;) &#123;
            combinedConfig = (0, hexo_util_1.deepMerge)(combinedConfig, js_yaml_1.default.load(file));
            count++;
        &#125;
        else if (ext === &#x27;.json&#x27;) &#123;
            combinedConfig = (0, hexo_util_1.deepMerge)(combinedConfig, js_yaml_1.default.load(file, &#123; json: true &#125;));
            count++;
        &#125;
        else &#123;
            log.w(`Config file $&#123;paths[i]&#125; not supported type.`);
        &#125;
    &#125;
    if (count === 0) &#123;
        log.e(&#x27;No config files found. Using _config.yml.&#x27;);
        return defaultPath;
    &#125;
    log.i(&#x27;Config based on&#x27;, count.toString(), &#x27;files&#x27;);
    const multiconfigRoot = outputDir || base;
    const outputPath = (0, path_1.join)(multiconfigRoot, &#x27;_multiconfig.yml&#x27;);
    log.d(`Writing _multiconfig.yml to $&#123;outputPath&#125;`);
    (0, hexo_fs_1.writeFileSync)(outputPath, js_yaml_1.default.dump(combinedConfig));
    // write file and return path
    return outputPath;
&#125;;
//# sourceMappingURL=multi_config_path.js.map</code></pre>
<p><code>multiConfigPath</code> 函数用于处理 Hexo 配置文件。该函数会根据传入的配置文件路径来合并多个配置文件并生成一个新的配置文件 <code>_multiconfig.yml</code>。</p>
<p>顺带一个读取配置文件路径的参数：</p>
<pre><code class="language-javascript">this.config_path = args.config ? mcp(base, args.config, args.output)
  : (0, path_1.join)(base, &#x27;_config.yml&#x27;);</code></pre>
<p>根据用户的命令行输入和 Hexo 项目的配置，决定要读取的配置文件的路径。</p>
<h4 id="注册模型"><a class="markdownIt-Anchor" href="#注册模型"></a> 注册模型</h4>
<pre><code class="language-javascript">(0, register_models_1.default)(this);</code></pre>
<pre><code class="language-javascript">&quot;use strict&quot;;
var __createBinding = (this &amp;&amp; this.__createBinding) || (Object.create ? (function(o, m, k, k2) &#123;
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (&quot;get&quot; in desc ? !m.__esModule : desc.writable || desc.configurable)) &#123;
        desc = &#123; enumerable: true, get: function() &#123; return m[k]; &#125; &#125;;
    &#125;
    Object.defineProperty(o, k2, desc);
&#125;) : (function(o, m, k, k2) &#123;
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
&#125;));
var __setModuleDefault = (this &amp;&amp; this.__setModuleDefault) || (Object.create ? (function(o, v) &#123;
    Object.defineProperty(o, &quot;default&quot;, &#123; enumerable: true, value: v &#125;);
&#125;) : function(o, v) &#123;
    o[&quot;default&quot;] = v;
&#125;);
var __importStar = (this &amp;&amp; this.__importStar) || function (mod) &#123;
    if (mod &amp;&amp; mod.__esModule) return mod;
    var result = &#123;&#125;;
    if (mod != null) for (var k in mod) if (k !== &quot;default&quot; &amp;&amp; Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
&#125;;
const models = __importStar(require(&quot;../models&quot;));
module.exports = (ctx) =&gt; &#123;
    const db = ctx.database;
    const keys = Object.keys(models);
    for (let i = 0, len = keys.length; i &lt; len; i++) &#123;
        const key = keys[i];
        db.model(key, models[key](ctx));
    &#125;
&#125;;
//# sourceMappingURL=register_models.js.map</code></pre>
<p>上三个函数是 TypeScript 编译器在编译时生成的，用于处理 ES 模块的导入和默认导出行为。它们确保在使用 CommonJS 模块时，能正确处理 ES 模块的导入。</p>
<p>接下来导入的 <code>models</code> 模块是 <code>hexo/dist/models</code> 目录，这里使用了 <code>__importStar</code> 函数导入 <code>models</code> 模块中的所有导出，作为 <code>models</code> 对象的属性。</p>
<blockquote>
<p><code>models</code> 模块内容很多，后续会仔细讲解。</p>
</blockquote>
<p><code>register_models</code> 模块导出一个函数，该函数接收一个 <code>ctx</code> 参数，并从 <code>ctx</code> 对象中获取数据库实例 <code>db</code>、获取 <code>models</code> 对象的所有键，遍历这些键，为每个模型在数据库中注册一个模型。</p>
<p>主要功能是导入所有的模型，并将这些模型注册到数据库中。</p>
<h4 id="源文件管理"><a class="markdownIt-Anchor" href="#源文件管理"></a> 源文件管理</h4>
<pre><code class="language-javascript">this.source = new source_1.default(this);</code></pre>
<pre><code class="language-javascript">&quot;use strict&quot;;
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) &#123;
    return (mod &amp;&amp; mod.__esModule) ? mod : &#123; &quot;default&quot;: mod &#125;;
&#125;;
const box_1 = __importDefault(require(&quot;../box&quot;));
class Source extends box_1.default &#123;
    constructor(ctx) &#123;
        super(ctx, ctx.source_dir);
        this.processors = ctx.extend.processor.list();
    &#125;
&#125;
module.exports = Source;
//# sourceMappingURL=source.js.map</code></pre>
<p><code>Source</code> 类继承自 <code>Box</code> 类，所以先看一眼 <code>Box</code> 类：</p>
<pre><code class="language-javascript">&quot;use strict&quot;;
var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) &#123;
    function adopt(value) &#123; return value instanceof P ? value : new P(function (resolve) &#123; resolve(value); &#125;); &#125;
    return new (P || (P = Promise))(function (resolve, reject) &#123;
        function fulfilled(value) &#123; try &#123; step(generator.next(value)); &#125; catch (e) &#123; reject(e); &#125; &#125;
        function rejected(value) &#123; try &#123; step(generator[&quot;throw&quot;](value)); &#125; catch (e) &#123; reject(e); &#125; &#125;
        function step(result) &#123; result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); &#125;
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    &#125;);
&#125;;
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) &#123;
    return (mod &amp;&amp; mod.__esModule) ? mod : &#123; &quot;default&quot;: mod &#125;;
&#125;;
Object.defineProperty(exports, &quot;__esModule&quot;, &#123; value: true &#125;);
const path_1 = require(&quot;path&quot;);
const bluebird_1 = __importDefault(require(&quot;bluebird&quot;));
const file_1 = __importDefault(require(&quot;./file&quot;));
const hexo_util_1 = require(&quot;hexo-util&quot;);
const hexo_fs_1 = require(&quot;hexo-fs&quot;);
const picocolors_1 = require(&quot;picocolors&quot;);
const events_1 = require(&quot;events&quot;);
const micromatch_1 = require(&quot;micromatch&quot;);
const defaultPattern = new hexo_util_1.Pattern(() =&gt; (&#123;&#125;));
class Box extends events_1.EventEmitter &#123;
    constructor(ctx, base, options) &#123;
        super();
        this.options = Object.assign(&#123;
            persistent: true,
            awaitWriteFinish: &#123;
                stabilityThreshold: 200
            &#125;
        &#125;, options);
        if (!base.endsWith(path_1.sep)) &#123;
            base += path_1.sep;
        &#125;
        this.context = ctx;
        this.base = base;
        this.processors = [];
        this._processingFiles = &#123;&#125;;
        this.watcher = null;
        this.Cache = ctx.model(&#x27;Cache&#x27;);
        this.File = this._createFileClass();
        let targets = this.options.ignored || [];
        if (ctx.config.ignore &amp;&amp; ctx.config.ignore.length) &#123;
            targets = targets.concat(ctx.config.ignore);
        &#125;
        this.ignore = targets;
        this.options.ignored = targets.map(s =&gt; toRegExp(ctx, s)).filter(x =&gt; x);
    &#125;
    _createFileClass() &#123;
        const ctx = this.context;
        class _File extends file_1.default &#123;
            render(options) &#123;
                return ctx.render.render(&#123;
                    path: this.source
                &#125;, options);
            &#125;
            renderSync(options) &#123;
                return ctx.render.renderSync(&#123;
                    path: this.source
                &#125;, options);
            &#125;
        &#125;
        _File.prototype.box = this;
        return _File;
    &#125;
    addProcessor(pattern, fn) &#123;
        if (!fn &amp;&amp; typeof pattern === &#x27;function&#x27;) &#123;
            fn = pattern;
            pattern = defaultPattern;
        &#125;
        if (typeof fn !== &#x27;function&#x27;)
            throw new TypeError(&#x27;fn must be a function&#x27;);
        if (!(pattern instanceof hexo_util_1.Pattern))
            pattern = new hexo_util_1.Pattern(pattern);
        this.processors.push(&#123;
            pattern,
            process: fn
        &#125;);
    &#125;
    _readDir(base, prefix = &#x27;&#x27;) &#123;
        const &#123; context: ctx &#125; = this;
        const results = [];
        return readDirWalker(ctx, base, results, this.ignore, prefix)
            .return(results)
            .map(path =&gt; this._checkFileStatus(path))
            .map(file =&gt; this._processFile(file.type, file.path).return(file.path));
    &#125;
    _checkFileStatus(path) &#123;
        const &#123; Cache, context: ctx &#125; = this;
        const src = (0, path_1.join)(this.base, path);
        return Cache.compareFile(src.substring(ctx.base_dir.length), () =&gt; getHash(src), () =&gt; (0, hexo_fs_1.stat)(src)).then(result =&gt; (&#123;
            type: result.type,
            path
        &#125;));
    &#125;
    process(callback) &#123;
        const &#123; base, Cache, context: ctx &#125; = this;
        return (0, hexo_fs_1.stat)(base).then(stats =&gt; &#123;
            if (!stats.isDirectory())
                return;
            // Check existing files in cache
            const relativeBase = base.substring(ctx.base_dir.length);
            const cacheFiles = Cache.filter(item =&gt; item._id.startsWith(relativeBase)).map(item =&gt; item._id.substring(relativeBase.length));
            // Handle deleted files
            return this._readDir(base)
                .then((files) =&gt; cacheFiles.filter((path) =&gt; !files.includes(path)))
                .map((path) =&gt; this._processFile(file_1.default.TYPE_DELETE, path));
        &#125;).catch(err =&gt; &#123;
            if (err &amp;&amp; err.code !== &#x27;ENOENT&#x27;)
                throw err;
        &#125;).asCallback(callback);
    &#125;
    _processFile(type, path) &#123;
        if (this._processingFiles[path]) &#123;
            return bluebird_1.default.resolve();
        &#125;
        this._processingFiles[path] = true;
        const &#123; base, File, context: ctx &#125; = this;
        this.emit(&#x27;processBefore&#x27;, &#123;
            type,
            path
        &#125;);
        return bluebird_1.default.reduce(this.processors, (count, processor) =&gt; &#123;
            // patten supports *nix style path only, replace backslashes on Windows
            const params = processor.pattern.match(escapeBackslash(path));
            if (!params)
                return count;
            const file = new File(&#123;
                // source is used for file system path, keep backslashes on Windows
                source: (0, path_1.join)(base, path),
                // path is used for URL path, replace backslashes on Windows
                path: escapeBackslash(path),
                params,
                type
            &#125;);
            return Reflect.apply(bluebird_1.default.method(processor.process), ctx, [file])
                .thenReturn(count + 1);
        &#125;, 0).then(count =&gt; &#123;
            if (count) &#123;
                ctx.log.debug(&#x27;Processed: %s&#x27;, (0, picocolors_1.magenta)(path));
            &#125;
            this.emit(&#x27;processAfter&#x27;, &#123;
                type,
                path
            &#125;);
        &#125;).catch(err =&gt; &#123;
            ctx.log.error(&#123; err &#125;, &#x27;Process failed: %s&#x27;, (0, picocolors_1.magenta)(path));
        &#125;).finally(() =&gt; &#123;
            this._processingFiles[path] = false;
        &#125;).thenReturn(path);
    &#125;
    watch(callback) &#123;
        if (this.isWatching()) &#123;
            return bluebird_1.default.reject(new Error(&#x27;Watcher has already started.&#x27;)).asCallback(callback);
        &#125;
        const &#123; base &#125; = this;
        function getPath(path) &#123;
            return path.substring(base.length);
        &#125;
        return this.process().then(() =&gt; (0, hexo_fs_1.watch)(base, this.options)).then(watcher =&gt; &#123;
            this.watcher = watcher;
            watcher.on(&#x27;add&#x27;, path =&gt; &#123;
                this._processFile(file_1.default.TYPE_CREATE, getPath(path));
            &#125;);
            watcher.on(&#x27;change&#x27;, path =&gt; &#123;
                this._processFile(file_1.default.TYPE_UPDATE, getPath(path));
            &#125;);
            watcher.on(&#x27;unlink&#x27;, path =&gt; &#123;
                this._processFile(file_1.default.TYPE_DELETE, getPath(path));
            &#125;);
            watcher.on(&#x27;addDir&#x27;, path =&gt; &#123;
                let prefix = getPath(path);
                if (prefix)
                    prefix += path_1.sep;
                this._readDir(path, prefix);
            &#125;);
        &#125;).asCallback(callback);
    &#125;
    unwatch() &#123;
        if (!this.isWatching())
            return;
        this.watcher.close();
        this.watcher = null;
    &#125;
    isWatching() &#123;
        return Boolean(this.watcher);
    &#125;
&#125;
function escapeBackslash(path) &#123;
    // Replace backslashes on Windows
    return path.replace(/\\/g, &#x27;/&#x27;);
&#125;
function getHash(path) &#123;
    const src = (0, hexo_fs_1.createReadStream)(path);
    const hasher = (0, hexo_util_1.createSha1Hash)();
    const finishedPromise = new bluebird_1.default((resolve, reject) =&gt; &#123;
        src.once(&#x27;error&#x27;, reject);
        src.once(&#x27;end&#x27;, resolve);
    &#125;);
    src.on(&#x27;data&#x27;, chunk =&gt; &#123; hasher.update(chunk); &#125;);
    return finishedPromise.then(() =&gt; hasher.digest(&#x27;hex&#x27;));
&#125;
function toRegExp(ctx, arg) &#123;
    if (!arg)
        return null;
    if (typeof arg !== &#x27;string&#x27;) &#123;
        ctx.log.warn(&#x27;A value of &quot;ignore:&quot; section in &quot;_config.yml&quot; is not invalid (not a string)&#x27;);
        return null;
    &#125;
    const result = (0, micromatch_1.makeRe)(arg);
    if (!result) &#123;
        ctx.log.warn(&#x27;A value of &quot;ignore:&quot; section in &quot;_config.yml&quot; can not be converted to RegExp:&#x27; + arg);
        return null;
    &#125;
    return result;
&#125;
function isIgnoreMatch(path, ignore) &#123;
    return path &amp;&amp; ignore &amp;&amp; ignore.length &amp;&amp; (0, micromatch_1.isMatch)(path, ignore);
&#125;
function readDirWalker(ctx, base, results, ignore, prefix) &#123;
    if (isIgnoreMatch(base, ignore))
        return bluebird_1.default.resolve();
    return bluebird_1.default.map((0, hexo_fs_1.readdir)(base).catch(err =&gt; &#123;
        ctx.log.error(&#123; err &#125;, &#x27;Failed to read directory: %s&#x27;, base);
        if (err &amp;&amp; err.code === &#x27;ENOENT&#x27;)
            return [];
        throw err;
    &#125;), (path) =&gt; __awaiter(this, void 0, void 0, function* () &#123;
        const fullpath = (0, path_1.join)(base, path);
        const stats = yield (0, hexo_fs_1.stat)(fullpath).catch(err =&gt; &#123;
            ctx.log.error(&#123; err &#125;, &#x27;Failed to stat file: %s&#x27;, fullpath);
            if (err &amp;&amp; err.code === &#x27;ENOENT&#x27;)
                return null;
            throw err;
        &#125;);
        const prefixPath = `$&#123;prefix&#125;$&#123;path&#125;`;
        if (stats) &#123;
            if (stats.isDirectory()) &#123;
                return readDirWalker(ctx, fullpath, results, ignore, prefixPath + path_1.sep);
            &#125;
            if (!isIgnoreMatch(fullpath, ignore)) &#123;
                results.push(prefixPath);
            &#125;
        &#125;
    &#125;));
&#125;
exports.default = Box;
//# sourceMappingURL=index.js.map</code></pre>
<p>部分辅助函数：</p>
<ul>
<li><code>__awaiter</code>：用于处理异步函数和生成器函数，使得可以使用 <code>async/await</code> 语法。</li>
<li><code>__importDefault</code>：用于处理默认导入。</li>
<li><code>escapeBackslash</code>：将路径中的反斜杠替换为斜杠。</li>
<li><code>getHash</code>：生成文件的 SHA-1 哈希值。</li>
<li><code>toRegExp</code>：将字符串转换为正则表达式。</li>
<li><code>isIgnoreMatch</code>：检查路径是否与忽略模式匹配。</li>
<li><code>readDirWalker</code>：递归读取目录，并收集所有符合条件的文件路径。</li>
</ul>
<p><code>box/index.js</code> 也导入了一个 <code>file.js</code> 文件，该文件定义了一个 <code>File</code> 类，用来表示文件对象，并提供了一些方法来读取和获取文件状态：</p>
<pre><code class="language-javascript">&quot;use strict&quot;;
const hexo_fs_1 = require(&quot;hexo-fs&quot;);
class File &#123;
    constructor(&#123; source, path, params, type &#125;) &#123;
        this.source = source;
        this.path = path;
        this.params = params;
        this.type = type;
    &#125;
    read(options) &#123;
        return (0, hexo_fs_1.readFile)(this.source, options);
    &#125;
    readSync(options) &#123;
        return (0, hexo_fs_1.readFileSync)(this.source, options);
    &#125;
    stat() &#123;
        return (0, hexo_fs_1.stat)(this.source);
    &#125;
    statSync() &#123;
        return (0, hexo_fs_1.statSync)(this.source);
    &#125;
&#125;
File.TYPE_CREATE = &#x27;create&#x27;;
File.TYPE_UPDATE = &#x27;update&#x27;;
File.TYPE_SKIP = &#x27;skip&#x27;;
File.TYPE_DELETE = &#x27;delete&#x27;;
module.exports = File;
//# sourceMappingURL=file.js.map</code></pre>
<ul>
<li><code>read(options)</code>：异步读取文件内容，返回一个 Promise。</li>
<li><code>readSync(options)</code>：同步读取文件内容，返回文件内容。</li>
<li><code>stat()</code>：异步获取文件状态，返回一个 Promise。</li>
<li><code>statSync()</code>：同步获取文件状态，返回文件状态。</li>
<li>文件类型常量：明确表示文件的操作类型。</li>
</ul>
<p><code>Box</code> 类也是继承自 <code>EventEmitter</code>。</p>
<p>主要的属性和方法：</p>
<ul>
<li>构造函数：初始化 Box 类的实例，设置：
<ul>
<li><code>options</code>：默认选项和用户传入的选项合并。</li>
<li><code>context</code>：上下文对象。</li>
<li><code>base</code>：基础路径。</li>
<li><code>processors</code>：处理器列表。</li>
<li><code>_processingFiles</code>：正在处理的文件。</li>
<li><code>watcher</code>：文件监视器。</li>
<li><code>Cache</code>：缓存模型。</li>
<li><code>File</code>：文件类。</li>
<li><code>ignore</code>：忽略模式。</li>
</ul>
</li>
<li><code>_createFileClass</code>：创建一个文件类，用于处理文件的渲染操作。</li>
<li><code>addProcessor</code>：添加一个处理器，用于处理特定模式的文件。</li>
<li><code>_readDir</code>：读取目录，并递归处理所有文件。</li>
<li><code>_checkFileStatus</code>：检查文件状态，比较缓存文件和实际文件。</li>
<li><code>process</code>：处理目录中的所有文件。</li>
<li><code>_processFile</code>：处理单个文件，根据文件类型执行处理器。</li>
<li><code>watch</code>：监视目录中的文件变化，并在文件添加、修改或删除时触发相应的处理。</li>
<li><code>unwatch</code>：停止监视目录。</li>
<li><code>isWatching</code>：检查是否正在监视目录。</li>
</ul>
<p><code>Box</code> 类的更多详情可见 <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/api/box">Hexo 官方文档</a>。</p>
<p>现在再来看 <code>Source</code> 类。它继承自 <code>Box</code> 类，拥有着 <code>Box</code> 类的所有属性和方法。<code>Box</code> 类提供了文件读取、监视、处理等能力。而 <code>Source</code> 类在此基础上，专注于处理特定于源文件的逻辑。</p>
<h4 id="主题"><a class="markdownIt-Anchor" href="#主题"></a> 主题</h4>
<pre><code class="language-javascript">this.theme = new theme_1.default(this);</code></pre>
<div class="danger">
<p><code>Theme</code> 类被定义在 <code>hexo/dist/theme</code> 中，未来会详细说。目前只讲 <code>index.js</code> 的大致逻辑。</p>
</div>
<p><code>Theme</code> 类是 Hexo 中负责管理主题的核心模块。</p>
<blockquote>
<p>可见 <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/api/themes">Hexo 官方文档</a>。</p>
</blockquote>
<pre><code class="language-javascript">&quot;use strict&quot;;
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) &#123;
    return (mod &amp;&amp; mod.__esModule) ? mod : &#123; &quot;default&quot;: mod &#125;;
&#125;;
const path_1 = require(&quot;path&quot;);
const box_1 = __importDefault(require(&quot;../box&quot;));
const view_1 = __importDefault(require(&quot;./view&quot;));
const hexo_i18n_1 = __importDefault(require(&quot;hexo-i18n&quot;));
const config_1 = require(&quot;./processors/config&quot;);
const i18n_1 = require(&quot;./processors/i18n&quot;);
const source_1 = require(&quot;./processors/source&quot;);
const view_2 = require(&quot;./processors/view&quot;);
class Theme extends box_1.default &#123;
    constructor(ctx, options) &#123;
        super(ctx, ctx.theme_dir, options);
        this.config = &#123;&#125;;
        this.views = &#123;&#125;;
        this.processors = [
            config_1.config,
            i18n_1.i18n,
            source_1.source,
            view_2.view
        ];
        let languages = ctx.config.language;
        if (!Array.isArray(languages))
            languages = [languages];
        languages.push(&#x27;default&#x27;);
        this.i18n = new hexo_i18n_1.default(&#123;
            languages: [...new Set(languages.filter(Boolean))]
        &#125;);
        class _View extends view_1.default &#123;
        &#125;
        this.View = _View;
        _View.prototype._theme = this;
        _View.prototype._render = ctx.render;
        _View.prototype._helper = ctx.extend.helper;
    &#125;
    getView(path) &#123;
        // Replace backslashes on Windows
        path = path.replace(/\\/g, &#x27;/&#x27;);
        const ext = (0, path_1.extname)(path);
        const name = path.substring(0, path.length - ext.length);
        const views = this.views[name];
        if (!views)
            return;
        if (ext) &#123;
            return views[ext];
        &#125;
        return views[Object.keys(views)[0]];
    &#125;
    setView(path, data) &#123;
        const ext = (0, path_1.extname)(path);
        const name = path.substring(0, path.length - ext.length);
        this.views[name] = this.views[name] || &#123;&#125;;
        const views = this.views[name];
        views[ext] = new this.View(path, data);
    &#125;
    removeView(path) &#123;
        const ext = (0, path_1.extname)(path);
        const name = path.substring(0, path.length - ext.length);
        const views = this.views[name];
        if (!views)
            return;
        views[ext] = undefined;
    &#125;
&#125;
module.exports = Theme;
//# sourceMappingURL=index.js.map</code></pre>
<p><code>Theme</code> 类同样继承自 <code>Box</code> 类：</p>
<ul>
<li><code>constructor(ctx, options)</code>：构造函数接受上下文对象 <code>ctx</code> 和选项 <code>options</code>，调用父类 <code>box_1.default</code> 的构造函数。</li>
<li>初始化 <code>config</code> 和 <code>views</code> 属性为空对象。</li>
<li><code>processors</code>：设置处理器数组，包括配置、国际化、源文件和视图处理器。</li>
<li>初始化多语言支持，确保 <code>languages</code> 是数组，并添加 <code>default</code> 语言。使用 <code>hexo-i18n</code> 库创建 <code>i18n</code> 对象。</li>
<li>定义一个新的 <code>_View</code> 类，继承自 <code>view_1.default</code>，并在其原型上添加 <code>_theme</code>、<code>_render</code> 和 <code>_helper</code> 属性。</li>
</ul>
<p>撇开本地文件导入，这里的 <code>hexo-i18n</code> 是 Hexo 自己的 i18n 模块。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo-i18n"><img src="https://gh-card.dev/repos/hexojs/hexo-i18n.svg" alt="hexojs/hexo-i18n - GitHub"></a></p>
<blockquote>
<p>i18n 的全程是 <strong>Internationalization</strong>（国际化），是指在设计软件、将软件与特定语言及地区脱钩的过程。由于英文单字长度过长，所以常被简称为 i18n（18意味着在 Internationalization 这个单字中，i 和 n 之间有 18 个字母。</p>
</blockquote>
<p><code>Theme</code> 类也有以下方法：</p>
<ul>
<li><code>getView(path)</code>：根据给定路径获取视图。</li>
<li><code>setView(path, data)</code> 设置指定路径的 <code>View</code> 内容。</li>
<li><code>removeView(path)</code> 移除指定路径的 <code>View</code>。</li>
</ul>
<p>通过实例化 <code>Theme</code> 类，Hexo 可以获得一个用于操作当前主题的对象，从而正确地渲染和生成静态页面。</p>
<blockquote>
<p>视图（<code>View</code>）在 Hexo 中是用于渲染页面内容的模板文件。通常使用模板引擎语法编写，如 Swig、Pug 等，允许在模板中嵌入动态数据和逻辑。</p>
<p>视图主要有以下几种类型：</p>
<ol>
<li>布局（Layout）：定义了页面的基本结构，如 HTML 头部、导航栏、页脚等通用部分。所有其他视图都将被渲染到布局视图中的特定位置。</li>
<li>包含（Partial）：可重用的模板片段，通常用于渲染页面的某一部分，如文章列表、评论区等。它们可以在其他视图中被引入和渲染。</li>
<li>页面（Page）：用于渲染特定的页面内容，如文章、分类、标签等。它们通常会引入布局视图和其他所需的包含视图。</li>
<li>助手（Helper）：一些辅助函数，用于在模板中执行特定的逻辑或操作，如格式化日期、生成链接等。</li>
</ol>
</blockquote>
<h4 id="本地数据"><a class="markdownIt-Anchor" href="#本地数据"></a> 本地数据</h4>
<pre><code class="language-javascript">this.locals = new locals_1.default();</code></pre>
<p><code>Locals</code> 类用于管理和缓存局部变量：</p>
<pre><code class="language-javascript">&quot;use strict&quot;;
const hexo_util_1 = require(&quot;hexo-util&quot;);
class Locals &#123;
    constructor() &#123;
        this.cache = new hexo_util_1.Cache();
        this.getters = &#123;&#125;;
    &#125;
    get(name) &#123;
        if (typeof name !== &#x27;string&#x27;)
            throw new TypeError(&#x27;name must be a string!&#x27;);
        return this.cache.apply(name, () =&gt; &#123;
            const getter = this.getters[name];
            if (!getter)
                return;
            return getter();
        &#125;);
    &#125;
    set(name, value) &#123;
        if (typeof name !== &#x27;string&#x27;)
            throw new TypeError(&#x27;name must be a string!&#x27;);
        if (value == null)
            throw new TypeError(&#x27;value is required!&#x27;);
        const getter = typeof value === &#x27;function&#x27; ? value : () =&gt; value;
        this.getters[name] = getter;
        this.cache.del(name);
        return this;
    &#125;
    remove(name) &#123;
        if (typeof name !== &#x27;string&#x27;)
            throw new TypeError(&#x27;name must be a string!&#x27;);
        this.getters[name] = null;
        this.cache.del(name);
        return this;
    &#125;
    invalidate() &#123;
        this.cache.flush();
        return this;
    &#125;
    toObject() &#123;
        const result = &#123;&#125;;
        const keys = Object.keys(this.getters);
        for (let i = 0, len = keys.length; i &lt; len; i++) &#123;
            const key = keys[i];
            const item = this.get(key);
            if (item != null)
                result[key] = item;
        &#125;
        return result;
    &#125;
&#125;
module.exports = Locals;
//# sourceMappingURL=locals.js.map</code></pre>
<p><code>Locals</code> 类有两个属性：</p>
<ul>
<li><code>cache</code>：使用 <code>hexo-util</code> 模块的 <code>Cache</code> 类实例化缓存对象。</li>
<li><code>getters</code>：初始化一个空对象，用于存储 <code>getter</code> 函数。</li>
</ul>
<p><code>Locals</code> 类也有以下方法：</p>
<ul>
<li><code>get(name)</code> 获取指定名称的本地数据。</li>
<li><code>set(name, value)</code> 设置指定名称的本地数据。</li>
<li><code>remove(name)</code> 移除指定名称的本地数据。</li>
<li><code>invalidate()</code> 清空缓存。</li>
<li><code>toObject()</code> 将本地数据转换为普通对象。</li>
</ul>
<p><code>Locals</code> 类是 Hexo 中用于管理本地数据的模块。本地数据在 Hexo 插件开发中意外重要，后续会详细讲解。</p>
<blockquote>
<p>暂且，请看 <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/api/locals">Hexo 官方文档</a>。</p>
</blockquote>
<h2 id="本地数据绑定"><a class="markdownIt-Anchor" href="#本地数据绑定"></a> 本地数据绑定</h2>
<p>构造函数的最后一行是用来绑定本地数据的：</p>
<pre><code class="language-javascript">this._bindLocals();</code></pre>
<pre><code class="language-javascript">_bindLocals() &#123;
  const db = this.database;
  const &#123; locals &#125; = this;
  locals.set(&#x27;posts&#x27;, () =&gt; &#123;
    const query = &#123;&#125;;
    if (!this.config.future) &#123;
      query.date = &#123; $lte: Date.now() &#125;;
    &#125;
    if (!this._showDrafts()) &#123;
      query.published = true;
    &#125;
    return db.model(&#x27;Post&#x27;).find(query);
  &#125;);
  locals.set(&#x27;pages&#x27;, () =&gt; &#123;
    const query = &#123;&#125;;
    if (!this.config.future) &#123;
      query.date = &#123; $lte: Date.now() &#125;;
    &#125;
    return db.model(&#x27;Page&#x27;).find(query);
  &#125;);
  locals.set(&#x27;categories&#x27;, () =&gt; &#123;
    // Ignore categories with zero posts
    return db.model(&#x27;Category&#x27;).filter(category =&gt; category.length);
  &#125;);
  locals.set(&#x27;tags&#x27;, () =&gt; &#123;
    // Ignore tags with zero posts
    return db.model(&#x27;Tag&#x27;).filter(tag =&gt; tag.length);
  &#125;);
  locals.set(&#x27;data&#x27;, () =&gt; &#123;
    const obj = &#123;&#125;;
    db.model(&#x27;Data&#x27;).forEach(data =&gt; &#123;
      obj[data._id] = data.data;
    &#125;);
    return obj;
  &#125;);
&#125;</code></pre>
<p>首先获取 <code>Hexo</code> 实例的数据库对象 <code>this.database</code>，接着使用对象解构赋值的语法从 <code>this</code> 对象中提取 <code>locals</code> 属性的值。<code>this</code> 指向的是当前执行上下文中的对象实例，在这里，<code>this</code> 是 <code>Hexo</code> 实例本身。</p>
<p><code>const &#123; locals &#125; = this;</code> 相当于这行代码：</p>
<pre><code class="language-javascript">const locals = this.locals;</code></pre>
<p>通过调用 <code>locals.set()</code> 方法，为不同的本地数据设置了获取器函数。当其他地方访问这些本地数据时，相应的获取器函数将被执行，从数据库中查询并返回所需的数据。</p>
<p>具体来说，这个方法设置了以下几个本地数据及其获取器：</p>
<ul>
<li><code>posts</code>：获取所有已发布且不是未来日期的文章。如果 <code>config.future</code> 设置为 <code>true</code>，则也包括未来日期的文章。如果 <code>_showDrafts()</code> 返回 <code>true</code>，则也包括草稿文章。</li>
<li><code>pages</code>：获取所有已发布且不是未来日期的页面。如果 <code>config.future</code> 设置为 <code>true</code>，则也包括未来日期的页面。</li>
<li><code>categories</code>：获取所有包含文章的分类。</li>
<li><code>tags</code>：获取所有包含文章的标签。</li>
<li><code>data</code>：获取所有自定义数据。</li>
</ul>
<h2 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h2>
<pre><code class="language-javascript">init() &#123;
  this.log.debug(&#x27;Hexo version: %s&#x27;, (0, picocolors_1.magenta)(this.version));
  this.log.debug(&#x27;Working directory: %s&#x27;, (0, picocolors_1.magenta)((0, tildify_1.default)(this.base_dir)));
  // Load internal plugins
  require(&#x27;../plugins/console&#x27;)(this);
  require(&#x27;../plugins/filter&#x27;)(this);
  require(&#x27;../plugins/generator&#x27;)(this);
  require(&#x27;../plugins/helper&#x27;)(this);
  require(&#x27;../plugins/highlight&#x27;)(this);
  require(&#x27;../plugins/injector&#x27;)(this);
  require(&#x27;../plugins/processor&#x27;)(this);
  require(&#x27;../plugins/renderer&#x27;)(this);
  require(&#x27;../plugins/tag&#x27;).default(this);
  // Load config
  return bluebird_1.default.each([
    &#x27;update_package&#x27;, // Update package.json
    &#x27;load_config&#x27;, // Load config
    &#x27;load_theme_config&#x27;, // Load alternate theme config
    &#x27;load_plugins&#x27; // Load external plugins &amp; scripts
  ], name =&gt; require(`./$&#123;name&#125;`)(this)).then(() =&gt; this.execFilter(&#x27;after_init&#x27;, null, &#123; context: this &#125;)).then(() =&gt; &#123;
    // Ready to go!
    this.emit(&#x27;ready&#x27;);
  &#125;);
&#125;</code></pre>
<p><code>init</code> 方法负责进行初始化工作：</p>
<ol>
<li>打印 Hexo 版本和工作目录信息到控制台，使用 <code>picocolors</code> 库为版本和目录路径上色。</li>
<li>加载内部插件。</li>
<li>执行一系列初始化步骤后，使用了 <code>bluebird.each</code> 方法按顺序执行以下步骤：
<ul>
<li><code>update_package</code>：更新 <code>package.json</code> 文件。</li>
<li><code>load_config</code>：加载配置文件。</li>
<li><code>load_theme_config</code>：加载主题配置文件。</li>
<li><code>load_plugins</code>：加载外部插件和脚本。</li>
</ul>
</li>
<li>在所有初始化步骤完成后，执行 <code>after_init</code> 过滤器，允许插件和主题在初始化后进行一些额外的操作。</li>
<li>发射 <code>ready</code> 事件，表示 Hexo 已经准备就绪，可以执行其他操作了。</li>
</ol>
<h2 id="调用控制台命令"><a class="markdownIt-Anchor" href="#调用控制台命令"></a> 调用控制台命令</h2>
<pre><code class="language-javascript">call(name, args, callback) &#123;
  if (!callback &amp;&amp; typeof args === &#x27;function&#x27;) &#123;
    callback = args;
    args = &#123;&#125;;
  &#125;
  const c = this.extend.console.get(name);
  if (c)
    return Reflect.apply(c, this, [args]).asCallback(callback);
  return bluebird_1.default.reject(new Error(`Console \`$&#123;name&#125;\` has not been registered yet!`));
&#125;</code></pre>
<p>这段代码定义了 <code>call</code> 方法，用于调用已注册的控制台命令。</p>
<p>先是检查了是否传入回调函数。如果没有，但是第二个参数是一个函数的话，就将第二个参数视为回调函数，同时将 <code>args</code> 设置为一个空对象。这是为了兼容只传入回调函数的情况。</p>
<p>从 <code>this.extend.console</code> 对象中获取名为 <code>name</code> 的控制台命令。如果找到了对应的控制台命令对象 <code>c</code>，便执行以下步骤：</p>
<ol>
<li>使用 <code>Reflect</code> 对象的 <code>apply</code> 方法调用控制台命令 <code>c</code>。</li>
<li><code>.asCallback(callback)</code> 将上一步的调用结果转换为一个 Promise 对象，并将该 Promise 与回调函数 <code>callback</code> 关联。这样就可以在 Promise 完成时自动调用回调函数。</li>
</ol>
<p>如果未能找到对应的控制台命令对象，就返回一个被拒绝的 Promise，其中包含一个表示该命令尚未注册的错误消息。</p>
<h2 id="定义数据库模型"><a class="markdownIt-Anchor" href="#定义数据库模型"></a> 定义数据库模型</h2>
<pre><code class="language-javascript">model(name, schema) &#123;
  return this.database.model(name, schema);
&#125;</code></pre>
<p>回到<a href="####%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a>的 <code>Database</code> 类，能看出 <code>model</code> 方法是用来创建一个模型的。</p>
<h2 id="解析插件"><a class="markdownIt-Anchor" href="#解析插件"></a> 解析插件</h2>
<pre><code class="language-javascript">resolvePlugin(name, basedir) &#123;
  try &#123;
    // Try to resolve the plugin with the Node.js&#x27;s built-in require.resolve.
    return require.resolve(name, &#123; paths: [basedir] &#125;);
  &#125;
  catch (err) &#123;
    try &#123;
      // There was an error (likely the node_modules is corrupt or from early version of npm)
      // Use Hexo prior 6.0.0&#x27;s behavior (resolve.sync) to resolve the plugin.
      resolveSync = resolveSync || require(&#x27;resolve&#x27;).sync;
      return resolveSync(name, &#123; basedir &#125;);
    &#125;
    catch (err) &#123;
      // There was an error (likely the plugin wasn&#x27;t found), so return a possibly
      // non-existing path that a later part of the resolution process will check.
      return (0, path_1.join)(basedir, &#x27;node_modules&#x27;, name);
    &#125;
  &#125;
&#125;</code></pre>
<p>先是使用 <code>require.resolve</code> 方法用于解析模块。如果解析失败了，就继续尝试使用 <code>resolve.sync</code> 方法。最后如果依然失败，则返回一个可能不存在的路径以供后续处理。</p>
<blockquote>
<p><code>require.resolve</code> 方法是 Node.js 内置的，用于解析模块的路径。 如果 <code>require.resolve</code> 失败，通常是由于 <code>node_modules</code> 目录损坏或其他原因。</p>
<p><code>require('resolve').sync</code> 方法是一个更兼容旧版本 npm 的解决方案，类似于早期 Hexo 版本的插件解析方式。<code>resolve.sync</code> 方法如果也失败，很有可能是因为插件未找到，这时候便返回一个大概并不存在的路径。</p>
</blockquote>
<h2 id="加载插件"><a class="markdownIt-Anchor" href="#加载插件"></a> 加载插件</h2>
<pre><code class="language-javascript">loadPlugin(path, callback) &#123;
  return (0, hexo_fs_1.readFile)(path).then(script =&gt; &#123;
    // Based on: https://github.com/nodejs/node-v0.x-archive/blob/v0.10.33/src/node.js#L516
    const module = new module_1.default(path);
    module.filename = path;
    module.paths = module_1.default._nodeModulePaths(path);
    function req(path) &#123;
      return module.require(path);
    &#125;
    req.resolve = (request) =&gt; module_1.default._resolveFilename(request, module);
    req.main = require.main;
    req.extensions = module_1.default._extensions;
    req.cache = module_1.default._cache;
    script = `(async function(exports, require, module, __filename, __dirname, hexo)&#123;$&#123;script&#125;\n&#125;);`;
    const fn = (0, vm_1.runInThisContext)(script, path);
    return fn(module.exports, req, module, path, (0, path_1.dirname)(path), this);
  &#125;).asCallback(callback);
&#125;</code></pre>
<ol>
<li>
<p>使用 <code>hexo-fs</code> 库的 <code>readFile</code> 异步读取插件文件的内容，返回一个 Promise 对象。</p>
<blockquote>
<p><code>hexo-fs</code> 库的源代码未来再说，暂且只需要知道是 Hexo 的文件系统模块。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo-fs"><img src="https://gh-card.dev/repos/hexojs/hexo-fs.svg" alt="hexojs/hexo-fs - GitHub"></a></p>
</li>
<li>
<p>接着创建模块环境，并设置 <code>filename</code> 和 <code>paths</code> 属性。这里的 <code>module_1</code> 是 <code>module</code> 模块，定义了多种与模块加载、解析和处理相关的类型和接口。<code>filename</code> 属性被赋值插件的路径 <code>path</code>；<code>paths</code> 被赋值模块的搜索路径。</p>
</li>
<li>
<p><code>req</code> 方法用于模块加载。这个方法实际上模拟了 <code>require</code> 函数。之后这段代码分别定义了 <code>req.resolve</code> 方法来解析模块的绝对路径，设置 <code>req.main</code> 属性来指向 Node.js 主模块、<code>req.extensions</code> 属性来处理模块文件的加载、<code>req.cache</code> 属性来缓存加载的模块。</p>
</li>
<li>
<p>插件的内容被包装在一个异步函数中，并传入了必要的参数、赋值给变量 <code>script</code>。</p>
</li>
<li>
<p>使用 <code>vm_1.runInThisContext</code> 方法将包装后的插件内容编译为可执行函数。</p>
<ul>
<li><code>vm_1</code> 是 <code>vm</code> 模块，提供了一组 API 用于在 JavaScript 中创建虚拟机和运行沙盒化的代码。</li>
</ul>
</li>
<li>
<p>执行编译后的函数，传入需要的参数。</p>
</li>
<li>
<p>最终将 Promise 对象转换为回调函数形式，并进行执行。</p>
</li>
</ol>
<h2 id="显示草稿内容"><a class="markdownIt-Anchor" href="#显示草稿内容"></a> 显示草稿内容</h2>
<pre><code class="language-javascript">_showDrafts() &#123;
  const &#123; args &#125; = this.env;
  return args.draft || args.drafts || this.config.render_drafts;
&#125;</code></pre>
<p>根据用户的输入和 Hexo 的配置，确定是否应该显示草稿内容。</p>
<h2 id="加载"><a class="markdownIt-Anchor" href="#加载"></a> 加载</h2>
<pre><code class="language-javascript">load(callback) &#123;
  return (0, load_database_1.default)(this).then(() =&gt; &#123;
    this.log.info(&#x27;Start processing&#x27;);
    return bluebird_1.default.all([
      this.source.process(),
      this.theme.process()
    ]);
  &#125;).then(() =&gt; &#123;
    mergeCtxThemeConfig(this);
    return this._generate(&#123; cache: false &#125;);
  &#125;).asCallback(callback);
&#125;</code></pre>
<blockquote>
<p><code>load_database</code> 模块检查数据库文件是否存在，存在则尝试加载数据库。如果加载失败，则删除数据库文件。它使用了 <code>hexo-fs</code> 模块来处理文件系统操作，并使用 <code>bluebird</code> 提供的 Promise 来管理异步操作。通过 <code>ctx</code> 上下文对象来传递数据库和日志对象，以及跟踪数据库加载状态。</p>
<pre><code class="language-javascript">&quot;use strict&quot;;
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) &#123;
  return (mod &amp;&amp; mod.__esModule) ? mod : &#123; &quot;default&quot;: mod &#125;;
&#125;;
const hexo_fs_1 = require(&quot;hexo-fs&quot;);
const bluebird_1 = __importDefault(require(&quot;bluebird&quot;));
module.exports = (ctx) =&gt; &#123;
  if (ctx._dbLoaded)
    return bluebird_1.default.resolve();
  const db = ctx.database;
  const &#123; path &#125; = db.options;
  const &#123; log &#125; = ctx;
  return (0, hexo_fs_1.exists)(path).then(exist =&gt; &#123;
    if (!exist)
      return;
    log.debug(&#x27;Loading database.&#x27;);
    return db.load();
  &#125;).then(() =&gt; &#123;
    ctx._dbLoaded = true;
  &#125;).catch(() =&gt; &#123;
    log.error(&#x27;Database load failed. Deleting database.&#x27;);
    return (0, hexo_fs_1.unlink)(path);
  &#125;);
&#125;;
//# sourceMappingURL=load_database.js.map</code></pre>
</blockquote>
<p>在数据库加载完成后，使用 <code>then</code> 方法处理返回的 Promise。在这个处理函数中，首先记录了日志信息 <code>Start processing</code>，然后使用 <code>bluebird_1.default.all</code> 方法并行处理两个任务：</p>
<ul>
<li><code>this.source.process()</code> 处理源文件。</li>
<li><code>this.theme.process()</code> 处理主题。</li>
</ul>
<p>处理完源文件和主题后，再次使用了 <code>then</code> 方法处理返回的 Promise。调用 <code>mergeCtxThemeConfig</code> 函数，将 <code>Hexo</code> 实例的上下文与主题配置合并，然后调用了 <code>this._generate(&#123; cache: false &#125;)</code> 方法，生成静态文件。</p>
<p><code>mergeCtxThemeConfig</code> 函数在 <code>index.js</code> 文件的很上方：</p>
<pre><code class="language-javascript">const mergeCtxThemeConfig = (ctx) =&gt; &#123;
  if (ctx.config.theme_config) &#123;
    ctx.theme.config = (0, hexo_util_1.deepMerge)(ctx.theme.config, ctx.config.theme_config);
  &#125;
&#125;;</code></pre>
<p>该函数用于将 <code>ctx.config.theme_config</code>（主题配置）合并到 <code>ctx.theme.config</code>（博客目录）中。这里还使用了 <code>hexo-util</code> 库的深度合并。<code>hexo-util</code> 库也是未来会讲的。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo-util"><img src="https://gh-card.dev/repos/hexojs/hexo-util.svg" alt="hexojs/hexo-util - GitHub"></a></p>
<pre><code class="language-javascript">_generate(options = &#123;&#125;) &#123;
  if (this._isGenerating)
    return;
  const useCache = options.cache;
  this._isGenerating = true;
  this.emit(&#x27;generateBefore&#x27;);
  // Run before_generate filters
  return this.execFilter(&#x27;before_generate&#x27;, null, &#123; context: this &#125;)
    .then(() =&gt; this._routerRefresh(this._runGenerators(), useCache)).then(() =&gt; &#123;
      this.emit(&#x27;generateAfter&#x27;);
      // Run after_generate filters
      return this.execFilter(&#x27;after_generate&#x27;, null, &#123; context: this &#125;);
    &#125;).finally(() =&gt; &#123;
      this._isGenerating = false;
    &#125;);
&#125;</code></pre>
<p>为了防止重复生成，<code>_generate</code> 方法先是判断了 <code>_isGenerating</code> 变量，再进行接下来的操作。从 <code>options</code> 参数中提取 <code>cache</code> 选项，是为了决定是否在生成过程中使用缓存。</p>
<p>设置 <code>this._isGenerating</code> 为 <code>true</code> 后，便开始生成。<code>generateBefore</code> 事件被触发，接着执行 <code>before_generate</code> 过滤器。</p>
<blockquote>
<p>过滤器（Filter）后续会讲解。目前先延申 <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/api/filter">Hexo 官方文档</a>中的说明：</p>
<blockquote>
<p>过滤器用于修改特定文件，Hexo 将这些文件依序传给过滤器，而过滤器可以针对文件进行修改。</p>
</blockquote>
</blockquote>
<blockquote>
<p>其中的 <code>execFilter</code> 方法在 <code>Hexo</code> 类的最下方被定义：</p>
<pre><code class="language-javascript">execFilter(type, data, options) &#123;
    return this.extend.filter.exec(type, data, options);
&#125;</code></pre>
<blockquote>
<p><code>Hexo</code> 类也有一个 <code>execFilterSync</code> 方法：</p>
<pre><code class="language-javascript">execFilterSync(type, data, options) &#123;
  return this.extend.filter.execSync(type, data, options);
&#125;</code></pre>
</blockquote>
</blockquote>
<p><code>before_generate</code> 过滤器执行完毕后，调用 <code>_routerRefresh</code> 方法：</p>
<blockquote>
<pre><code class="language-javascript">_routerRefresh(runningGenerators, useCache) &#123;
  const &#123; route &#125; = this;
  const routeList = route.list();
  const Locals = this._generateLocals();
  Locals.prototype.cache = useCache;
  return runningGenerators.map((generatorResult) =&gt; &#123;
    if (typeof generatorResult !== &#x27;object&#x27; || generatorResult.path == null)
      return undefined;
    const path = route.format(generatorResult.path);
    const &#123; data, layout &#125; = generatorResult;
    if (!layout) &#123;
      route.set(path, data);
      return path;
    &#125;
    return this.execFilter(&#x27;template_locals&#x27;, new Locals(path, data), &#123; context: this &#125;)
      .then(locals =&gt; &#123; route.set(path, createLoadThemeRoute(generatorResult, locals, this)); &#125;)
      .thenReturn(path);
  &#125;).then(newRouteList =&gt; &#123;
    for (let i = 0, len = routeList.length; i &lt; len; i++) &#123;
      const item = routeList[i];
      if (!newRouteList.includes(item)) &#123;
        route.remove(item);
      &#125;
    &#125;
  &#125;);
&#125;</code></pre>
<ol>
<li>初始化和获取路由列表：从 <code>this</code> 中获取 <code>route</code> 对象，并调用其 <code>list</code> 方法获取当前路由列表；生成局部变量 <code>Locals</code>，并将 <code>useCache</code> 选项赋给 <code>Locals.prototype.cache</code>，决定是否使用缓存。</li>
<li>处理生成器结果：遍历 <code>runningGenerators</code> 数组，对于每个生成器结果进行处理。如果 <code>generatorResult</code> 不是对象或 <code>path</code> 为空，则返回 <code>undefined</code>。</li>
<li>格式化路径并处理数据：调用 <code>route.format</code> 方法格式化路径；解构 <code>generatorResult</code>，获取 <code>data</code> 和 <code>layout</code>。如果 <code>layout</code> 不存在，直接将 <code>path</code> 和 <code>data</code> 设置到路由中，并返回 <code>path</code>。</li>
<li>执行 <code>template_locals</code> 过滤器并设置路由：调用 <code>execFilter</code> 方法执行 <code>template_locals</code> 过滤器，传入新的 <code>Locals</code> 实例。在过滤器执行完毕后，将路径和创建的主题路由设置到路由中，并返回 <code>path</code>。<pre><code class="language-javascript">const createLoadThemeRoute = function (generatorResult, locals, ctx) &#123;
  const &#123; log, theme &#125; = ctx;
  const &#123; path, cache: useCache &#125; = locals;
  const layout = [...new Set(castArray(generatorResult.layout))];
  const layoutLength = layout.length;
  locals.cache = true;
  return () =&gt; &#123;
    if (useCache &amp;&amp; routeCache.has(generatorResult))
      return routeCache.get(generatorResult);
    for (let i = 0; i &lt; layoutLength; i++) &#123;
      const name = layout[i];
      const view = theme.getView(name);
      if (view) &#123;
        log.debug(`Rendering HTML $&#123;name&#125;: $&#123;(0, picocolors_1.magenta)(path)&#125;`);
        return view.render(locals)
          .then(result =&gt; ctx.extend.injector.exec(result, locals))
          .then(result =&gt; ctx.execFilter(&#x27;_after_html_render&#x27;, result, &#123;
            context: ctx,
            args: [locals]
          &#125;))
          .tap(result =&gt; &#123;
            if (useCache) &#123;
              routeCache.set(generatorResult, result);
            &#125;
          &#125;).tapCatch(err =&gt; &#123;
            log.error(&#123; err &#125;, `Render HTML failed: $&#123;(0, picocolors_1.magenta)(path)&#125;`);
          &#125;);
      &#125;
    &#125;
    log.warn(`No layout: $&#123;(0, picocolors_1.magenta)(path)&#125;`);
  &#125;;
&#125;;</code></pre>
<code>createLoadThemeRoute</code> 方法创建加载主题路由的闭包。<br>
首先从 <code>ctx</code> 中获取日志记录器 <code>log</code> 和主题对象 <code>theme</code>、从 <code>locals</code> 中获取路由的路径 <code>path</code> 和缓存标志 <code>useCache</code>。然后将 <code>generatorResult.layout</code> 转换为一个唯一的布局数组，记录布局的长度，同时将 <code>locals.cache</code> 设置为 <code>true</code>，以确保视图在渲染期间使用缓存。<br>
返回一个闭包。闭包指的是函数和函数内部引用的外部变量的组合。该闭包在调用时会渲染 HTML 视图。<br>
如果 <code>useCache</code> 为 <code>true</code>，并且缓存中存在 <code>generatorResult</code>，直接返回缓存的结果。否则遍历布局数组，并尝试从主题中获取对应的视图。<br>
如果找到了视图，就使用该视图渲染 <code>locals</code>，并执行注入器和过滤器，最后返回渲染结果。否则记录警告并返回。</li>
</ol>
<blockquote>
<p>注入器（Injector）是 Hexo 扩展之一，在 <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/api/injector">Hexo 官方文档</a> 中被声明为 <strong>用于将静态代码片段注入生成的 HTML 的 <code>&lt;head&gt;</code> 和/或 <code>&lt;body&gt;</code> 中</strong>，且注入必须在 <code>after_render:html</code> 过滤器之前完成。</p>
</blockquote>
<ol start="5">
<li>移除旧路由：获取新生成的 <code>newRouteList</code>；遍历旧路由列表 <code>routeList</code>，如果某个路由不在 <code>newRouteList</code> 中，则将其移除。</li>
</ol>
<p><code>_routerRefresh</code> 方法确保了生成器结果正确应用到路由中，同时清理不再需要的旧路由，保持路由的最新状态。</p>
</blockquote>
<p>路由刷新完成后，<code>_generate</code> 方法触发了 <code>generateAfter</code> 事件，并执行 <code>after_generate</code> 过滤器。</p>
<p>最后使用 <code>finally</code> 方法确保无论生成过程成功与否，都会将 <code>this._isGenerating</code> 重置为 <code>false</code>，允许后续生成操作进行。</p>
<p>通过执行前后过滤器和触发事件，<code>_generate</code> 方法确保生成过程的各个阶段都可以被插件或自定义代码扩展和修改。</p>
<p><code>load</code> 方法在调用 <code>_generate</code>、生成静态文件后，将整个异步操作的结果传递给回调函数 <code>callback</code>。<code>asCallback</code> 方法将 <code>Promise</code> 转换为传统的回调形式，以兼容老式回调风格的代码。</p>
<h2 id="监视文件变化"><a class="markdownIt-Anchor" href="#监视文件变化"></a> 监视文件变化</h2>
<p><code>watch</code> 函数的目的是在监视文件变化时重新生成内容，并在需要时启用缓存。</p>
<pre><code class="language-javascript">watch(callback) &#123;
  let useCache = false;
  const &#123; cache &#125; = Object.assign(&#123;
    cache: false
  &#125;, this.config.server);
  const &#123; alias &#125; = this.extend.console;
  if (alias[this.env.cmd] === &#x27;server&#x27; &amp;&amp; cache) &#123;
    // enable cache when run hexo server
    useCache = true;
  &#125;
  this._watchBox = debounce(() =&gt; this._generate(&#123; cache: useCache &#125;), 100);
  return (0, load_database_1.default)(this).then(() =&gt; &#123;
    this.log.info(&#x27;Start processing&#x27;);
    return bluebird_1.default.all([
      this.source.watch(),
      this.theme.watch()
    ]);
  &#125;).then(() =&gt; &#123;
    mergeCtxThemeConfig(this);
    this.source.on(&#x27;processAfter&#x27;, this._watchBox);
    this.theme.on(&#x27;processAfter&#x27;, () =&gt; &#123;
      this._watchBox();
      mergeCtxThemeConfig(this);
    &#125;);
    return this._generate(&#123; cache: useCache &#125;);
  &#125;).asCallback(callback);
&#125;</code></pre>
<ol>
<li><code>watch</code> 函数会先从 <code>this.config.server</code> 中读取 <code>cache</code> 配置，默认值为 <code>false</code>。如果当前命令为 <code>server</code>，并且配置了 <code>cache</code>，就会启用缓存。</li>
<li>接着使用 <code>debounce</code> 函数防抖 <code>_generate</code> 方法，间隔设置为 100 毫秒：<pre><code class="language-javascript">function debounce(func, wait) &#123;
    let timeout;
    return function () &#123;
        clearTimeout(timeout);
        timeout = setTimeout(() =&gt; &#123;
            func.apply(this);
        &#125;, wait);
    &#125;;
&#125;</code></pre>
<code>debounce</code> 函数的目的是限制某个函数在一段时间内的调用次数，当该函数被连续调用时，只有在停止调用后等待指定的时间才会真正执行。这样便可以优化性能。</li>
<li>调用 <code>load_database_1.default</code> 方法加载数据库，打印日志 <code>Start processing</code>，同时监视 <code>source</code> 和 <code>theme</code> 的变化，使用 <code>bluebird_1.default.all</code> 以并行方式执行。</li>
<li>合并主题配置并设置监控回调：这里的 <code>mergeCtxThemeConfig</code> 方法之前已经说过了。当 <code>source</code> 处理完成后，调用 <code>_watchBox</code>；当 <code>theme</code> 处理完成后，调用 <code>_watchBox</code> 并再次合并主题配置。</li>
<li>调用 <code>_generate</code> 方法，初次生成内容，并根据 <code>useCache</code> 决定是否使用缓存。</li>
<li>最后使用 <code>bluebird</code> 库的 <code>asCallback</code> 方法，将结果作为回调传递给 <code>callback</code>。</li>
</ol>
<h2 id="停止监控"><a class="markdownIt-Anchor" href="#停止监控"></a> 停止监控</h2>
<p>既然有了监视用的方法，那么也有取消监视的方法。</p>
<pre><code class="language-javascript">unwatch() &#123;
  if (this._watchBox != null) &#123;
    this.source.removeListener(&#x27;processAfter&#x27;, this._watchBox);
    this.theme.removeListener(&#x27;processAfter&#x27;, this._watchBox);
    this._watchBox = null;
  &#125;
  stopWatcher(this.source);
  stopWatcher(this.theme);
&#125;</code></pre>
<p><code>unwatch</code> 方法检查并清除了 <code>_watchBox</code>。根据上面 <code>watch</code> 方法的内容，<code>this._watchBox</code> 是一个防抖函数，用来处理文件变动后的生成操作。如果它存在，就需要将其从 <code>source</code> 和 <code>theme</code> 对象的 <code>processAfter</code> 事件监听器中移除。</p>
<p><code>stopWatcher</code> 函数被定义在 <code>index.js</code> 的最上方：</p>
<pre><code class="language-javascript">const stopWatcher = (box) =&gt; &#123; if (box.isWatching())
  box.unwatch(); &#125;;</code></pre>
<p>它用于停止对给定对象的监控。逻辑很简单：该对象是否正在被监控，如果是，就调用 <code>unwatch</code> 方法停止监控。</p>
<h2 id="生成本地环境"><a class="markdownIt-Anchor" href="#生成本地环境"></a> 生成本地环境</h2>
<pre><code class="language-javascript">_generateLocals() &#123;
  const &#123; config, env, theme, theme_dir &#125; = this;
  const ctx = &#123; config: &#123; url: this.config.url &#125; &#125;;
  const localsObj = this.locals.toObject();
  class Locals &#123;
    constructor(path, locals) &#123;
      this.page = Object.assign(&#123;&#125;, locals);
      if (this.page.path == null)
        this.page.path = path;
      this.path = path;
      this.url = hexo_util_1.full_url_for.call(ctx, path);
      this.config = config;
      this.theme = theme.config;
      this.layout = &#x27;layout&#x27;;
      this.env = env;
      this.view_dir = (0, path_1.join)(theme_dir, &#x27;layout&#x27;) + path_1.sep;
      this.site = localsObj;
    &#125;
  &#125;
  return Locals;
&#125;</code></pre>
<p><code>Locals</code> 类中，许多环境相关的属性，如 <code>url</code>、<code>config</code> 等属性都被设置。该方法生成了本地环境的信息对象，以便在模块渲染过程中使用。</p>
<h2 id="运行生成器"><a class="markdownIt-Anchor" href="#运行生成器"></a> 运行生成器</h2>
<blockquote>
<p>同样，生成器（Generator）后续也会讲解。</p>
<p>在 <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/api/generator">Hexo 官方文档</a> 中，生成器被解释为 <strong>会根据处理后的原始文件建立路由</strong>。</p>
</blockquote>
<pre><code class="language-javascript">_runGenerators() &#123;
  this.locals.invalidate();
  const siteLocals = this.locals.toObject();
  const generators = this.extend.generator.list();
  const &#123; log &#125; = this;
  // Run generators
  return bluebird_1.default.map(Object.keys(generators), key =&gt; &#123;
    const generator = generators[key];
    log.debug(&#x27;Generator: %s&#x27;, (0, picocolors_1.magenta)(key));
    return Reflect.apply(generator, this, [siteLocals]);
  &#125;).reduce((result, data) =&gt; &#123;
    return data ? result.concat(data) : result;
  &#125;, []);
&#125;</code></pre>
<ol>
<li><code>invalidate</code> 方法使 <code>Hexo</code> 实例的本地数据无效，以便在生成器运行之前重新加载。</li>
<li>提取当前 <code>Hexo</code> 实例的本地数据对象，将其赋值给 <code>siteLocals</code> 变量。</li>
<li>获取 <code>Hexo</code> 实例中已注册的所有生成器，将它们保存在 <code>generators</code> 变量中。</li>
<li>运行生成器之前，记录了一条调试信息，指示将要运行哪个生成器。</li>
<li>使用 <code>bluebird</code> 库的 <code>map</code> 方法对生成器进行并行处理。每个生成器都被调用 <code>Reflect.apply(generator, this, [siteLocals])</code>，将生成器函数应用到当前的 <code>Hexo</code> 实例上。</li>
<li>使用 <code>bluebird</code> 库的 <code>reduce</code> 方法将生成器返回的数据收集到一个数组中，并返回这个数组。</li>
</ol>
<p><code>_runGenerators</code> 方法运行 <code>Hexo</code> 实例中所有注册的生成器，并将它们返回的数据收集到一个数组中。</p>
<h2 id="退出进程"><a class="markdownIt-Anchor" href="#退出进程"></a> 退出进程</h2>
<p><code>exit</code> 方法用于退出 Hexo 进程。</p>
<pre><code class="language-javascript">exit(err) &#123;
  if (err) &#123;
    this.log.fatal(&#123; err &#125;, &#x27;Something\&#x27;s wrong. Maybe you can find the solution here: %s&#x27;, (0, picocolors_1.underline)(&#x27;https://hexo.io/docs/troubleshooting.html&#x27;));
  &#125;
  return this.execFilter(&#x27;before_exit&#x27;, null, &#123; context: this &#125;).then(() =&gt; &#123;
    this.emit(&#x27;exit&#x27;, err);
  &#125;);
&#125;</code></pre>
<p>这里值得说的是，<code>exit</code> 方法会触发 <code>execFilter</code> 方法、触发 <code>before_exit</code> 过滤器。以及最终它会触发 <code>exit</code> 事件。</p>
<h2 id="定义属性和导出"><a class="markdownIt-Anchor" href="#定义属性和导出"></a> 定义属性和导出</h2>
<pre><code class="language-javascript">Hexo.lib_dir = libDir + path_1.sep;
Hexo.prototype.lib_dir = Hexo.lib_dir;
Hexo.core_dir = (0, path_1.dirname)(libDir) + path_1.sep;
Hexo.prototype.core_dir = Hexo.core_dir;
Hexo.version = version;
Hexo.prototype.version = Hexo.version;
module.exports = Hexo;</code></pre>
<p><code>Hexo</code> 类本身终于讲完了，在 <code>Hexo</code> 类的下方，它的部分属性和原型属性被定义，并最终被导出为模块的默认输出。</p>
<ul>
<li><code>LibDir</code>：<code>Hexo</code> 库目录的路径。</li>
<li><code>core_dir</code>：核心目录的路径。</li>
<li><code>version</code>：版本号。</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="407.html">上一篇</a><a class="next" href="224a.html">下一篇</a></div><div class="copyright"><p>© 2022 - 2025 <a href="https://cytrogen.icu">Cytrogen</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/cytrogen/hexo-theme-ares" target="_blank">hexo-theme-ares</a>.</p></div></footer></div></div><a class="back-to-top" href="#top" aria-label="返回顶部"><svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path d="M3.293 9.707a1 1 0 010-1.414L9.586 2a2 2 0 012.828 0l6.293 6.293a1 1 0 01-1.414 1.414L11 3.414V17a1 1 0 11-2 0V3.414L2.707 9.707a1 1 0 01-1.414 0z"></path></svg></a><script>document.addEventListener('DOMContentLoaded', function() {
  const codeBlocks = document.querySelectorAll('figure.highlight');
  
  codeBlocks.forEach(block => {
    let caption = block.querySelector('figcaption');
    if (!caption) {
      caption = document.createElement('figcaption');
      block.insertBefore(caption, block.firstChild);
    }

    const info = document.createElement('div');
    info.className = 'info';
    
    const filename = caption.querySelector('span');
    if (filename) {
      filename.className = 'filename';
      info.appendChild(filename);
    }
    
    const lang = block.className.split(' ')[1];
    if (lang) {
      const langSpan = document.createElement('span');
      langSpan.className = 'lang-name';
      langSpan.textContent = lang;
      info.appendChild(langSpan);
    }

    const sourceLink = caption.querySelector('a');
    if (sourceLink) {
      sourceLink.className = 'source-link';
      info.appendChild(sourceLink);
    }

    const actions = document.createElement('div');
    actions.className = 'actions';

    const codeHeight = block.scrollHeight;
    const threshold = 300;

    if (codeHeight > threshold) {
      block.classList.add('folded');
      
      const toggleBtn = document.createElement('button');
      toggleBtn.textContent = '展开';
      toggleBtn.addEventListener('click', () => {
        block.classList.toggle('folded');
        toggleBtn.textContent = block.classList.contains('folded') ? '展开' : '折叠';
      });
      actions.appendChild(toggleBtn);
    }

    const copyBtn = document.createElement('button');
    copyBtn.textContent = '复制';
    copyBtn.addEventListener('click', async () => {
      const codeLines = block.querySelectorAll('.code .line');
      const code = Array.from(codeLines)
        .map(line => line.textContent)
        .join('\n')
        .replace(/\n\n/g, '\n');
      
      try {
        await navigator.clipboard.writeText(code);
        copyBtn.textContent = '已复制';
        copyBtn.classList.add('copied');
        
        setTimeout(() => {
          copyBtn.textContent = '复制';
          copyBtn.classList.remove('copied');
        }, 3000);
      } catch (err) {
        console.error('复制失败:', err);
        copyBtn.textContent = '复制失败';
        
        setTimeout(() => {
          copyBtn.textContent = '复制';
        }, 3000);
      }
    });
    actions.appendChild(copyBtn);

    caption.innerHTML = '';
    caption.appendChild(info);
    caption.appendChild(actions);

    const markedLines = block.getAttribute('data-marked-lines');
    if (markedLines) {
      const lines = markedLines.split(',');
      lines.forEach(range => {
        if (range.includes('-')) {
          const [start, end] = range.split('-').map(Number);
          for (let i = start; i <= end; i++) {
            const line = block.querySelector(`.line-${i}`);
            if (line) line.classList.add('marked');
          }
        } else {
          const line = block.querySelector(`.line-${range}`);
          if (line) line.classList.add('marked');
        }
      });
    }
  });
});</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=G-4PVPZXE0QQ"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-4PVPZXE0QQ');</script><script>(function() {
  // Wait for DOM to be ready
  document.addEventListener('DOMContentLoaded', function() {
    const themeToggle = document.querySelector('.theme-toggle');
    
    if (!themeToggle) return;
    
    // Get current theme
    const getCurrentTheme = () => {
      return document.documentElement.getAttribute('data-theme') || 'light';
    };
    
    // Update UI to match current theme
    const updateUI = (theme) => {
      const isDark = theme === 'dark';
      themeToggle.setAttribute('aria-pressed', isDark.toString());
    };
    
    // Simplified theme setter - CSS handles all animations
    const setTheme = (theme) => {
      document.documentElement.setAttribute('data-theme', theme);
      document.documentElement.style.colorScheme = theme; // Update native UI elements
      
      // Also update page-wrapper for animation support
      const pageWrapper = document.getElementById('page-wrapper');
      if (pageWrapper) {
        pageWrapper.setAttribute('data-theme', theme);
      }
      
      // Find and remove the temporary anti-flicker style tag if it exists.
      // This ensures the main stylesheet takes full control after the initial load.
      const antiFlickerStyle = document.getElementById('anti-flicker-style');
      if (antiFlickerStyle) {
        antiFlickerStyle.remove();
      }
      
      localStorage.setItem('theme', theme);
      updateUI(theme);
    };
    
    // Simple theme toggle - letting CSS handle the smooth transitions
    const toggleTheme = () => {
      const current = getCurrentTheme();
      const newTheme = current === 'light' ? 'dark' : 'light';
      setTheme(newTheme);
    };
    
    // Initialize UI on page load
    updateUI(getCurrentTheme());
    
    // Add click event listener
    themeToggle.addEventListener('click', toggleTheme);
    
    // Listen for system theme changes
    if (window.matchMedia) {
      const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
      mediaQuery.addEventListener('change', function(e) {
        // Only update if no manual preference is saved
        if (!localStorage.getItem('theme')) {
          const theme = e.matches ? 'dark' : 'light';
          setTheme(theme);
        }
      });
    }
  });
})();
</script><script>(function() {
  document.addEventListener('DOMContentLoaded', function() {
    const backToTopBtn = document.querySelector('.back-to-top');
    
    if (!backToTopBtn) return;
    
    // Show/hide button based on scroll position
    const toggleButtonVisibility = () => {
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      const shouldShow = scrollTop > 200; // Show after scrolling 200px
      
      if (shouldShow) {
        backToTopBtn.classList.add('is-visible');
      } else {
        backToTopBtn.classList.remove('is-visible');
      }
    };
    
    // Throttle scroll events for better performance
    let ticking = false;
    const handleScroll = () => {
      if (!ticking) {
        requestAnimationFrame(() => {
          toggleButtonVisibility();
          ticking = false;
        });
        ticking = true;
      }
    };
    
    // Smooth scroll to top when clicked
    const scrollToTop = (event) => {
      event.preventDefault();
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    };
    
    // Add event listeners
    window.addEventListener('scroll', handleScroll);
    backToTopBtn.addEventListener('click', scrollToTop);
    
    // Check initial scroll position
    toggleButtonVisibility();
  });
})();</script></body></html>