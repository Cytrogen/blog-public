<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>IBM全栈开发【11】：全栈应用程序开发项目 · Cytrogen 的个人博客</title><meta name="description" content="本文是 IBM 全栈开发课程的最终篇学习笔记，通过一个完整的“Best Cars”汽车经销商项目，将课程所学技能融会贯通。文章详细记录了从零构建一个全栈应用的完整流程：首先使用 Django 搭建基础网站并实现用户管理；接着，开发独立的 Node.js/MongoDB 后端服务和 AI 情感分析微服务；然后，创建动态的 React 前端来消费这些服务。最后，教程还演示了如何配置 GitHub Actions 实现 CI/CD，并将主应用容器化（Docker），最终部署到 Kubernetes (K8s) 集群。这篇笔记是对现代全栈开发、微服务和 DevOps 实践的一次全面实战演练。"><link rel="icon" href="../favicon.png"><link rel="preload" href="../fonts/opensans-regular-latin.woff2" as="font" type="font/woff2" crossorigin="anonymous"><style>@font-face {
  font-family: 'Open Sans';
  src: url('../fonts/opensans-regular-latin.woff2') format('woff2');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
  size-adjust: 107%;
  ascent-override: 97%;
  descent-override: 25%;
  line-gap-override: 0%;
}
</style><link rel="stylesheet" href="../css/ares.css"><script>(function() {
  const getInitialTheme = () => {
    const saved = localStorage.getItem('theme');
    if (saved && (saved === 'light' || saved === 'dark')) {
      return saved;
    }
    
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      return 'dark';
    }
    
    return 'light';
  };
  
  const theme = getInitialTheme();
  document.documentElement.setAttribute('data-theme', theme);
  
  document.documentElement.style.colorScheme = theme;
  
  // Add anti-flicker style for dark mode
  if (theme === 'dark') {
    const style = document.createElement('style');
    style.id = 'anti-flicker-style';
    style.innerHTML = `
      #page-wrapper[data-theme="dark"] {
        background-color: #0f172a;
        color: #f1f5f9;
      }
    `;
    document.head.appendChild(style);
  }
  
  document.addEventListener('DOMContentLoaded', function() {
    const pageWrapper = document.getElementById('page-wrapper');
    if (pageWrapper) {
      pageWrapper.setAttribute('data-theme', theme);
    }
  });
})();

</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="atom.xml" title="Cytrogen 的个人博客" type="application/atom+xml">
</head><body><div id="page-wrapper"><a class="skip-link" href="#main-content">跳到主要内容</a><div class="wrap"><header><a class="logo-link" href="../index.html"><img src="../favicon.png" alt="logo"></a><nav class="site-nav"><div class="nav-main"><div class="nav-primary"><ul class="nav-list hidden-mobile"><li class="nav-item"><a class="nav-link" href="../index.html">首页</a></li></ul><div class="nav-tools"><div class="language-menu"><button class="language-toggle" type="button"><svg class="icon icon-globe" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true" focusable="false"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8zm7.5-6.923c-.67.204-1.335.82-1.887 1.855A7.97 7.97 0 0 0 5.145 4H7.5V1.077zM4.09 4a9.267 9.267 0 0 1 .64-1.539 6.7 6.7 0 0 1 .597-.933A7.025 7.025 0 0 0 2.255 4H4.09zm-.582 3.5c.03-.877.138-1.718.312-2.5H1.674a6.958 6.958 0 0 0-.656 2.5h2.49zM4.847 5a12.5 12.5 0 0 0-.338 2.5H7.5V5H4.847zM8.5 5v2.5h2.99a12.495 12.495 0 0 0-.337-2.5H8.5zM4.51 8.5a12.5 12.5 0 0 0 .337 2.5H7.5V8.5H4.51zm3.99 0V11h2.653c.187-.765.306-1.608.338-2.5H8.5zM5.145 12c.138.386.295.744.468 1.068.552 1.035 1.218 1.65 1.887 1.855V12H5.145zm.182 2.472a6.696 6.696 0 0 1-.597-.933A9.268 9.268 0 0 1 4.09 12H2.255a7.024 7.024 0 0 0 3.072 2.472zM3.82 11a13.652 13.652 0 0 1-.312-2.5h-2.49c.062.89.291 1.733.656 2.5H3.82zm6.853 3.472A7.024 7.024 0 0 0 13.745 12H11.91a9.27 9.27 0 0 1-.64 1.539 6.688 6.688 0 0 1-.597.933zM8.5 12v2.923c.67-.204 1.335-.82 1.887-1.855A7.97 7.97 0 0 0 10.855 12H8.5zm3.68-1h2.146c.365-.767.594-1.61.656-2.5h-2.49a13.65 13.65 0 0 1-.312 2.5zm2.802-3.5a6.959 6.959 0 0 0-.656-2.5H12.18c.174.782.282 1.623.312 2.5h2.49zM11.27 2.461c.247.464.462.98.64 1.539h1.835a7.024 7.024 0 0 0-3.072-2.472c.218.284.418.598.597.933zM10.855 4a7.966 7.966 0 0 0-.468-1.068C9.835 1.897 9.17 1.282 8.5 1.077V4h2.355z"></path></svg><span>中文</span></button><div class="language-dropdown"></div></div></div><div class="nav-controls"><div class="more-menu hidden-mobile"><button class="more-toggle" type="button"><span>更多</span><svg class="icon icon-chevron-down" width="12" height="12" viewBox="0 0 12 12" fill="currentColor" aria-hidden="true" focusable="false"><path d="M6 8.825c-.2 0-.4-.1-.5-.2l-3.3-3.3c-.3-.3-.3-.8 0-1.1s.8-.3 1.1 0l2.7 2.7 2.7-2.7c.3-.3.8-.3 1.1 0s.3.8 0 1.1l-3.3 3.3c-.1.1-.3.2-.5.2z"></path></svg></button><div class="more-dropdown"><ul class="dropdown-list"><li class="dropdown-item"><a class="nav-link" href="../archives">归档</a></li><li class="dropdown-item"><a class="nav-link" href="../categories">分类</a></li><li class="dropdown-item"><a class="nav-link" href="../tags">标签</a></li><li class="dropdown-item"><a class="nav-link" href="../about">关于</a></li><li class="dropdown-item"><a class="nav-link" href="../friends">友链</a></li><li class="dropdown-item"><a class="nav-link" href="../atom.xml">RSS订阅</a></li><li class="dropdown-item"><a class="dropdown-link" href="https://portfolio.cytrogen.icu" target="_blank" rel="noopener noreferrer">作品集<svg class="icon icon-external-link" width="14" height="14" viewBox="0 0 14 14" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8.636 2.364A1 1 0 0 1 10 1h3a1 1 0 0 1 1 1v3a1 1 0 0 1-2 0V3.414l-4.293 4.293a1 1 0 0 1-1.414-1.414L10.586 2H9a1 1 0 0 1-1.364-1.636zM2 3a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V9a1 1 0 1 1 2 0v3a3 3 0 0 1-3 3H2a3 3 0 0 1-3-3V4a3 3 0 0 1 3-3h3a1 1 0 1 1 0 2H2z"></path></svg></a></li><li class="dropdown-item"><a class="dropdown-link" href="https://github.com/cytrogen" target="_blank" rel="noopener noreferrer">GitHub<svg class="icon icon-external-link" width="14" height="14" viewBox="0 0 14 14" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8.636 2.364A1 1 0 0 1 10 1h3a1 1 0 0 1 1 1v3a1 1 0 0 1-2 0V3.414l-4.293 4.293a1 1 0 0 1-1.414-1.414L10.586 2H9a1 1 0 0 1-1.364-1.636zM2 3a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V9a1 1 0 1 1 2 0v3a3 3 0 0 1-3 3H2a3 3 0 0 1-3-3V4a3 3 0 0 1 3-3h3a1 1 0 1 1 0 2H2z"></path></svg></a></li></ul></div></div><div class="theme-switcher"><button class="theme-toggle" type="button" role="switch" aria-pressed="false" aria-label="切换主题"><div class="theme-icon moon-icon"><svg class="icon icon-moon" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true" focusable="false"><path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"></path></svg></div><div class="theme-icon sun-icon"><svg class="icon icon-sun" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0 1a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"></path></svg></div></button></div><details class="mobile-menu-details hidden-desktop"><summary class="hamburger-menu" aria-label="nav.menu"><svg class="icon icon-bars" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true" focusable="false"><path d="M2.5 12a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5z"></path></svg><span class="menu-text">nav.menu</span></summary><div class="mobile-menu-dropdown"><ul class="mobile-nav-list"><li class="mobile-nav-item"><a class="mobile-nav-link" href="../index.html">首页</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../archives">归档</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../categories">分类</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../tags">标签</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../about">关于</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../friends">友链</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../atom.xml">RSS订阅</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="https://portfolio.cytrogen.icu" target="_blank" rel="noopener noreferrer">作品集<svg class="icon icon-external-link" width="14" height="14" viewBox="0 0 14 14" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8.636 2.364A1 1 0 0 1 10 1h3a1 1 0 0 1 1 1v3a1 1 0 0 1-2 0V3.414l-4.293 4.293a1 1 0 0 1-1.414-1.414L10.586 2H9a1 1 0 0 1-1.364-1.636zM2 3a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V9a1 1 0 1 1 2 0v3a3 3 0 0 1-3 3H2a3 3 0 0 1-3-3V4a3 3 0 0 1 3-3h3a1 1 0 1 1 0 2H2z"></path></svg></a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="https://github.com/cytrogen" target="_blank" rel="noopener noreferrer">GitHub<svg class="icon icon-external-link" width="14" height="14" viewBox="0 0 14 14" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8.636 2.364A1 1 0 0 1 10 1h3a1 1 0 0 1 1 1v3a1 1 0 0 1-2 0V3.414l-4.293 4.293a1 1 0 0 1-1.414-1.414L10.586 2H9a1 1 0 0 1-1.364-1.636zM2 3a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V9a1 1 0 1 1 2 0v3a3 3 0 0 1-3 3H2a3 3 0 0 1-3-3V4a3 3 0 0 1 3-3h3a1 1 0 1 1 0 2H2z"></path></svg></a></li></ul></div></details></div></div></div></nav></header><main class="container" id="main-content" tabindex="-1"><div class="post"><article class="post-block"><h1 class="post-title">IBM全栈开发【11】：全栈应用程序开发项目</h1><div class="post-info">6/27/2024</div><div class="post-content"><p>近期在学习IBM全栈应用开发微学士课程，故此记录学习笔记。</p>
<span id="more"></span>
<h1 id="1-应用程序静态页面"><a class="markdownIt-Anchor" href="#1-应用程序静态页面"></a> 1. 应用程序：静态页面</h1>
<p>恭喜您成为 “Best Cars” 汽车经销商的首席云应用程序开发员。作为热身任务，您需要运行并测试其主要 Django 应用程序。</p>
<p>Django 应用程序将主要用于用户管理和身份验证、管理汽车型号和品牌，以及路由其他 MongoDB 服务以获取经销商和客户评论。您将在毕业设计课程中分阶段构建此 Django 应用程序和相关服务。</p>
<blockquote>
<p>将更改推送到 Git 仓库的步骤：</p>
<pre><code class="language-bash">git config --global user.email &quot;yourgithub@email.com&quot;
git config --global user.name &quot;name&quot;
git add .
git commit -m&quot;Adding temporary changes to Github&quot;
git push</code></pre>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/ibm-developer-skills-network/xrwvm-fullstack_developer_capstone"><img src="https://gh-card.dev/repos/ibm-developer-skills-network/xrwvm-fullstack_developer_capstone.svg" alt="ibm-developer-skills-network/xrwvm-fullstack_developer_capstone - GitHub"></a></p>
<p>导航至此仓库，并创建一个包含本项目所需的基本启动代码的版本库分叉（fork）。</p>
<h2 id="11-在开发服务器上运行-django-应用程序"><a class="markdownIt-Anchor" href="#11-在开发服务器上运行-django-应用程序"></a> 1.1. 在开发服务器上运行 Django 应用程序</h2>
<p>观察 Django 应用程序骨架结构的文件夹结构。您会看到服务器文件夹下有三个子文件夹：</p>
<ul>
<li><code>djangoapp</code>：包含 Django 应用程序。</li>
<li><code>djangoproj</code>：包含项目配置。</li>
<li><code>frontend</code>：HTML 和 CSS 以及 React 前端。</li>
</ul>
<p>接下来，让我们设置 Python 运行时并测试应用程序。</p>
<pre><code class="language-bash">cd xrwvm-fullstack_developer_capstone/server
pip install virtualenv
virtualenv djangoenv
source djangoenv/bin/activate</code></pre>
<p>在虚拟环境中安装必要的 Python 软件包。软件包名称已在 <code>requirements.txt</code> 中提供。</p>
<pre><code class="language-bash">python3 -m pip install -U -r requirements.txt</code></pre>
<p>在 <code>server/djangoproj/settings.py</code> 的 <code>TEMPLATES</code> 下，您会发现 <code>DIRS</code> 是一个空列表。在列表中添加 <code>os.path.join(BASE_DIR,'frontend/static')</code>，以便 Django 应用程序识别前端静态文件。设置如下：</p>
<pre><code class="language-python">&#x27;DIRS&#x27;: [
    os.path.join(BASE_DIR,&#x27;frontend/static&#x27;)
],</code></pre>
<p>在同一文件 <code>server/djangoproj/settings.py</code> 中，在文件底部添加 Django 应用程序查找静态文件的目录。</p>
<pre><code class="language-python">STATICFILES_DIRS = [
    os.path.join(BASE_DIR,&#x27;frontend/static&#x27;)
]</code></pre>
<p>执行迁移，创建必要的表格。</p>
<pre><code class="language-bash">python3 manage.py makemigrations</code></pre>
<p>运行迁移以激活应用程序的模型。</p>
<pre><code class="language-bash">python3 manage.py migrate</code></pre>
<p>启动本地开发服务器。</p>
<pre><code class="language-bash">python3 manage.py runserver</code></pre>
<blockquote>
<p>在文件编辑器中打开 <code>server/djangoproj/settings.py</code>，设置 <code>ALLOWED_HOSTS</code> 和 <code>CSRF_TRUSTED_ORIGINS</code> 以反映 Django 应用程序的根 URL。</p>
<p>请不要在末尾添加 /。</p>
<pre><code class="language-python">ALLOWED_HOSTS=[&#x27;localhost&#x27;,&#x27;&lt;your application URL here&gt;&#x27;]
CSRF_TRUSTED_ORIGINS=[&#x27;&lt;your application URL here&gt;&#x27;]</code></pre>
</blockquote>
<h2 id="12-添加-about-us-页面"><a class="markdownIt-Anchor" href="#12-添加-about-us-页面"></a> 1.2. 添加 “About Us” 页面</h2>
<p>在编辑器中打开 <code>server/frontend/static/About.html</code>。同一文件夹中还有样式表 <code>style.css</code>。在 <code>About.html</code> 中的 <code>&lt;head&gt;</code> 标签中链接样式表，以便在 HTML 文件中使用。</p>
<pre><code class="language-html">&lt;link rel=&quot;stylesheet&quot; href=&quot;/static/style.css&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;/static/bootstrap.min.css&quot;&gt;</code></pre>
<p>在名为 <code>about-header</code> 的 <code>&lt;div&gt;</code> 标记中粘贴以下内容。</p>
<pre><code class="language-html">&lt;h1&gt;About Us&lt;/h1&gt;
Welcome to Best Cars dealership, home to the best cars in North America. We deal in sale of domestic and imported cars at reasonable prices.</code></pre>
<p>将图片 <code>person.png</code> 改为真人图片，并修改 <code>About.html</code> 中的所有文字，使其看起来更真实。根据您的喜好更改样式。</p>
<p>转到 <code>djangoproj/urls.py</code>，在 <code>urlpatterns</code> 中添加以下内容：</p>
<pre><code class="language-python">path(&#x27;about/&#x27;, TemplateView.as_view(template_name=&quot;About.html&quot;)),</code></pre>
<h2 id="13-添加-contact-us-页面"><a class="markdownIt-Anchor" href="#13-添加-contact-us-页面"></a> 1.3. 添加 “Contact Us” 页面</h2>
<p>在 <code>server/frontend/static</code> 文件夹下添加一个名为 <code>Contact.html</code> 的新文件。</p>
<p>添加样式表链接。</p>
<p>添加标题导航栏，将 <code>Contact Us</code> 作为活动链接。</p>
<p>在文件中写入联系信息内容。您可以发挥创意，编写自己的信息。使用 css 创建样式。</p>
<p>将 <code>contact</code> 路径添加到 <code>djangproj/urls.py</code>：</p>
<pre><code class="language-python">path(&#x27;contact/&#x27;, TemplateView.as_view(template_name=&quot;Contact.html&quot;)),</code></pre>
<p>Django 服务器会自动重启。</p>
<h1 id="2-应用程序用户管理"><a class="markdownIt-Anchor" href="#2-应用程序用户管理"></a> 2. 应用程序：用户管理</h1>
<p>现在，您已经构建并部署了最初的 Django 应用程序。下一步，经销商的管理员将查看应用程序，以识别用户并根据角色（如匿名用户或注册用户）管理其访问权限。为此，您需要在应用程序中添加身份验证和授权，即用户管理。在本课中，您需要执行以下任务来添加用户管理功能：</p>
<ul>
<li>为应用程序创建超级用户。</li>
<li>构建客户端并进行配置。</li>
<li>检查客户端配置。</li>
<li>添加登录视图以处理登录请求。</li>
<li>添加注销视图以处理注销请求。</li>
<li>添加注册视图来处理注册请求。</li>
</ul>
<h2 id="21-为您的应用创建超级用户"><a class="markdownIt-Anchor" href="#21-为您的应用创建超级用户"></a> 2.1. 为您的应用创建超级用户</h2>
<p>运行以下命令创建超级用户：</p>
<pre><code class="language-bash">python manage.py createsuperuser</code></pre>
<p>输入用户名、电子邮件和密码后，您应该会看到 <code>Superuser created successfully</code> 的信息，表明超级用户已创建。执行以下命令运行服务器：</p>
<pre><code class="language-bash">python manage.py runserver</code></pre>
<p>请在端口 <code>8000</code> 上启动应用程序，并在 URL 末尾添加 <code>/admin</code>，以进入 Django 管理用户界面。使用刚刚为超级用户创建的凭据登录管理员站点。单击 <code>AUTHENTICATION AND AUTHORIZATION</code> 部分下的 <code>Users</code>。您应该可以查看刚刚创建的超级用户。</p>
<h2 id="22-构建客户端并进行配置"><a class="markdownIt-Anchor" href="#22-构建客户端并进行配置"></a> 2.2. 构建客户端并进行配置</h2>
<p>打开新终端，切换到客户端目录：</p>
<pre><code class="language-bash">cd /server/frontend</code></pre>
<p>安装所有必需的软件包：</p>
<pre><code class="language-bash">npm install</code></pre>
<p>运行以下命令构建客户端：</p>
<pre><code class="language-bash">npm run build</code></pre>
<p>在编辑器中打开 <code>server/djangoproj/settings.py</code>。在 <code>TEMPLATES</code> 下可以找到 <code>DIRS</code>。在列表中添加 <code>os.path.join(BASE_DIR,'frontend/build')</code>，以便 Django 应用程序识别前端。设置如下：</p>
<pre><code class="language-python">&#x27;DIRS&#x27;: [
    os.path.join(BASE_DIR, &#x27;frontend/static&#x27;),
    os.path.join(BASE_DIR, &#x27;frontend/build&#x27;),
    os.path.join(BASE_DIR, &#x27;frontend/build/static&#x27;),
],</code></pre>
<p>在 <code>server/djangoproj/settings.py</code> 中，将 Django 应用程序查找静态文件的目录添加到名为 <code>STATICFILES_DIRS</code> 的列表中。设置如下：</p>
<pre><code class="language-python">STATICFILES_DIRS = [
    os.path.join(BASE_DIR, &#x27;frontend/static&#x27;),
    os.path.join(BASE_DIR, &#x27;frontend/build&#x27;),
    os.path.join(BASE_DIR, &#x27;frontend/build/static&#x27;),
]</code></pre>
<h2 id="23-添加新的登录视图"><a class="markdownIt-Anchor" href="#23-添加新的登录视图"></a> 2.3. 添加新的登录视图</h2>
<p>接下来，您需要创建一个新的登录 Django 视图来处理登录请求。打开 <code>djangoapp/views.py</code>，取消顶部的导入语句。观察登录视图以验证用户身份。用户登录后，视图会返回一个包含用户名和状态的 JSON 对象。</p>
<p>打开 <code>server/djangoapp/urls.py</code>，取消注释顶部的导入语句：</p>
<pre><code class="language-python">from django.urls import path
from django.conf.urls.static import static
from django.conf import settings
from . import views</code></pre>
<p>通过取消对 <code>server/djangoapp/urls.py</code> 中路径条目的注释，为登录视图配置路由，如下所示：</p>
<pre><code class="language-python">path(route=&#x27;login&#x27;, view=views.login_user, name=&#x27;login&#x27;),</code></pre>
<p>如下所示，在 <code>server/djangoproj/urls.py</code> 中添加路径条目，为登录页面配置路由。登录页面是通过 <code>/server/frontend/src/App.js</code> 中配置的路由呈现的 React 页面。</p>
<pre><code class="language-python">path(&#x27;login/&#x27;, TemplateView.as_view(template_name=&quot;index.html&quot;)),</code></pre>
<h2 id="24-添加注销功能"><a class="markdownIt-Anchor" href="#24-添加注销功能"></a> 2.4. 添加注销功能</h2>
<p>您需要创建一个新的注销 Django 视图来处理注销请求。</p>
<p>打开 <code>djangoapp/views.py</code>，添加一个新的注销视图来处理注销请求。用户注销后，视图应返回一个包含用户名的 JSON 对象。</p>
<pre><code class="language-python">def logout_request(request):
    logout(request)
    data = &#123;&quot;userName&quot;: &quot;&quot;&#125;
    return JsonResponse(data)</code></pre>
<p>在 <code>djangoapp/urls.py</code> 中添加路径条目，为注销视图配置路由：</p>
<pre><code class="language-python">path(route=&#x27;logout&#x27;, view=views.logout_request, name=&#x27;logout&#x27;),</code></pre>
<p>在 <code>server/frontend/static/Home.html</code> 中的空白处加入以下代码，以处理用户退出登录：</p>
<pre><code class="language-python">const logout = async (e) =&gt; &#123;
  let logout_url = window.location.origin+&quot;/djangoapp/logout&quot;;
  const res = await fetch(logout_url, &#123;
    method: &quot;GET&quot;,
  &#125;);

  const json = await res.json();
  if (json) &#123;
    let username = sessionStorage.getItem(&#x27;username&#x27;);
    sessionStorage.removeItem(&#x27;username&#x27;);
    window.location.href = window.location.origin;
    window.location.reload();
    alert(&quot;Logging out &quot;+username+&quot;...&quot;)
  &#125;
  else &#123;
    alert(&quot;The user could not be logged out.&quot;)
  &#125;
&#125;;</code></pre>
<p>打开一个新的终端，运行以下命令：</p>
<pre><code class="language-bash">cd /server/frontend
npm run build</code></pre>
<p>如果会话没有过期，您将从上一步登录。如果没有，请登录，然后单击 <code>Logout</code>。</p>
<h2 id="25-添加注册功能"><a class="markdownIt-Anchor" href="#25-添加注册功能"></a> 2.5. 添加注册功能</h2>
<p>您需要创建一个新的注册 Django 视图来处理注册请求。</p>
<p>打开 <code>djangoapp/views.py</code>，添加一个新的注册视图来处理注册请求。用户注册时，应创建一个用户对象，并登录该用户。它应返回一个包含用户名的 JSON 对象。</p>
<pre><code class="language-python">@csrf_exempt
def registration(request):
    context = &#123;&#125;

    data = json.loads(request.body)
    username = data[&#x27;userName&#x27;]
    password = data[&#x27;password&#x27;]
    first_name = data[&#x27;firstName&#x27;]
    last_name = data[&#x27;lastName&#x27;]
    email = data[&#x27;email&#x27;]
    username_exist = False
    email_exist = False
    try:
        # Check if user already exists
        User.objects.get(username=username)
        username_exist = True
    except:
        # If not, simply log this is a new user
        logger.debug(&quot;&#123;&#125; is new user&quot;.format(username))

    # If it is a new user
    if not username_exist:
        # Create user in auth_user table
        user = User.objects.create_user(username=username, first_name=first_name, last_name=last_name,password=password, email=email)
        # Login the user and redirect to list page
        login(request, user)
        data = &#123;&quot;userName&quot;:username,&quot;status&quot;:&quot;Authenticated&quot;&#125;
        return JsonResponse(data)
    else :
        data = &#123;&quot;userName&quot;:username,&quot;error&quot;:&quot;Already Registered&quot;&#125;
        return JsonResponse(data)</code></pre>
<p>在 <code>djangoapp/urls.py</code> 中添加路径条目，为注册视图配置路由：</p>
<pre><code class="language-python">path(route=&#x27;register&#x27;, view=views.registration, name=&#x27;register&#x27;),</code></pre>
<p>在 <code>frontend/src/components/Register</code> 中创建一个名为 <code>Register.jsx</code> 的文件。我们已经提供了该页面要使用的 CSS。在 <code>Register.jsx</code> 中添加以下代码：</p>
<pre><code class="language-jsx">import React, &#123; useState &#125; from &quot;react&quot;;
import &quot;./Register.css&quot;;
import user_icon from &quot;../assets/person.png&quot;
import email_icon from &quot;../assets/email.png&quot;
import password_icon from &quot;../assets/password.png&quot;
import close_icon from &quot;../assets/close.png&quot;

const Register = () =&gt; &#123;

  const [userName, setUserName] = useState(&quot;&quot;);
  const [password, setPassword] = useState(&quot;&quot;);
  const [email, setEmail] = useState(&quot;&quot;);
  const [firstName, setFirstName] = useState(&quot;&quot;);
  const [lastName, setlastName] = useState(&quot;&quot;);


  const gohome = ()=&gt; &#123;
    window.location.href = window.location.origin;
  &#125;

  const register = async (e) =&gt; &#123;
    e.preventDefault();

    let register_url = window.location.origin+&quot;/djangoapp/register&quot;;
    
    const res = await fetch(register_url, &#123;
        method: &quot;POST&quot;,
        headers: &#123;
            &quot;Content-Type&quot;: &quot;application/json&quot;,
        &#125;,
        body: JSON.stringify(&#123;
            &quot;userName&quot;: userName,
            &quot;password&quot;: password,
            &quot;firstName&quot;:firstName,
            &quot;lastName&quot;:lastName,
            &quot;email&quot;:email
        &#125;),
    &#125;);

    const json = await res.json();
    if (json.status) &#123;
        sessionStorage.setItem(&#x27;username&#x27;, json.userName);
        window.location.href = window.location.origin;
    &#125;
    else if (json.error === &quot;Already Registered&quot;) &#123;
      alert(&quot;The user with same username is already registered&quot;);
      window.location.href = window.location.origin;
    &#125;
&#125;;

  return(
    &lt;div className=&quot;register_container&quot; style=&#123;&#123;width: &quot;50%&quot;&#125;&#125;&gt;
      &lt;div className=&quot;header&quot; style=&#123;&#123;display: &quot;flex&quot;,flexDirection: &quot;row&quot;, justifyContent: &quot;space-between&quot;&#125;&#125;&gt;
          &lt;span className=&quot;text&quot; style=&#123;&#123;flexGrow:&quot;1&quot;&#125;&#125;&gt;SignUp&lt;/span&gt; 
          &lt;div style=&#123;&#123;display: &quot;flex&quot;,flexDirection: &quot;row&quot;, justifySelf: &quot;end&quot;, alignSelf: &quot;start&quot; &#125;&#125;&gt;
          &lt;a href=&quot;/&quot; onClick=&#123;()=&gt;&#123;gohome()&#125;&#125; style=&#123;&#123;justifyContent: &quot;space-between&quot;, alignItems:&quot;flex-end&quot;&#125;&#125;&gt;
            &lt;img style=&#123;&#123;width:&quot;1cm&quot;&#125;&#125; src=&#123;close_icon&#125; alt=&quot;X&quot;/&gt;
          &lt;/a&gt;
          &lt;/div&gt;
          &lt;hr/&gt;
        &lt;/div&gt;

        &lt;form onSubmit=&#123;register&#125;&gt;
        &lt;div className=&quot;inputs&quot;&gt;
          &lt;div className=&quot;input&quot;&gt;
            &lt;img src=&#123;user_icon&#125; className=&quot;img_icon&quot; alt=&#x27;Username&#x27;/&gt;
            &lt;input type=&quot;text&quot;  name=&quot;username&quot; placeholder=&quot;Username&quot; className=&quot;input_field&quot; onChange=&#123;(e) =&gt; setUserName(e.target.value)&#125;/&gt;
          &lt;/div&gt;
          &lt;div&gt;
            &lt;img src=&#123;user_icon&#125; className=&quot;img_icon&quot; alt=&#x27;First Name&#x27;/&gt;
            &lt;input type=&quot;text&quot;  name=&quot;first_name&quot; placeholder=&quot;First Name&quot; className=&quot;input_field&quot; onChange=&#123;(e) =&gt; setFirstName(e.target.value)&#125;/&gt;
          &lt;/div&gt;

          &lt;div&gt;
            &lt;img src=&#123;user_icon&#125; className=&quot;img_icon&quot; alt=&#x27;Last Name&#x27;/&gt;
            &lt;input type=&quot;text&quot;  name=&quot;last_name&quot; placeholder=&quot;Last Name&quot; className=&quot;input_field&quot; onChange=&#123;(e) =&gt; setlastName(e.target.value)&#125;/&gt;
          &lt;/div&gt;

          &lt;div&gt;
            &lt;img src=&#123;email_icon&#125; className=&quot;img_icon&quot; alt=&#x27;Email&#x27;/&gt;
            &lt;input type=&quot;email&quot;  name=&quot;email&quot; placeholder=&quot;email&quot; className=&quot;input_field&quot; onChange=&#123;(e) =&gt; setEmail(e.target.value)&#125;/&gt;
          &lt;/div&gt;

          &lt;div className=&quot;input&quot;&gt;
            &lt;img src=&#123;password_icon&#125; className=&quot;img_icon&quot; alt=&#x27;password&#x27;/&gt;
            &lt;input name=&quot;psw&quot; type=&quot;password&quot;  placeholder=&quot;Password&quot; className=&quot;input_field&quot; onChange=&#123;(e) =&gt; setPassword(e.target.value)&#125;/&gt;
          &lt;/div&gt;

        &lt;/div&gt;
        &lt;div className=&quot;submit_panel&quot;&gt;
          &lt;input className=&quot;submit&quot; type=&quot;submit&quot; value=&quot;Register&quot;/&gt;
        &lt;/div&gt;
      &lt;/form&gt;
      &lt;/div&gt;
  )
&#125;

export default Register;</code></pre>
<p>在 <code>frontend/src/App.js</code> 中配置路由：</p>
<pre><code class="language-javascript">&lt;Route path=&quot;/register&quot; element=&#123;&lt;Register /&gt;&#125; /&gt;</code></pre>
<p>在之前用于运行 <code>npm run build</code> 的终端中，再次运行以反映最新更改。</p>
<p>在编辑器中打开 <code>server/djangoproj/urls.py</code>，在 <code>urlpatterns</code> 中添加以下路径。路由已在 <code>App.js</code> 中配置：</p>
<pre><code class="language-python">path(&#x27;register/&#x27;, TemplateView.as_view(template_name=&quot;index.html&quot;)),</code></pre>
<p>如果已登录，请注销，然后点击 <code>Register</code> 链接。您将看到如下所示的注册页面。</p>
<h1 id="3-后端服务"><a class="markdownIt-Anchor" href="#3-后端服务"></a> 3. 后端服务</h1>
<p>在本模块中，您将在 Express 应用程序中实现一些与 MongoDB 进行交易的端点。然后使用 Docker 将 Mongo 和 Express 服务器容器化并运行。此外，您还将使用 Django 模型设置 <code>CarMake</code> 和 <code>CarModel</code>，并填充数据库。然后，将情感分析器部署到 IBM 代码引擎。最后，您将创建代理服务来访问这些外部服务。</p>
<p>您在上一个模块中创建的 Django 应用程序需要与数据库通信。在本模块中，您将创建一个容器化的 Node.js 应用程序，使用 MongoDB 作为后端为 API 端点提供服务。</p>
<p>您将在 Express 应用程序中编写这些后端服务，并使用 Docker 将其容器化。</p>
<p>您将查看和测试以下端点：</p>
<ul>
<li><code>/fetchReviews/dealer/29</code></li>
<li><code>/fetchDealers</code></li>
<li><code>/fetchDealer/3</code></li>
<li><code>/fetchDealers/Kansas</code></li>
</ul>
<h2 id="31-使用-express-mongo-实现应用程序接口端点"><a class="markdownIt-Anchor" href="#31-使用-express-mongo-实现应用程序接口端点"></a> 3.1. 使用 <code>Express-Mongo</code> 实现应用程序接口端点</h2>
<p>切换到包含数据文件的目录：</p>
<pre><code class="language-bash">cd /server/database</code></pre>
<p>在在线课程实验项目中，我们为您提供了两个用于 <code>Reviews</code> 和 <code>Dealerships</code> 实体的模式文件，以及包含要加载到 MongoDB 并通过端点提供的经销商和评论数据的 JSON 文件。</p>
<ul>
<li><code>server/database/data/dealerships.json</code></li>
<li><code>server/database/data/reviews.json</code></li>
</ul>
<p>Node 应用程序将使用 <code>mongoose</code> 与 MongoDB 交互。评论和经销商的模式分别在 <code>review.js</code> 和 <code>dealership.js</code> 中定义。</p>
<p>查看 <code>server/database/app.js</code> 中的内容。它将提供以下端点：</p>
<ul>
<li><code>fetchReviews</code>（用于获取所有评论）</li>
<li><code>fetchReviews/dealer/:id</code>（用于获取特定经销商的评论）</li>
<li><code>fetchDealers</code>（用于获取所有经销商的评论）</li>
<li><code>fetchDealers/:state</code>（用于获取某一州的所有经销商信息）</li>
<li><code>fetchDealer/:id</code>（按 ID 查找经销商）</li>
<li><code>insert_review</code>（用于插入评论）</li>
</ul>
<p>有些端点已经为您实施。请利用这些想法和先前的学习成果，实施尚未实施的端点。</p>
<h4 id="311-与-mongoose-合作提供-api-端点"><a class="markdownIt-Anchor" href="#311-与-mongoose-合作提供-api-端点"></a> 3.1.1. 与 Mongoose 合作提供 API 端点</h4>
<p>运行以下命令来构建 Docker 应用程序。记住，每次更改 <code>app.js</code> 时都要这样做。</p>
<div class="danger">
<p>请确保你的计算机里有安装 Docker。</p>
<p>运行 Docker 还需要开启 Hyper-V，可以上网找教程。</p>
</div>
<pre><code class="language-bash">docker build . -t nodeapp</code></pre>
<p>我们创建了用于运行两个容器的 <code>docker-compose.yml</code>，一个用于 Mongo，另一个用于 Node 应用程序。运行以下命令来运行服务器：</p>
<pre><code class="language-bash">docker-compose up</code></pre>
<h4 id="312-创建应用程序接口端点-url"><a class="markdownIt-Anchor" href="#312-创建应用程序接口端点-url"></a> 3.1.2. 创建应用程序接口端点 URL</h4>
<p>实现 <code>server/database/app.js</code> 中尚未实施的以下端点（可以直接参考已经被实现的端点写法）：</p>
<ul>
<li>
<p><code>fetchDealers</code>：</p>
<pre><code class="language-js">app.get(&#x27;/fetchDealers&#x27;, async (req, res) =&gt; &#123;
  try &#123;
    const documents = await Dealerships.find();
    res.json(documents);
  &#125; catch (error) &#123;
    res.status(500).json(&#123; error: &#x27;Error fetching documents&#x27; &#125;);
  &#125;
&#125;);</code></pre>
</li>
<li>
<p><code>fetchDealers/:state</code>：</p>
<pre><code class="language-js">app.get(&#x27;/fetchDealers/:state&#x27;, async (req, res) =&gt; &#123;
  try &#123;
    const documents = await Dealerships.find(&#123;state: req.params.state&#125;);
    res.json(documents);
  &#125; catch (error) &#123;
    res.status(500).json(&#123; error: &#x27;Error fetching documents&#x27; &#125;);
  &#125;
&#125;);</code></pre>
</li>
<li>
<p><code>fetchDealer/:id</code>：</p>
<pre><code class="language-js">app.get(&#x27;/fetchDealer/:id&#x27;, async (req, res) =&gt; &#123;
  try &#123;
    const documents = await Dealerships.find(&#123;id: req.params.id&#125;);
    res.json(documents);
  &#125; catch (error) &#123;
    res.status(500).json(&#123; error: &#x27;Error fetching documents&#x27; &#125;);
  &#125;
&#125;);</code></pre>
</li>
</ul>
<p>写完后，停止上一个任务中启动的 Docker 应用程序，接着再次执行 <code>docker build</code> 和 <code>docker-compose</code> 命令。</p>
<p>在 <code>3030</code> 端口中测试以下端点：</p>
<ul>
<li><code>/fetchReviews/dealer/29</code></li>
<li><code>/fetchDealers</code></li>
<li><code>/fetchDealer/3</code></li>
<li><code>/fetchDealers/Kansas</code></li>
</ul>
<h2 id="32-构建-carmodel-和-carmake-django-模型"><a class="markdownIt-Anchor" href="#32-构建-carmodel-和-carmake-django-模型"></a> 3.2. 构建 <code>CarModel</code> 和 <code>CarMake</code> Django 模型</h2>
<p>您已经创建了一个经销商和与 CRUD API 相关的评论。接下来，您需要为经销商的库存创建数据模型和服务。</p>
<p>每个经销商都管理着不同车型和品牌的汽车库存，这些都是相对静态的数据，因此适合本地存储在 Django 中。要集成外部经销商和审查数据，您需要从 Django 应用程序调用 API，并在 Django 视图中处理 API 结果，然后通过 React 页面呈现。此类 Django 视图使用代理服务根据用户请求从外部资源获取数据，并使用 React 组件进行渲染。</p>
<p>在本课中，您需要执行以下任务来添加汽车模型、与汽车相关的模型和视图以及代理服务：</p>
<ul>
<li>创建 <code>CarModel</code> 和 <code>CarMake</code> Django 模型</li>
<li>在管理网站注册 <code>CarModel</code> 和 <code>CarMake</code> 模型</li>
<li>创建带有相关汽车品牌和经销商的新汽车模型对象</li>
</ul>
<h4 id="321-建立-carmodel-和-carmake-模型的步骤"><a class="markdownIt-Anchor" href="#321-建立-carmodel-和-carmake-模型的步骤"></a> 3.2.1. 建立 <code>CarModel</code> 和 <code>CarMake</code> 模型的步骤</h4>
<p>您需要在 <code>server/djangoapp/models.py</code> 中创建两个新模型：</p>
<ul>
<li>一个 <code>CarMake</code> 模型，用于保存汽车品牌的一些数据。</li>
<li>一个 <code>CarModel</code> 模型，用于保存汽车模型的一些数据。</li>
</ul>
<p>创建汽车制造商 Django 模型 <code>class CarMake(models.Model)</code>：</p>
<ul>
<li>名称</li>
<li>描述</li>
<li>你想包含在汽车品牌中的任何其他字段</li>
<li>打印汽车品牌对象的 <code>__str__</code> 方法</li>
</ul>
<pre><code class="language-python">class CarMake(models.Model):
    name = models.CharField(max_length=100)
    description = models.TextField()

    def __str__(self):
        return self.name</code></pre>
<p>创建汽车模型 Django 模型 <code>class CarModel(models.Model)</code>：</p>
<ul>
<li>与 <code>CarMake</code> 模型的多对一关系（使用外键字段，一个汽车品牌可以有多个汽车型号）</li>
<li>经销商 ID（整数字段）指 Cloudant 数据库中创建的经销商</li>
<li>名称</li>
<li>类型（带选择参数的 <code>CharField</code>，用于提供有限的选择，如轿车、SUV 和旅行车）</li>
<li>年份（日期字段）</li>
<li>您希望包含在汽车模型中的任何其他字段</li>
<li>打印汽车品牌和车型对象的 <code>__str__</code> 方法</li>
</ul>
<pre><code class="language-python">class CarModel(models.Model):
    car_make = models.ForeignKey(CarMake, on_delete=models.CASCADE)  # Many-to-One relationship
    name = models.CharField(max_length=100)
    CAR_TYPES = [
        (&#x27;SEDAN&#x27;, &#x27;Sedan&#x27;),
        (&#x27;SUV&#x27;, &#x27;SUV&#x27;),
        (&#x27;WAGON&#x27;, &#x27;Wagon&#x27;),
        # Add more choices as required
    ]
    type = models.CharField(max_length=10, choices=CAR_TYPES, default=&#x27;SUV&#x27;)
    year = models.IntegerField(default=2023,
        validators=[
            MaxValueValidator(2023),
            MinValueValidator(2015)
        ])

    def __str__(self):
        return self.name</code></pre>
<p>您需要在管理网站上注册 <code>CarMake</code> 和 <code>CarModel</code>，这样就可以方便地管理它们的内容（即执行 CRUD 操作）：</p>
<pre><code class="language-python"># djangoapp/admin.py

from django.contrib import admin
from .models import CarMake, CarModel

admin.site.register(CarMake)
admin.site.register(CarModel)</code></pre>
<p>为模型运行迁移：</p>
<pre><code class="language-bash">python manage.py makemigrations
python manage.py migrate --run-syncdb</code></pre>
<blockquote>
<p><code>--run-syncdb</code> 允许在不迁移的情况下为应用程序创建表格。</p>
</blockquote>
<h4 id="322-在管理网站注册-carmake-和-carmodel-模型的步骤"><a class="markdownIt-Anchor" href="#322-在管理网站注册-carmake-和-carmodel-模型的步骤"></a> 3.2.2. 在管理网站注册 <code>CarMake</code> 和 <code>CarModel</code> 模型的步骤</h4>
<p>打开 <code>djangoapp/views.py</code>，在文件开头的其他导入语句之后导入 <code>CarMake</code> 和 <code>CarModel</code>，然后添加一个方法来获取汽车列表，方法中包含以下代码：</p>
<pre><code class="language-python">from .models import CarMake, CarModel

# ...

def get_cars(request):
    count = CarMake.objects.filter().count()
    print(count)
    if(count == 0):
        initiate()
    car_models = CarModel.objects.select_related(&#x27;car_make&#x27;)
    cars = []
    for car_model in car_models:
        cars.append(&#123;&quot;CarModel&quot;: car_model.name, &quot;CarMake&quot;: car_model.car_make.name&#125;)
    return JsonResponse(&#123;&quot;CarModels&quot;:cars&#125;)</code></pre>
<p>打开 <code>server/djangoapp/urls.py</code>，在其中添加 <code>get_cars</code> 的路径：</p>
<pre><code class="language-python">path(route=&#x27;get_cars&#x27;, view=views.get_cars, name =&#x27;getcars&#x27;),</code></pre>
<p>打开 <code>server/djangoapp/populate.py</code>，然后粘贴以下代码，以便在数据库中填充数据。如果 <code>CarModel</code> 为空，则在第一次调用 <code>get_cars</code> 时填充数据。如果您想手动添加数据，请跳过此步骤。</p>
<pre><code class="language-python">from .models import CarMake, CarModel

def initiate():
    car_make_data = [
        &#123;&quot;name&quot;:&quot;NISSAN&quot;, &quot;description&quot;:&quot;Great cars. Japanese technology&quot;&#125;,
        &#123;&quot;name&quot;:&quot;Mercedes&quot;, &quot;description&quot;:&quot;Great cars. German technology&quot;&#125;,
        &#123;&quot;name&quot;:&quot;Audi&quot;, &quot;description&quot;:&quot;Great cars. German technology&quot;&#125;,
        &#123;&quot;name&quot;:&quot;Kia&quot;, &quot;description&quot;:&quot;Great cars. Korean technology&quot;&#125;,
        &#123;&quot;name&quot;:&quot;Toyota&quot;, &quot;description&quot;:&quot;Great cars. Japanese technology&quot;&#125;,
    ]

    car_make_instances = []
    for data in car_make_data:
        car_make_instances.append(CarMake.objects.create(name=data[&#x27;name&#x27;], description=data[&#x27;description&#x27;]))


    # Create CarModel instances with the corresponding CarMake instances
    car_model_data = [
        &#123;&quot;name&quot;:&quot;Pathfinder&quot;, &quot;type&quot;:&quot;SUV&quot;, &quot;year&quot;: 2023, &quot;car_make&quot;:car_make_instances[0]&#125;,
        &#123;&quot;name&quot;:&quot;Qashqai&quot;, &quot;type&quot;:&quot;SUV&quot;, &quot;year&quot;: 2023, &quot;car_make&quot;:car_make_instances[0]&#125;,
        &#123;&quot;name&quot;:&quot;XTRAIL&quot;, &quot;type&quot;:&quot;SUV&quot;, &quot;year&quot;: 2023, &quot;car_make&quot;:car_make_instances[0]&#125;,
        &#123;&quot;name&quot;:&quot;A-Class&quot;, &quot;type&quot;:&quot;SUV&quot;, &quot;year&quot;: 2023, &quot;car_make&quot;:car_make_instances[1]&#125;,
        &#123;&quot;name&quot;:&quot;C-Class&quot;, &quot;type&quot;:&quot;SUV&quot;, &quot;year&quot;: 2023, &quot;car_make&quot;:car_make_instances[1]&#125;,
        &#123;&quot;name&quot;:&quot;E-Class&quot;, &quot;type&quot;:&quot;SUV&quot;, &quot;year&quot;: 2023, &quot;car_make&quot;:car_make_instances[1]&#125;,
        &#123;&quot;name&quot;:&quot;A4&quot;, &quot;type&quot;:&quot;SUV&quot;, &quot;year&quot;: 2023, &quot;car_make&quot;:car_make_instances[2]&#125;,
        &#123;&quot;name&quot;:&quot;A5&quot;, &quot;type&quot;:&quot;SUV&quot;, &quot;year&quot;: 2023, &quot;car_make&quot;:car_make_instances[2]&#125;,
        &#123;&quot;name&quot;:&quot;A6&quot;, &quot;type&quot;:&quot;SUV&quot;, &quot;year&quot;: 2023, &quot;car_make&quot;:car_make_instances[2]&#125;,
        &#123;&quot;name&quot;:&quot;Sorrento&quot;, &quot;type&quot;:&quot;SUV&quot;, &quot;year&quot;: 2023, &quot;car_make&quot;:car_make_instances[3]&#125;,
        &#123;&quot;name&quot;:&quot;Carnival&quot;, &quot;type&quot;:&quot;SUV&quot;, &quot;year&quot;: 2023, &quot;car_make&quot;:car_make_instances[3]&#125;,
        &#123;&quot;name&quot;:&quot;Cerato&quot;, &quot;type&quot;:&quot;Sedan&quot;, &quot;year&quot;: 2023, &quot;car_make&quot;:car_make_instances[3]&#125;,
        &#123;&quot;name&quot;:&quot;Corolla&quot;, &quot;type&quot;:&quot;Sedan&quot;, &quot;year&quot;: 2023, &quot;car_make&quot;:car_make_instances[4]&#125;,
        &#123;&quot;name&quot;:&quot;Camry&quot;, &quot;type&quot;:&quot;Sedan&quot;, &quot;year&quot;: 2023, &quot;car_make&quot;:car_make_instances[4]&#125;,
        &#123;&quot;name&quot;:&quot;Kluger&quot;, &quot;type&quot;:&quot;SUV&quot;, &quot;year&quot;: 2023, &quot;car_make&quot;:car_make_instances[4]&#125;,
    ]

    for data in car_model_data:
        CarModel.objects.create(name=data[&#x27;name&#x27;], car_make=data[&#x27;car_make&#x27;], type=data[&#x27;type&#x27;], year=data[&#x27;year&#x27;])</code></pre>
<p>如果您想手动添加汽车品牌和型号，也可以进入管理页面，根据自己的意愿添加。请注意，在项目后期，您只能从这些表格中选择一个品牌和车型发表评论。</p>
<p>进入 <code>127.0.0.1:8000/djangoapp/get_cars</code> 来查看已添加的汽车列表。</p>
<h2 id="33-创建后台-api-的-django-代理服务"><a class="markdownIt-Anchor" href="#33-创建后台-api-的-django-代理服务"></a> 3.3. 创建后台 API 的 Django 代理服务</h2>
<p>在之前的实验中，您创建了 <code>CarModel</code> 和 <code>CarMake</code> 的 Django 模型，这些模型驻留在本地 SQLite 存储库中。您还获得了由 Express API 端点提供服务的经销商和评论模型 Mongo DB。</p>
<p>现在，您需要集成这些模型和服务，以管理经销商和评论等所有实体。</p>
<p>要集成外部经销商和评论数据，您需要从 Django 应用程序调用 API 端点，并在 Django 视图中处理 API 结果。这些 Django 视图可以看作是终端用户的代理服务，因为它们会根据用户的请求从外部资源获取数据。</p>
<p>在本实验中，您将创建此类 Django 视图作为代理服务。</p>
<h4 id="331-运行-mongo-服务器"><a class="markdownIt-Anchor" href="#331-运行-mongo-服务器"></a> 3.3.1. 运行 Mongo 服务器</h4>
<p>后端 Mongo Express 服务器需要在实验室环境中的一个终端启动并运行。在这一阶段，服务器代码已经实现了所有的终端点。运行 <code>docker-compose up</code> 来启动服务器（端口 <code>3030</code>）。</p>
<p>打开 <code>djangoapp/.env</code>，将您的后台网址替换为上一步在记事本中复制的后台网址：</p>
<blockquote>
<p>确保末尾的 <code>/</code> 没有被复制。</p>
</blockquote>
<pre><code class="language-plaintext">backend_url=your backend url</code></pre>
<h4 id="332-创建与后端交互的函数"><a class="markdownIt-Anchor" href="#332-创建与后端交互的函数"></a> 3.3.2. 创建与后端交互的函数</h4>
<p>在之前的实验中，您已经创建了用于 <code>fetchReviews</code> 和 <code>fetchDealers</code> 的 API 端点。现在实现一个方法来从 Django 应用程序访问这些端点。</p>
<p>在 Django 中，有许多方法可以进行 HTTP 请求。这里我们使用一个非常流行且易于使用的 Python 库，名为 <code>requests</code>。</p>
<p>打开 <code>djangoapp/restapis.py</code>，添加 <code>get_request</code> 方法，如下所示：</p>
<pre><code class="language-python">def get_request(endpoint, **kwargs):
    params = &quot;&quot;
    if(kwargs):
        for key,value in kwargs.items():
            params=params+key+&quot;=&quot;+value+&quot;&amp;&quot;

    request_url = backend_url+endpoint+&quot;?&quot;+params

    print(&quot;GET from &#123;&#125; &quot;.format(request_url))
    try:
        # Call get method of requests library with URL and parameters
        response = requests.get(request_url)
        return response.json()
    except:
        # If any error occurs
        print(&quot;Network exception occurred&quot;)</code></pre>
<h4 id="333-启动-code-engine"><a class="markdownIt-Anchor" href="#333-启动-code-engine"></a> 3.3.3. 启动 Code Engine</h4>
<blockquote>
<p>以下为 Code Engine 相关。该课程采用的是 IBM 的 Skills Network 实验环境，Code Engine 被直接嵌入在这个实验环境中。</p>
</blockquote>
<p>创建一个项目，启动 Code Engine。Code Engine 环境需要一段时间来准备。您将在设置面板中看到进度状态。</p>
<p>Code Engine 设置完成后，您可以看到它已激活。单击 <code>Code Engine CLI</code>，在下面的终端中开始预配置的 CLI。</p>
<h4 id="334-将情感分析作为微服务部署在-code-engine-上"><a class="markdownIt-Anchor" href="#334-将情感分析作为微服务部署在-code-engine-上"></a> 3.3.4. 将情感分析作为微服务部署在 Code Engine 上</h4>
<p>在 Code Engine CLI 中，更改为 <code>server/djangoapp/microservices</code> 目录：</p>
<pre><code class="language-bash">cd xrwvm-fullstack_developer_capstone/server/djangoapp/microservices</code></pre>
<p>我们为您提供了使用 NLTK 进行情感分析的 <code>sentiment_analyzer.py</code>。我们还为您提供了一个 Dockerfile，您将使用它在代码引擎中部署此服务，并将其作为微服务使用。</p>
<p>运行以下命令，用 Docker 构建情感分析应用程序（请注意，代码引擎实例是瞬时的，并附在你的实验室空间用户名上）：</p>
<pre><code class="language-bash">docker build . -t us.icr.io/$&#123;SN_ICR_NAMESPACE&#125;/senti_analyzer</code></pre>
<p>运行以下命令推送 Docker 镜像：</p>
<pre><code class="language-bash">docker push us.icr.io/$&#123;SN_ICR_NAMESPACE&#125;/senti_analyzer</code></pre>
<p>在 Code Engine 上部署 <code>senti_analyzer</code> 应用程序：</p>
<pre><code class="language-bash">ibmcloud ce application create --name sentianalyzer --image us.icr.io/$&#123;SN_ICR_NAMESPACE&#125;/senti_analyzer --registry-secret icr-secret --port 5000</code></pre>
<p>连接到生成的 URL 以访问微服务，并检查部署是否成功。如果应用程序部署验证成功，请在浏览器中将 <code>/analyze/Fantastic</code> 服务附加到 URL，查看是否返回正值。</p>
<p>打开 <code>djangoapp/.env</code>，将 Code Engine 部署 URL 替换为上文获得的部署 URL：</p>
<pre><code class="language-plaintext">sentiment_analyzer_url=your code engine deployment url</code></pre>
<blockquote>
<p>URL 最后的 <code>/</code> 要去掉。</p>
</blockquote>
<blockquote>
<p>如果想要在本地环境中部署该微服务，可以进入 <code>/server/djangoapp/microservices</code> 目录，启动 Docker：</p>
<pre><code class="language-bash">docker build -t sentiment_app .
docker run -p 5050:5050 my_microservice</code></pre>
<p>然后要在 <code>.env</code> 文件中注释掉 <code>sentiment_analyzer_url</code> 一行。</p>
</blockquote>
<p>更新 <code>djangoapp/restapis.py</code>，并在其中添加以下函数，以使用微服务分析情感：</p>
<pre><code class="language-python">def analyze_review_sentiments(text):
    request_url = sentiment_analyzer_url+&quot;/analyze/&quot;+text
    try:
        # Call get method of requests library with URL and parameters
        response = requests.get(request_url)
        return response.json()
    except Exception as err:
        print(f&quot;Unexpected &#123;err=&#125;, &#123;type(err)=&#125;&quot;)
        print(&quot;Network exception occurred&quot;)</code></pre>
<h4 id="335-创建-django-视图以获取经销商"><a class="markdownIt-Anchor" href="#335-创建-django-视图以获取经销商"></a> 3.3.5. 创建 Django 视图以获取经销商</h4>
<p>使用以下代码更新 <code>djangoapp/views.py</code> 中的 <code>get_dealerships</code> 视图方法。它将使用您在 <code>restapis.py</code> 中通过 <code>/fetchDealers</code> 端点实现的 <code>get_request</code>。</p>
<pre><code class="language-python">def get_dealerships(request, state=&quot;All&quot;):
    if(state == &quot;All&quot;):
        endpoint = &quot;/fetchDealers&quot;
    else:
        endpoint = &quot;/fetchDealers/&quot;+state
    dealerships = get_request(endpoint)
    return JsonResponse(&#123;&quot;status&quot;:200,&quot;dealers&quot;:dealerships&#125;)</code></pre>
<p>为 <code>url.py</code> 中的 <code>get_dealerships</code> 视图方法配置路由：</p>
<pre><code class="language-python">path(route=&#x27;get_dealers&#x27;, view=views.get_dealerships, name=&#x27;get_dealers&#x27;),
path(route=&#x27;get_dealers/&lt;str:state&gt;&#x27;, view=views.get_dealerships, name=&#x27;get_dealers_by_state&#x27;),</code></pre>
<p>在 <code>views.py</code> 中创建一个以 <code>dealer_id</code> 为参数的 <code>get_dealer_details</code> 方法，并添加一个映射 <code>urls.py</code>。它将使用你在 <code>restapis.py</code> 中实现的 <code>get_request</code>，并传递 <code>/fetchDealer/&lt;dealer id&gt;</code> 端点。</p>
<pre><code class="language-python">def get_dealer_details(request, dealer_id):
    if(dealer_id):
        endpoint = &quot;/fetchDealer/&quot;+str(dealer_id)
        dealership = get_request(endpoint)
        return JsonResponse(&#123;&quot;status&quot;:200,&quot;dealer&quot;:dealership&#125;)
    else:
        return JsonResponse(&#123;&quot;status&quot;:400,&quot;message&quot;:&quot;Bad Request&quot;&#125;)</code></pre>
<p>同样配置路由：</p>
<pre><code class="language-python">path(route=&#x27;dealer/&lt;int:dealer_id&gt;&#x27;, view=views.get_dealer_details, name=&#x27;dealer_details&#x27;),</code></pre>
<p>在 <code>views.py</code> 中创建以 <code>dealer_id</code> 为参数的 <code>get_dealer_reviews</code> 方法，并添加 <code>urls.py</code> 映射。它将使用在 <code>restapis.py</code> 中实现的 <code>get_request</code>，并传递 <code>/fetchReviews/dealer/&lt;dealer id&gt;</code> 端点。它还将调用 <code>restapis.py</code> 中的 <code>analyze_review_sentiments</code>，以消费微服务并确定每条评论的情感，然后在 <code>review_detail</code> 字典中设置值，并作为 <code>JsonResponse</code> 返回。</p>
<p>情感属性的值将由情感分析微服务决定。它可以是正面的、中性的或负面的。</p>
<pre><code class="language-python">def get_dealer_reviews(request, dealer_id):
    # if dealer id has been provided
    if(dealer_id):
        endpoint = &quot;/fetchReviews/dealer/&quot;+str(dealer_id)
        reviews = get_request(endpoint)
        for review_detail in reviews:
            response = analyze_review_sentiments(review_detail[&#x27;review&#x27;])
            print(response)
            review_detail[&#x27;sentiment&#x27;] = response[&#x27;sentiment&#x27;]
        return JsonResponse(&#123;&quot;status&quot;:200,&quot;reviews&quot;:reviews&#125;)
    else:
        return JsonResponse(&#123;&quot;status&quot;:400,&quot;message&quot;:&quot;Bad Request&quot;&#125;)</code></pre>
<pre><code class="language-python">path(route=&#x27;reviews/dealer/&lt;int:dealer_id&gt;&#x27;, view=views.get_dealer_reviews, name=&#x27;dealer_details&#x27;),</code></pre>
<h4 id="336-创建-django-视图以发布经销商评论"><a class="markdownIt-Anchor" href="#336-创建-django-视图以发布经销商评论"></a> 3.3.6. 创建 Django 视图以发布经销商评论</h4>
<p>你已经学会了如何进行各种 <code>GET</code> 调用，现在来创建 Django 视图以发布经销商评论：打开 <code>restapis.py</code>，添加一个 <code>post_review</code> 方法，该方法将接收一个数据字典，并在后台调用 <code>add_review</code>。字典将以键值对的形式接收经销商评论所需的所有值。</p>
<pre><code class="language-python">def post_review(data_dict):
    request_url = backend_url+&quot;/insert_review&quot;
    try:
        response = requests.post(request_url,json=data_dict)
        print(response.json())
        return response.json()
    except:
        print(&quot;Network exception occurred&quot;)</code></pre>
<p>打开 <code>views.py</code>，创建一个新的 <code>def add_review(request)：</code> 方法来处理评论文章请求。在 <code>add_review</code> 视图方法中：</p>
<ul>
<li>首先检查用户是否通过身份验证，因为只有通过身份验证的用户才能为经销商发布评论。</li>
<li>使用字典调用 <code>post_request</code> 方法。</li>
<li>将 <code>post_request</code> 的结果返回 <code>add_review</code> 视图方法。您可以打印帖子响应。</li>
<li>以 JSON 格式返回成功状态和信息。</li>
<li>在 <code>url.py</code> 中为 <code>add_review</code> 视图配置路由。</li>
</ul>
<pre><code class="language-python">def add_review(request):
    if(request.user.is_anonymous == False):
        data = json.loads(request.body)
        try:
            response = post_review(data)
            return JsonResponse(&#123;&quot;status&quot;:200&#125;)
        except:
            return JsonResponse(&#123;&quot;status&quot;:401,&quot;message&quot;:&quot;Error in posting review&quot;&#125;)
    else:
        return JsonResponse(&#123;&quot;status&quot;:403,&quot;message&quot;:&quot;Unauthorized&quot;&#125;)</code></pre>
<pre><code class="language-python">path(route=&#x27;add_review&#x27;, view=views.add_review, name=&#x27;add_review&#x27;),</code></pre>
<p>从 <code>restapis.py</code> 导入方法，以便在 <code>views.py</code> 中使用：</p>
<pre><code class="language-python">from .restapis import get_request, analyze_review_sentiments, post_review</code></pre>
<h1 id="4-应用程序动态页面"><a class="markdownIt-Anchor" href="#4-应用程序动态页面"></a> 4. 应用程序：动态页面</h1>
<p>在本模块中，您将使用 React 组件添加动态页面，以列出经销商、按州过滤经销商、查看经销商详细信息并添加经销商评论。</p>
<ul>
<li>创建前台页面，向终端用户展示后台服务。</li>
<li>创建一个组件来列出经销商。</li>
<li>开发一个经销商详情和评论组件。</li>
<li>创建评论提交页面。</li>
</ul>
<p>您在上一个模块中创建了所有必要的后台服务（Django 视图和 API 端点），用于管理经销商、评论和汽车。接下来，是时候创建一些风格化的前端 React 页面来向终端用户展示这些服务结果了。在本学习模块中，您需要执行以下任务将前端添加到应用程序中：</p>
<ul>
<li>创建一个经销商组件，列出所有经销商</li>
<li>创建一个经销商详细信息组件，显示特定经销商的评论</li>
<li>创建评论提交页面</li>
</ul>
<h2 id="41-为经销商页面添加和设置-react-组件"><a class="markdownIt-Anchor" href="#41-为经销商页面添加和设置-react-组件"></a> 4.1. 为经销商页面添加和设置 React 组件</h2>
<p>打开 <code>frontend/src/App.js</code>，导入 <code>Dealer</code> 组件并将其与其他组件一起添加到顶部。该组件已为您创建，并使用表格元素列出经销商。您可以随意更改外观和感觉。</p>
<pre><code class="language-jsx">import Dealers from &#x27;./components/Dealers/Dealers&#x27;;</code></pre>
<p>为 <code>/dealers</code> 添加路由，以呈现 <code>Dealers</code> 组件：</p>
<pre><code class="language-jsx">&lt;Route path=&quot;/dealers&quot; element=&#123;&lt;Dealers/&gt;&#125; /&gt;</code></pre>
<p>打开 <code>server/djangoproj/urls.py</code>，在其中添加 <code>Dealers</code> 和 <code>Dealer</code> 的路由：</p>
<pre><code class="language-python">path(&#x27;dealers/&#x27;, TemplateView.as_view(template_name=&quot;index.html&quot;)),</code></pre>
<p>打开一个新终端，像以前一样创建前端。进入 <code>127.0.0.1:8000/dealers</code> 测试 <code>get_dealers</code> 视图。</p>
<h2 id="42-添加-react-组件-dealer-显示评论"><a class="markdownIt-Anchor" href="#42-添加-react-组件-dealer-显示评论"></a> 4.2. 添加 React 组件 <code>Dealer</code> 显示评论</h2>
<p>打开 <code>frontend/src/App.js</code>，导入 <code>Dealer</code> React 组件的路由并将其添加到其他路由中。这样，当您点击经销商表上的链接时，就会呈现一个经销商特定的 React 页面以及评论。</p>
<blockquote>
<p>该页面还有一个链接，可以让已登录的用户发表评论。您将在下一个任务中添加发布评论页面。</p>
</blockquote>
<pre><code class="language-jsx">import Dealer from &quot;./components/Dealers/Dealer&quot;</code></pre>
<pre><code class="language-jsx">&lt;Route path=&quot;/dealer/:id&quot; element=&#123;&lt;Dealer/&gt;&#125; /&gt;</code></pre>
<p>在之前创建前端的同一终端再次创建前端。</p>
<p>打开 <code>server/djangoproj/urls.py</code>，加入以下代码，添加显示经销商页面的路径：</p>
<pre><code class="language-python">path(&#x27;dealer/&lt;int:dealer_id&gt;&#x27;,TemplateView.as_view(template_name=&quot;index.html&quot;)),</code></pre>
<p>刷新应用程序，进入 <code>View Reviews</code> 页面，点击任何经销商的名称链接，查看其评论。</p>
<h2 id="43-创建经销商详情或评论页面"><a class="markdownIt-Anchor" href="#43-创建经销商详情或评论页面"></a> 4.3. 创建经销商详情或评论页面</h2>
<p>通过身份验证的用户应能点击该链接并为经销商添加评论。我们将添加一个评论提交页面。</p>
<p>打开并查看 <code>frontend/src/components/Dealers/PostReview.jsx</code>。根据需要对外观和感觉进行修改。</p>
<p>导入 <code>PostReview</code> 组件，并在 <code>frontend/src/App.js</code> 中添加 <code>postreview/&lt;dealer id&gt;</code> 路由。</p>
<pre><code class="language-jsx">import PostReview from &quot;./components/Dealers/PostReview&quot;</code></pre>
<pre><code class="language-jsx">&lt;Route path=&quot;/postreview/:id&quot; element=&#123;&lt;PostReview/&gt;&#125; /&gt;</code></pre>
<p>转到构建前端的终端，再次运行构建。</p>
<p>打开 <code>server/djangoprojs/urls.py</code>，在其中加入以下代码，以添加审阅后页面的路径：</p>
<pre><code class="language-python">path(&#x27;postreview/&lt;int:dealer_id&gt;&#x27;,TemplateView.as_view(template_name=&quot;index.html&quot;)),</code></pre>
<p>使用已注册的用户名和密码登录。您将看到 <code>Post Review</code> 链接。向经销商添加评论，测试该链接。</p>
<h1 id="5-cicd-容器化和部署到-kubernetes"><a class="markdownIt-Anchor" href="#5-cicd-容器化和部署到-kubernetes"></a> 5. CI/CD、容器化和部署到 Kubernetes</h1>
<p>在本模块中，您将为您创建的所有 JavaScript 和 Python 文件设置一个 CI/CD 操作流程。然后，您将运行所有服务器端组件，包括 Docker 容器中的 Express-Mongo 服务器和代码引擎上的情感分析器无服务器部署。最后，您将构建前端 React 应用程序，并在 Kubernetes 上部署 Django 应用程序。</p>
<ul>
<li>配置 Django 应用程序并将其部署到 Kubernetes。</li>
</ul>
<p>恭喜您在添加静态页面和用户管理后测试了应用程序。下一步是为源代码设置持续集成和持续交付（CI/CD）。如果有多人参与项目，这一点尤为重要。持续集成（CI）为开发人员提供了一种协作方式，而持续交付（CD）则提供了一种不间断地向客户交付变更的方式。在本模块中，您将：</p>
<ul>
<li>了解所提供的 GitHub 工作流程（workflow）模板中的工作流程</li>
<li>了解所提供的 GitHub 工作流程模板中的 Linting 作业</li>
<li>启用 GitHub Actions  并运行 Linting 工作流</li>
</ul>
<blockquote>
<p>Linting 是一种自动检查源代码中是否存在编程和样式错误的方法，通常通过使用 Lint 工具（也称为 Linter）来实现。Lint 工具是一种基础的静态代码分析器。</p>
</blockquote>
<h2 id="51-添加持续集成和持续部署功能"><a class="markdownIt-Anchor" href="#51-添加持续集成和持续部署功能"></a> 5.1. 添加持续集成和持续部署功能</h2>
<p>您的团队正在壮大！管理层决定招聘前端和后端工程师，以确保路线图上的功能能在未来版本中及时开发出来。然而，这意味着多名工程师需要在版本库上并行工作。您的任务是确保推送到主分支的代码符合团队的编码风格，并且没有语法错误。</p>
<p>在本实验中，你将为版本库添加语法检查功能，在开发人员创建拉取请求或将分支合并到默认主分支时自动检查语法错误。在开始实验之前，我们先来了解一下 GitHub Actions。</p>
<h4 id="511-github-actions"><a class="markdownIt-Anchor" href="#511-github-actions"></a> 5.1.1. GitHub Actions</h4>
<p>GitHub Actions 提供了一种事件驱动的方式来自动执行项目中的任务。您可以监听多种事件。下面是几个例子：</p>
<ul>
<li><code>push</code>：当有人向版本库分支（branch）推送时运行任务。</li>
<li><code>pull_request</code>：当有人创建拉取请求（PR）时运行任务。您还可以在某些活动发生时启动任务，例如：
<ul>
<li>PR 已打开</li>
<li>PR 已关闭</li>
<li>PR 被重新打开</li>
</ul>
</li>
<li><code>create</code>：当有人创建分支或标记时运行任务。</li>
<li><code>delete</code>：当有人删除分支或标记时运行任务。</li>
<li><code>manually</code>：手动启动任务。</li>
</ul>
<p>在本实验中，您将使用以下一个或多个组件：</p>
<ul>
<li>Workflows（工作流）：您可以添加到存储库的作业集合。</li>
<li>Events：启动工作流的活动。</li>
<li>Jobs（作业）：一个或多个步骤的序列。作业默认并行运行。</li>
<li>Steps：可在作业中运行的单个任务。一个步骤可以是一个操作或命令。</li>
<li>Actions：工作流的最小模块。</li>
</ul>
<p>下面为您提供了一个工作流程模板。让我们来研究一下：</p>
<pre><code class="language-yaml">name: &#x27;Lint Code&#x27;
on:
  push:
    branches: [master, main]
  pull_request:
    branches: [master, main]
jobs:
  lint_python:
    name: Lint Python Files
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: 3.12
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install flake8
      - name: Print working directory
        run: pwd
      - name: Run Linter
        run: |
          pwd
          # This command finds all Python files recursively and runs flake8 on them
          find . -name &quot;*.py&quot; -exec flake8 &#123;&#125; +
          echo &quot;Linted all the python files successfully&quot;
  lint_js:
    name: Lint JavaScript Files
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3
      - name: Install Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 14
      - name: Install JSHint
        run: npm install jshint --global
      - name: Run Linter
        run: |
          # This command finds all JavaScript files recursively and runs JSHint on them
          find ./server/database -name &quot;*.js&quot; -exec jshint &#123;&#125; +
          echo &quot;Linted all the js files successfully&quot;</code></pre>
<ol>
<li>第一行命名工作流程。</li>
<li>下一行定义了工作流的运行时间。工作流应在开发人员向主分支推送变更或创建 PR 时运行。这两种方式的捕获方式如下：
<ul>
<li>推送到主分支（主分支或主分支）时运行：<pre><code class="language-yaml">push:
  branches: [master, main]</code></pre>
</li>
<li>在主分支（主分支或主分支）上创建 PR 时运行：<pre><code class="language-yaml">pull_request:
  branches: [master, main]</code></pre>
</li>
</ul>
</li>
<li>然后，您将定义所有工作。本工作流程中有两个任务：
<ul>
<li><code>lint_python</code>： 检查 Python 函数</li>
<li><code>lint_js</code>： 检查 JavaScript 函数</li>
</ul>
</li>
</ol>
<h4 id="512-github-jobs"><a class="markdownIt-Anchor" href="#512-github-jobs"></a> 5.1.2. GitHub Jobs</h4>
<p>让我们逐一看看这些作业：</p>
<ol>
<li>
<p><code>lint_python</code>：</p>
<ul>
<li>使用 <code>actions/setup-python@v4</code> 操作设置该操作的 Python 运行时。</li>
<li>使用 <code>pip install</code> 安装所有依赖项。</li>
<li>在服务器目录下的所有文件中递归运行 Linting 命令 <code>flake8 *.py</code>。</li>
<li>打印一条提示信息，说明 Linting 已成功完成。</li>
</ul>
</li>
<li>
<p><code>lint_function_js</code>：</p>
<ul>
<li>使用 <code>actions/setup-node@v3</code> 操作设置要运行的 Node.js 运行时。</li>
<li>安装所有 JSHint 内核 <code>npm install jshint</code>。</li>
<li>在数据库目录中的所有 <code>.js</code> 文件上递归运行 Linting 命令。</li>
<li>打印一条提示信息，说明 Linting 已成功完成。</li>
</ul>
</li>
</ol>
<h4 id="513-启动-github-actions"><a class="markdownIt-Anchor" href="#513-启动-github-actions"></a> 5.1.3. 启动 GitHub Actions</h4>
<p>要启用 GitHub Actions，请登录 GitHub 并打开已 Fork 的仓库。然后，转到 <code>Actions</code> 选项卡，点击 <code>Set up a workflow yourself</code>。将上述 Lint 代码粘贴到 <code>main.yml</code> 中并提交。再次打开 <code>Actions</code> 选项卡，就会看到提交已自动启动了检查工作流程。</p>
<p>您可以单击工作流程运行，查看单个作业和每个作业的日志。工作流程成功完成后，你会看到绿色的 <code>√</code>，表示工作顺利。红叉表示在检查代码时发现了错误。</p>
<p>查看这些提示，解决你可能遇到的常见 Linting 错误。</p>
<ol>
<li>
<p><code>Flake-8 Lint</code>（Python）Linting 错误：</p>
<ol>
<li>
<p>如果收到下列一个或多个错误：</p>
<pre><code class="language-plaintext">E117 over-indented
E128 continuation line under-indented for visual indent</code></pre>
<p>解决方法：</p>
<ul>
<li>确认所有代码都保持适当的缩进——既不会缩进过小，也不会缩进过大。</li>
<li>注意：使用文本编辑器确保准确执行。</li>
</ul>
</li>
<li>
<pre><code class="language-plaintext">E501 line too long (xxx &gt; 79 characters)</code></pre>
<p>解决办法：</p>
<ul>
<li>将代码分成多行，确保每行最多不超过 79 个字符。</li>
</ul>
</li>
<li>
<pre><code class="language-plaintext">F401 &#x27;xxx&#x27; imported but unused</code></pre>
<p>解决方法：</p>
<ul>
<li>核实后续代码段中是否使用了提及的实体或变量（<code>xxx</code>）。如果未使用实体或变量，则删除包含该实体或变量的行。</li>
</ul>
<blockquote>
<p>这里有个小坑，<code>djangoapp/views.py</code> 文件中每个函数中的 <code>request</code> 参数绝对不能删除，建议在当前函数内 <code>print</code> 一下 <code>request</code> 参数来回避该错误。部分不能被删除但同时也没被用到的变量同理。</p>
</blockquote>
</li>
<li>
<pre><code class="language-plaintext">W292 no newline at end of file</code></pre>
<p>解决方法：</p>
<ul>
<li>在文件的最终代码后插入新行，并将光标置于垂直窗格的最左侧（不向右缩进）。</li>
</ul>
</li>
<li>
<pre><code class="language-plaintext">E302 expected 2 blank lines, found 1</code></pre>
<p>解决方案：</p>
<ul>
<li>确保每对相邻函数之间正好有两行空行（不能多也不能少）。</li>
</ul>
</li>
<li>
<pre><code class="language-plaintext">E231 missing whitespace after &#x27;:&#x27;</code></pre>
<p>解决方法：</p>
<ul>
<li>确保在所有字典键值对中的分号后留一个空格。</li>
<li>例如，如果现有代码为 <code>&quot;a&quot;:&quot;b&quot;</code>，请将其更改为 <code>&quot;a&quot;: &quot;b&quot;</code>。</li>
</ul>
</li>
<li>
<pre><code class="language-plaintext">E275 missing whitespace after keyword</code></pre>
<p>解决办法：</p>
<ul>
<li>确保每个关键字后都有一个空格。</li>
<li>例如，如果您的现有代码是 <code>if(&quot;condition&quot;):</code>，请将其改为 <code>if (&quot;condition&quot;):</code>。</li>
</ul>
</li>
<li>
<pre><code class="language-plaintext">E722 do not use bare &#x27;except&#x27;</code></pre>
<p>解决方法：</p>
<ul>
<li>使用 <code>except Exception:</code> 而不是 <code>except</code> 作为捕获异常和全面处理异常的最佳实践。</li>
<li>例如，如果现有代码是：<pre><code class="language-python">except:
    print(&quot;Error&quot;)</code></pre>
您可以将其改为：<pre><code class="language-python">except Exception as e:
    print(f&quot;Error: &#123;e&#125;&quot;)</code></pre>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p><code>JS Hint</code>（JavaScript）Linting 错误：</p>
<ol>
<li>
<p>如果收到下列一个或多个错误：</p>
<pre><code class="language-plaintext">&#x27;const&#x27; is available in ES6 (use &#x27;esversion: 6&#x27;) or Mozilla JS extensions (use moz).
&#x27;arrow function syntax (=&gt;)&#x27; is only available in ES6 (use &#x27;esversion: 6&#x27;).
&#x27;async functions&#x27; is only available in ES8 (use &#x27;esversion: 8&#x27;).
&#x27;let&#x27; is available in ES6 (use &#x27;esversion: 6&#x27;) or Mozilla JS extensions (use moz).
&#x27;template literal syntax&#x27; is only available in ES6 (use &#x27;esversion: 6&#x27;).</code></pre>
<p>解决方法：</p>
<ul>
<li>在报告此错误的文件开头添加以下一行：<pre><code class="language-js">/*jshint esversion: 8 */</code></pre>
</li>
</ul>
</li>
<li>
<pre><code class="language-plaintext">[&#x27;xxxxxx&#x27;] is better written in dot notation.</code></pre>
<p>解决方法：</p>
<ul>
<li>当字典或 JSON 键值对的格式为 <code>key[value]</code> 时，就会出现这个问题。要解决这个问题，请将格式切换为 <code>key.value</code>。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="52-容器化并部署到-kubernetes"><a class="markdownIt-Anchor" href="#52-容器化并部署到-kubernetes"></a> 5.2. 容器化并部署到 Kubernetes</h2>
<p>根据最新的技术发展趋势，并为了避免供应商锁定，贵公司的管理团队希望将经销商应用程序部署到多个云中。该应用程序目前在 Code Engine 上运行，但您被告知并非所有云提供商都提供托管 Code Engine 服务。所有大型云提供商都有托管和管理容器的方法，因此您被要求将容器作为缓解这一问题的可能方法。在对应用程序进行容器化时，过程包括将应用程序与其相关的环境变量、配置文件、库和软件依赖关系打包。其结果是一个容器映像，可以在容器平台上运行。您还需要使用 Kubernetes 来管理容器化部署。</p>
<blockquote>
<p>Kubernetes 是一个开源容器编排平台，可以自动部署、管理和扩展应用程序。</p>
</blockquote>
<p>在本模块中，您将：</p>
<ul>
<li>为应用程序添加在容器中运行的功能</li>
<li>为应用程序添加部署工件，以便 Kubernetes 对其进行管理</li>
</ul>
<blockquote>
<p>注意：在开始实验之前，请按照步骤检查和删除以前持续存在的会话，以避免在运行实验时出现任何问题。</p>
<p>请运行以下命令：</p>
<pre><code class="language-bash">kubectl get deployments</code></pre>
<p>如果您发现经部署 <code>dealership</code> 已经存在，请删除它：</p>
<pre><code class="language-bash">kubectl delete deployment dealership</code></pre>
<p>请运行以下命令：</p>
<pre><code class="language-bash">ibmcloud cr images</code></pre>
<p>如果有任何 <code>dealership</code> 镜像，请使用删除它：</p>
<pre><code class="language-bash">ibmcloud cr image-rm us.icr.io/&lt;your sn labs namespace&gt;/dealership:latest &amp;&amp; docker rmi us.icr.io/&lt;your sn labs namespace&gt;/dealership:latest</code></pre>
<blockquote>
<p>请输入您的 SN Labs 命名空间，以代替 <code>&lt;your sn labs namespace&gt;</code>。（SN Labs 命名空间是 IBM Skills Network 内置的）</p>
<p>如果您不记得自己的命名空间，可以使用以下任一命令获取：</p>
<ul>
<li>oc 项目</li>
<li>ibmcloud cr 命名空间（请使用格式为 <code>sn-labs-$USERNAME</code> 的命名空间）</li>
</ul>
</blockquote>
<ul>
<li>请退出 SN Labs 并清除浏览器缓存和 cookie。</li>
<li>请重新启动实验室并按以下步骤操作。</li>
</ul>
</blockquote>
<h4 id="521-设置环境"><a class="markdownIt-Anchor" href="#521-设置环境"></a> 5.2.1. 设置环境</h4>
<ol>
<li>如果实验室环境已重置，请克隆您的 Git 仓库。</li>
<li>打开一个新终端，切换到 <code>server/database</code> 目录，然后按照之前的操作运行 Mongo Express 服务器。</li>
<li>如果部署在 Code Engine 上的情感分析器微服务不可用，请重新部署并更新所需的 URL。</li>
<li>打开另一个新终端。切换到 <code>server/frontend</code> 目录。运行以下命令创建前端：<pre><code class="language-bash">npm install
npm run build</code></pre>
</li>
</ol>
<h4 id="522-添加-dockerfile"><a class="markdownIt-Anchor" href="#522-添加-dockerfile"></a> 5.2.2. 添加 Dockerfile</h4>
<p>在 <code>server</code> 目录下创建一个 <code>Dockerfile</code>。文件中应列出以下步骤：</p>
<ol>
<li>添加基础镜像。</li>
<li>添加 <code>requirements.txt</code> 文件。</li>
<li>安装并更新 Python。</li>
<li>更改工作目录。</li>
<li>公开端口。</li>
<li>运行命令启动应用程序。</li>
</ol>
<p>下面是一个示例文件，供您开始使用：</p>
<pre><code class="language-dockerfile">FROM python:3.12.0-slim-bookworm

ENV PYTHONBUFFERED 1
ENV PYTHONWRITEBYTECODE 1

ENV APP=/app

# Change the workdir.
WORKDIR $APP

# Install the requirements
COPY requirements.txt $APP

RUN pip3 install -r requirements.txt

# Copy the rest of the files
COPY . $APP

EXPOSE 8000

RUN chmod +x /app/entrypoint.sh

ENTRYPOINT [&quot;/bin/bash&quot;,&quot;/app/entrypoint.sh&quot;]

CMD [&quot;gunicorn&quot;, &quot;--bind&quot;, &quot;:8000&quot;, &quot;--workers&quot;, &quot;3&quot;, &quot;djangoproj.wsgi&quot;]</code></pre>
<p>请注意，<code>Dockerfile</code> 中倒数第二个命令指的是 <code>entrypoint.sh</code>。在 <code>server</code> 目录中创建该文件。该文件应包含以下内容：</p>
<pre><code class="language-shell">#!/bin/sh

# Make migrations and migrate the database.
echo &quot;Making migrations and migrating the database. &quot;
python manage.py makemigrations --noinput
python manage.py migrate --run-syncdb --noinput
python manage.py collectstatic --noinput
exec &quot;$@&quot;</code></pre>
<h4 id="523-构建镜像并将其推送到容器注册表"><a class="markdownIt-Anchor" href="#523-构建镜像并将其推送到容器注册表"></a> 5.2.3. 构建镜像并将其推送到容器注册表</h4>
<p>您必须记住如何构建镜像并将其推送到 IBM Cloud Image Registry (ICR)。您需要在这里执行相同的操作，然后在 Kubernetes 部署文件中引用该镜像。</p>
<p>请导出 SN Labs 命名空间，并在控制台中打印出来，如下所示：</p>
<pre><code class="language-bash">MY_NAMESPACE=$(ibmcloud cr namespaces | grep sn-labs-)
echo $MY_NAMESPACE</code></pre>
<p>使用当前目录下的 <code>Dockerfile</code> 执行 docker 构建：</p>
<pre><code class="language-bash">docker build -t us.icr.io/$MY_NAMESPACE/dealership .</code></pre>
<p>接下来，将镜像推送到容器注册表：</p>
<pre><code class="language-bash">docker push us.icr.io/$MY_NAMESPACE/dealership</code></pre>
<h4 id="524-添加部署工件"><a class="markdownIt-Anchor" href="#524-添加部署工件"></a> 5.2.4. 添加部署工件</h4>
<p>在 <code>server</code> 目录下创建 <code>deployment.yaml</code> 文件，以创建部署和服务。文件应如下所示：</p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    run: dealership
  name: dealership
spec:
  replicas: 1
  selector:
    matchLabels:
      run: dealership
  strategy:
    rollingUpdate:
      maxSurge: 25%
      maxUnavailable: 25%
    type: RollingUpdate
  template:
    metadata:
      labels:
        run: dealership
    spec:
      containers:
      - image: us.icr.io/your-name-space/dealership:latest
        imagePullPolicy: Always
        name: dealership
        ports:
        - containerPort: 8000
          protocol: TCP
      restartPolicy: Always</code></pre>
<p>请在上述文件中输入您的 SN Labs 命名空间，以代替 <code>your-name-space</code>。</p>
<h4 id="525-部署应用程序"><a class="markdownIt-Anchor" href="#525-部署应用程序"></a> 5.2.5. 部署应用程序</h4>
<p>使用以下命令和部署文件创建部署：</p>
<pre><code class="language-bash">kubectl apply -f deployment.yaml</code></pre>
<p>通常，我们会在部署中添加一个服务；不过，我们将在此环境中使用端口转发功能来查看正在运行的应用程序：</p>
<pre><code class="language-bash">kubectl port-forward deployment.apps/dealership 8000:8000</code></pre>
<blockquote>
<p>注意：如果出现任何错误，请稍等片刻，然后重新运行该命令。</p>
</blockquote>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="369.html">上一篇</a><a class="next" href="52000.html">下一篇</a></div><div class="copyright"><p>© 2022 - 2025 <a href="https://cytrogen.icu">Cytrogen</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/cytrogen/hexo-theme-ares" target="_blank">hexo-theme-ares</a>.</p></div></footer></div></div><a class="back-to-top" href="#top" aria-label="返回顶部"><svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path d="M3.293 9.707a1 1 0 010-1.414L9.586 2a2 2 0 012.828 0l6.293 6.293a1 1 0 01-1.414 1.414L11 3.414V17a1 1 0 11-2 0V3.414L2.707 9.707a1 1 0 01-1.414 0z"></path></svg></a><script>document.addEventListener('DOMContentLoaded', function() {
  const codeBlocks = document.querySelectorAll('figure.highlight');
  
  codeBlocks.forEach(block => {
    let caption = block.querySelector('figcaption');
    if (!caption) {
      caption = document.createElement('figcaption');
      block.insertBefore(caption, block.firstChild);
    }

    const info = document.createElement('div');
    info.className = 'info';
    
    const filename = caption.querySelector('span');
    if (filename) {
      filename.className = 'filename';
      info.appendChild(filename);
    }
    
    const lang = block.className.split(' ')[1];
    if (lang) {
      const langSpan = document.createElement('span');
      langSpan.className = 'lang-name';
      langSpan.textContent = lang;
      info.appendChild(langSpan);
    }

    const sourceLink = caption.querySelector('a');
    if (sourceLink) {
      sourceLink.className = 'source-link';
      info.appendChild(sourceLink);
    }

    const actions = document.createElement('div');
    actions.className = 'actions';

    const codeHeight = block.scrollHeight;
    const threshold = 300;

    if (codeHeight > threshold) {
      block.classList.add('folded');
      
      const toggleBtn = document.createElement('button');
      toggleBtn.textContent = '展开';
      toggleBtn.addEventListener('click', () => {
        block.classList.toggle('folded');
        toggleBtn.textContent = block.classList.contains('folded') ? '展开' : '折叠';
      });
      actions.appendChild(toggleBtn);
    }

    const copyBtn = document.createElement('button');
    copyBtn.textContent = '复制';
    copyBtn.addEventListener('click', async () => {
      const codeLines = block.querySelectorAll('.code .line');
      const code = Array.from(codeLines)
        .map(line => line.textContent)
        .join('\n')
        .replace(/\n\n/g, '\n');
      
      try {
        await navigator.clipboard.writeText(code);
        copyBtn.textContent = '已复制';
        copyBtn.classList.add('copied');
        
        setTimeout(() => {
          copyBtn.textContent = '复制';
          copyBtn.classList.remove('copied');
        }, 3000);
      } catch (err) {
        console.error('复制失败:', err);
        copyBtn.textContent = '复制失败';
        
        setTimeout(() => {
          copyBtn.textContent = '复制';
        }, 3000);
      }
    });
    actions.appendChild(copyBtn);

    caption.innerHTML = '';
    caption.appendChild(info);
    caption.appendChild(actions);

    const markedLines = block.getAttribute('data-marked-lines');
    if (markedLines) {
      const lines = markedLines.split(',');
      lines.forEach(range => {
        if (range.includes('-')) {
          const [start, end] = range.split('-').map(Number);
          for (let i = start; i <= end; i++) {
            const line = block.querySelector(`.line-${i}`);
            if (line) line.classList.add('marked');
          }
        } else {
          const line = block.querySelector(`.line-${range}`);
          if (line) line.classList.add('marked');
        }
      });
    }
  });
});</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=G-4PVPZXE0QQ"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-4PVPZXE0QQ');</script><script>(function() {
  // Wait for DOM to be ready
  document.addEventListener('DOMContentLoaded', function() {
    const themeToggle = document.querySelector('.theme-toggle');
    
    if (!themeToggle) return;
    
    // Get current theme
    const getCurrentTheme = () => {
      return document.documentElement.getAttribute('data-theme') || 'light';
    };
    
    // Update UI to match current theme
    const updateUI = (theme) => {
      const isDark = theme === 'dark';
      themeToggle.setAttribute('aria-pressed', isDark.toString());
    };
    
    // Simplified theme setter - CSS handles all animations
    const setTheme = (theme) => {
      document.documentElement.setAttribute('data-theme', theme);
      document.documentElement.style.colorScheme = theme; // Update native UI elements
      
      // Also update page-wrapper for animation support
      const pageWrapper = document.getElementById('page-wrapper');
      if (pageWrapper) {
        pageWrapper.setAttribute('data-theme', theme);
      }
      
      // Find and remove the temporary anti-flicker style tag if it exists.
      // This ensures the main stylesheet takes full control after the initial load.
      const antiFlickerStyle = document.getElementById('anti-flicker-style');
      if (antiFlickerStyle) {
        antiFlickerStyle.remove();
      }
      
      localStorage.setItem('theme', theme);
      updateUI(theme);
    };
    
    // Simple theme toggle - letting CSS handle the smooth transitions
    const toggleTheme = () => {
      const current = getCurrentTheme();
      const newTheme = current === 'light' ? 'dark' : 'light';
      setTheme(newTheme);
    };
    
    // Initialize UI on page load
    updateUI(getCurrentTheme());
    
    // Add click event listener
    themeToggle.addEventListener('click', toggleTheme);
    
    // Listen for system theme changes
    if (window.matchMedia) {
      const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
      mediaQuery.addEventListener('change', function(e) {
        // Only update if no manual preference is saved
        if (!localStorage.getItem('theme')) {
          const theme = e.matches ? 'dark' : 'light';
          setTheme(theme);
        }
      });
    }
  });
})();
</script><script>(function() {
  document.addEventListener('DOMContentLoaded', function() {
    const backToTopBtn = document.querySelector('.back-to-top');
    
    if (!backToTopBtn) return;
    
    // Show/hide button based on scroll position
    const toggleButtonVisibility = () => {
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      const shouldShow = scrollTop > 200; // Show after scrolling 200px
      
      if (shouldShow) {
        backToTopBtn.classList.add('is-visible');
      } else {
        backToTopBtn.classList.remove('is-visible');
      }
    };
    
    // Throttle scroll events for better performance
    let ticking = false;
    const handleScroll = () => {
      if (!ticking) {
        requestAnimationFrame(() => {
          toggleButtonVisibility();
          ticking = false;
        });
        ticking = true;
      }
    };
    
    // Smooth scroll to top when clicked
    const scrollToTop = (event) => {
      event.preventDefault();
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    };
    
    // Add event listeners
    window.addEventListener('scroll', handleScroll);
    backToTopBtn.addEventListener('click', scrollToTop);
    
    // Check initial scroll position
    toggleButtonVisibility();
  });
})();</script></body></html>