<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>React + NestJS购物平台练习【5】用户登录功能 · Cytrogen 的个人博客</title><meta name="description" content="本文是 React + NestJS 全栈购物平台实践的第五篇，专注于实现完整的用户登录功能。前端部分，教程详细讲解了如何使用 Formik 和 Yup 构建登录表单，并结合 React Query 和 Zustand 实现“记住我”功能与自动登录检查。后端部分，则深入实现了基于 JWT 的双令牌（Access Token + Refresh Token）认证机制，包括令牌的生成、验证、刷新和注销。本教程为构建一个安全、用户体验友好的全栈登录系统提供了从前端交互到后端认证的完整实战指南。"><link rel="icon" href="../favicon.png"><link rel="preload" href="../fonts/opensans-regular-latin.woff2" as="font" type="font/woff2" crossorigin="anonymous"><style>@font-face {
  font-family: 'Open Sans';
  src: url('../fonts/opensans-regular-latin.woff2') format('woff2');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
  size-adjust: 107%;
  ascent-override: 97%;
  descent-override: 25%;
  line-gap-override: 0%;
}
</style><link rel="stylesheet" href="../css/ares.css"><script>(function() {
  const getInitialTheme = () => {
    const saved = localStorage.getItem('theme');
    if (saved && (saved === 'light' || saved === 'dark')) {
      return saved;
    }
    
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      return 'dark';
    }
    
    return 'light';
  };
  
  const theme = getInitialTheme();
  document.documentElement.setAttribute('data-theme', theme);
  
  document.documentElement.style.colorScheme = theme;
  
  // Add anti-flicker style for dark mode
  if (theme === 'dark') {
    const style = document.createElement('style');
    style.id = 'anti-flicker-style';
    style.innerHTML = `
      #page-wrapper[data-theme="dark"] {
        background-color: #0f172a;
        color: #f1f5f9;
      }
    `;
    document.head.appendChild(style);
  }
  
  document.addEventListener('DOMContentLoaded', function() {
    const pageWrapper = document.getElementById('page-wrapper');
    if (pageWrapper) {
      pageWrapper.setAttribute('data-theme', theme);
    }
  });
})();

</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="atom.xml" title="Cytrogen 的个人博客" type="application/atom+xml">
</head><body><div id="page-wrapper"><a class="skip-link" href="#main-content">跳到主要内容</a><div class="wrap"><header><a class="logo-link" href="../index.html"><img src="../favicon.png" alt="logo"></a><nav class="site-nav"><div class="nav-main"><div class="nav-primary"><ul class="nav-list hidden-mobile"><li class="nav-item"><a class="nav-link" href="../index.html">首页</a></li></ul><div class="nav-tools"><div class="language-menu"><button class="language-toggle" type="button"><svg class="icon icon-globe" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true" focusable="false"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8zm7.5-6.923c-.67.204-1.335.82-1.887 1.855A7.97 7.97 0 0 0 5.145 4H7.5V1.077zM4.09 4a9.267 9.267 0 0 1 .64-1.539 6.7 6.7 0 0 1 .597-.933A7.025 7.025 0 0 0 2.255 4H4.09zm-.582 3.5c.03-.877.138-1.718.312-2.5H1.674a6.958 6.958 0 0 0-.656 2.5h2.49zM4.847 5a12.5 12.5 0 0 0-.338 2.5H7.5V5H4.847zM8.5 5v2.5h2.99a12.495 12.495 0 0 0-.337-2.5H8.5zM4.51 8.5a12.5 12.5 0 0 0 .337 2.5H7.5V8.5H4.51zm3.99 0V11h2.653c.187-.765.306-1.608.338-2.5H8.5zM5.145 12c.138.386.295.744.468 1.068.552 1.035 1.218 1.65 1.887 1.855V12H5.145zm.182 2.472a6.696 6.696 0 0 1-.597-.933A9.268 9.268 0 0 1 4.09 12H2.255a7.024 7.024 0 0 0 3.072 2.472zM3.82 11a13.652 13.652 0 0 1-.312-2.5h-2.49c.062.89.291 1.733.656 2.5H3.82zm6.853 3.472A7.024 7.024 0 0 0 13.745 12H11.91a9.27 9.27 0 0 1-.64 1.539 6.688 6.688 0 0 1-.597.933zM8.5 12v2.923c.67-.204 1.335-.82 1.887-1.855A7.97 7.97 0 0 0 10.855 12H8.5zm3.68-1h2.146c.365-.767.594-1.61.656-2.5h-2.49a13.65 13.65 0 0 1-.312 2.5zm2.802-3.5a6.959 6.959 0 0 0-.656-2.5H12.18c.174.782.282 1.623.312 2.5h2.49zM11.27 2.461c.247.464.462.98.64 1.539h1.835a7.024 7.024 0 0 0-3.072-2.472c.218.284.418.598.597.933zM10.855 4a7.966 7.966 0 0 0-.468-1.068C9.835 1.897 9.17 1.282 8.5 1.077V4h2.355z"></path></svg><span>中文</span></button><div class="language-dropdown"></div></div></div><div class="nav-controls"><div class="more-menu hidden-mobile"><button class="more-toggle" type="button"><span>更多</span><svg class="icon icon-chevron-down" width="12" height="12" viewBox="0 0 12 12" fill="currentColor" aria-hidden="true" focusable="false"><path d="M6 8.825c-.2 0-.4-.1-.5-.2l-3.3-3.3c-.3-.3-.3-.8 0-1.1s.8-.3 1.1 0l2.7 2.7 2.7-2.7c.3-.3.8-.3 1.1 0s.3.8 0 1.1l-3.3 3.3c-.1.1-.3.2-.5.2z"></path></svg></button><div class="more-dropdown"><ul class="dropdown-list"><li class="dropdown-item"><a class="nav-link" href="../archives">归档</a></li><li class="dropdown-item"><a class="nav-link" href="../categories">分类</a></li><li class="dropdown-item"><a class="nav-link" href="../tags">标签</a></li><li class="dropdown-item"><a class="nav-link" href="../about">关于</a></li><li class="dropdown-item"><a class="nav-link" href="../friends">友链</a></li><li class="dropdown-item"><a class="nav-link" href="../atom.xml">RSS订阅</a></li><li class="dropdown-item"><a class="dropdown-link" href="https://portfolio.cytrogen.icu" target="_blank" rel="noopener noreferrer">作品集<svg class="icon icon-external-link" width="14" height="14" viewBox="0 0 14 14" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8.636 2.364A1 1 0 0 1 10 1h3a1 1 0 0 1 1 1v3a1 1 0 0 1-2 0V3.414l-4.293 4.293a1 1 0 0 1-1.414-1.414L10.586 2H9a1 1 0 0 1-1.364-1.636zM2 3a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V9a1 1 0 1 1 2 0v3a3 3 0 0 1-3 3H2a3 3 0 0 1-3-3V4a3 3 0 0 1 3-3h3a1 1 0 1 1 0 2H2z"></path></svg></a></li><li class="dropdown-item"><a class="dropdown-link" href="https://github.com/cytrogen" target="_blank" rel="noopener noreferrer">GitHub<svg class="icon icon-external-link" width="14" height="14" viewBox="0 0 14 14" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8.636 2.364A1 1 0 0 1 10 1h3a1 1 0 0 1 1 1v3a1 1 0 0 1-2 0V3.414l-4.293 4.293a1 1 0 0 1-1.414-1.414L10.586 2H9a1 1 0 0 1-1.364-1.636zM2 3a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V9a1 1 0 1 1 2 0v3a3 3 0 0 1-3 3H2a3 3 0 0 1-3-3V4a3 3 0 0 1 3-3h3a1 1 0 1 1 0 2H2z"></path></svg></a></li></ul></div></div><div class="theme-switcher"><button class="theme-toggle" type="button" role="switch" aria-pressed="false" aria-label="切换主题"><div class="theme-icon moon-icon"><svg class="icon icon-moon" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true" focusable="false"><path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"></path></svg></div><div class="theme-icon sun-icon"><svg class="icon icon-sun" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0 1a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"></path></svg></div></button></div><details class="mobile-menu-details hidden-desktop"><summary class="hamburger-menu" aria-label="nav.menu"><svg class="icon icon-bars" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true" focusable="false"><path d="M2.5 12a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5z"></path></svg><span class="menu-text">nav.menu</span></summary><div class="mobile-menu-dropdown"><ul class="mobile-nav-list"><li class="mobile-nav-item"><a class="mobile-nav-link" href="../index.html">首页</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../archives">归档</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../categories">分类</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../tags">标签</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../about">关于</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../friends">友链</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="../atom.xml">RSS订阅</a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="https://portfolio.cytrogen.icu" target="_blank" rel="noopener noreferrer">作品集<svg class="icon icon-external-link" width="14" height="14" viewBox="0 0 14 14" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8.636 2.364A1 1 0 0 1 10 1h3a1 1 0 0 1 1 1v3a1 1 0 0 1-2 0V3.414l-4.293 4.293a1 1 0 0 1-1.414-1.414L10.586 2H9a1 1 0 0 1-1.364-1.636zM2 3a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V9a1 1 0 1 1 2 0v3a3 3 0 0 1-3 3H2a3 3 0 0 1-3-3V4a3 3 0 0 1 3-3h3a1 1 0 1 1 0 2H2z"></path></svg></a></li><li class="mobile-nav-item"><a class="mobile-nav-link" href="https://github.com/cytrogen" target="_blank" rel="noopener noreferrer">GitHub<svg class="icon icon-external-link" width="14" height="14" viewBox="0 0 14 14" fill="currentColor" aria-hidden="true" focusable="false"><path d="M8.636 2.364A1 1 0 0 1 10 1h3a1 1 0 0 1 1 1v3a1 1 0 0 1-2 0V3.414l-4.293 4.293a1 1 0 0 1-1.414-1.414L10.586 2H9a1 1 0 0 1-1.364-1.636zM2 3a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V9a1 1 0 1 1 2 0v3a3 3 0 0 1-3 3H2a3 3 0 0 1-3-3V4a3 3 0 0 1 3-3h3a1 1 0 1 1 0 2H2z"></path></svg></a></li></ul></div></details></div></div></div></nav></header><main class="container" id="main-content" tabindex="-1"><div class="post"><article class="post-block"><h1 class="post-title">React + NestJS购物平台练习【5】用户登录功能</h1><div class="post-info">2/12/2025</div><div class="post-content"><p>在构建电商平台的过程中，用户登录是一个不可或缺的核心功能。</p>
<p>本文将详细介绍如何在 React 前端实现登录表单组件，并结合 NestJS 后端完成完整的用户认证流程，包括 JWT 认证、记住我功能以及登录状态持久化等关键特性。</p>
<span id="more"></span>
<h1 id="1-小改动"><a class="markdownIt-Anchor" href="#1-小改动"></a> 1. 小改动</h1>
<h2 id="11-改变量字段名字"><a class="markdownIt-Anchor" href="#11-改变量字段名字"></a> 1.1. 改变量/字段名字</h2>
<p>将 React 项目的 <code>src/stores/user/types.ts</code> 中的 <code>LoginCredentials</code> 的 <code>email</code> 修改为 <code>username</code>：</p>
<pre><code class="language-ts">export interface LoginCredentials &#123; 
  username: string; 
  password: string; 
&#125;</code></pre>
<h2 id="12-修改依赖数组"><a class="markdownIt-Anchor" href="#12-修改依赖数组"></a> 1.2. 修改依赖数组</h2>
<p>在 <code>src/pages/VerifyEmail.tsx</code> 中的 <code>useEffect</code> 的依赖数组内加一个 <code>location.search</code>：</p>
<pre><code class="language-tsx">useEffect(() =&gt; &#123;
  const searchParams = new URLSearchParams(location.search);
  const token = searchParams.get(&#x27;token&#x27;);
  const currentToken = useUserStore.getState().verificationToken;

  if (token &amp;&amp; !verificationInProgress &amp;&amp; !emailVerified &amp;&amp; token !== currentToken) &#123;
    handleVerification(token).then(r =&gt; &#123;
      if (r.success &amp;&amp; &#x27;message&#x27; in r) console.log(&#x27;邮箱验证成功：&#x27;, r.message);
    &#125;);
  &#125;
&#125;, [handleVerification, verificationInProgress, emailVerified, location.search]);</code></pre>
<h2 id="13-新建-email-verificationinterfacets"><a class="markdownIt-Anchor" href="#13-新建-email-verificationinterfacets"></a> 1.3. 新建 <code>email-verification.interface.ts</code></h2>
<p>将原本放在 <code>users.service.ts</code> 内的这段内容单独放在一个文件里：</p>
<pre><code class="language-ts">export enum EmailVerificationError &#123;
  TOKEN_INVALID = &#x27;TOKEN_INVALID&#x27;,
  TOKEN_EXPIRED = &#x27;TOKEN_EXPIRED&#x27;,
  ALREADY_VERIFIED = &#x27;ALREADY_VERIFIED&#x27;
&#125;

export interface VerificationResponse &#123;
  success: boolean;
  message: string;
  error?: EmailVerificationError;
  userId?: string;
&#125;</code></pre>
<h2 id="14-统一查找用户的方法"><a class="markdownIt-Anchor" href="#14-统一查找用户的方法"></a> 1.4. 统一查找用户的方法</h2>
<p>原先我们只写了靠 ID 来查找用户的方法，如果要进行扩展的话，一个方法一个方法写太麻烦了，干脆写一个更灵活的查找方法、支持通过任何唯一字段查找用户：</p>
<pre><code class="language-ts">async findUser(criteria: UserSearchCriteria) &#123;
  this.logger.debug(`开始查找用户，条件：$&#123;JSON.stringify(criteria)&#125;`);

  const whereClause = Object.entries(criteria)
    .filter(([, value]) =&gt; value !== undefined)
    .reduce((acc, [key, value]) =&gt; (&#123; ...acc, [key]: value &#125;), &#123;&#125;);

  if (Object.keys(whereClause).length === 0) &#123;
    this.logger.warn(&#x27;查询条件为空&#x27;);
    throw new BadRequestException(&#x27;至少需要一个查询条件&#x27;);
  &#125;

  const user = await this.usersRepository.findOne(&#123;
    where: whereClause
  &#125;);

  if (!user) &#123;
    const [[key, value]] = Object.entries(whereClause);
    const fieldMap = &#123;
      id: &#x27;ID&#x27;,
      username: &#x27;用户名&#x27;,
      email: &#x27;邮箱&#x27;,
      verificationToken: &#x27;验证令牌&#x27;
    &#125;;
    const errorMessage = `未找到$&#123;fieldMap[key]&#125;为 $&#123;value&#125; 的用户`;
    this.logger.warn(`查找用户失败：$&#123;errorMessage&#125;`);
    throw new NotFoundException(errorMessage);
  &#125;

  this.logger.debug(`用户查找成功：$&#123;user.id&#125;，用户详细信息：$&#123;JSON.stringify(user)&#125;`);
  return user;
&#125;</code></pre>
<pre><code class="language-ts">export type UserSearchCriteria = Partial&lt;&#123;
  id: string;
  username: string;
  email: string;
  verificationToken: string;
&#125;&gt;;</code></pre>
<p><code>UsersController</code> 的查找用户 API 也可以修改成类似的样子：</p>
<pre><code class="language-ts">@ApiOperation(&#123; summary: &#x27;根据不同字段查找用户&#x27; &#125;)
@ApiParam(&#123; name: &#x27;field&#x27;, enum: [&#x27;id&#x27;, &#x27;username&#x27;, &#x27;email&#x27;], description: &#x27;查找字段&#x27; &#125;)
@ApiParam(&#123; name: &#x27;value&#x27;, description: &#x27;查找值&#x27; &#125;)
@ApiResponse(&#123; status: HttpStatus.OK, description: &#x27;获取用户信息成功&#x27;, type: Users &#125;)
@HttpCode(HttpStatus.OK)
@Get(&#x27;:field/:value&#x27;)
async findByField(@Param(&#x27;field&#x27;) field: &#x27;id&#x27; | &#x27;username&#x27; | &#x27;email&#x27;, @Param(&#x27;value&#x27;) value: string): Promise&lt;Users&gt; &#123;
  const validFields = [&#x27;id&#x27;, &#x27;username&#x27;, &#x27;email&#x27;];
  if (!validFields.includes(field)) &#123;
    throw new BadRequestException(`不支持通过 $&#123;field&#125; 字段查找用户`);
  &#125;

  return this.usersService.findUser(&#123; [field]: value &#125;);
&#125;</code></pre>
<h2 id="15-jwt-payload-修复"><a class="markdownIt-Anchor" href="#15-jwt-payload-修复"></a> 1.5. <code>JWT Payload</code> 修复</h2>
<pre><code class="language-ts">// 过去的接口
export interface JWTPayload &#123;
  sub: number;  // 错误的类型
  username: string;
  email: string;
  role: string;
  iat?: number;
  exp?: number;
  aud?: string;
  iss?: string;
&#125;

// 现在的接口
export interface JWTPayload &#123;
  sub: string;  // 修正为 string 类型，因为使用 UUID
  username: string;
  email: string;
  role: string;
  verified: boolean;  // 新增字段，用于邮箱验证状态
  iat?: number;
  exp?: number;
  aud?: string;
  iss?: string;
&#125;</code></pre>
<h2 id="16-布局组件优化"><a class="markdownIt-Anchor" href="#16-布局组件优化"></a> 1.6. 布局组件优化</h2>
<p>为了更好地适应不同的页面布局需求，我们需要增加主布局组件的灵活性。原有的 <code>MainLayout</code> 组件只支持路由渲染：</p>
<pre><code class="language-tsx">const MainLayout = () =&gt; &#123;
  return (
    &lt;div&gt;
      &lt;header className=&quot;bg-primary shadow&quot;&gt;
        &lt;nav className=&quot;max-w-7xl mx-auto px-4 sm:px-6 lg:px-8&quot;&gt;
          &#123;/* TODO: 导航内容 */&#125;
        &lt;/nav&gt;
      &lt;/header&gt;

      &lt;main&gt;
        &lt;div className=&quot;max-w-7xl mx-auto px-4 sm:px-6 lg:px-8&quot;&gt;
          &lt;Outlet /&gt;
        &lt;/div&gt;
      &lt;/main&gt;
    &lt;/div&gt;
  );
&#125;;</code></pre>
<p>我们对其进行了改造，使其同时支持直接的子组件渲染：</p>
<pre><code class="language-tsx">import React from &#x27;react&#x27;;
import &#123; Outlet &#125; from &#x27;react-router-dom&#x27;;

interface MainLayoutProps &#123;
  children?: React.ReactNode;
&#125;

const MainLayout = (&#123; children &#125;: MainLayoutProps) =&gt; &#123;
  return (
    &lt;div&gt;
      &lt;header className=&quot;bg-primary shadow&quot;&gt;
        &lt;nav className=&quot;max-w-7xl mx-auto px-4 sm:px-6 lg:px-8&quot;&gt;
          &#123;/* TODO: 导航内容 */&#125;
        &lt;/nav&gt;
      &lt;/header&gt;

      &lt;main&gt;
        &lt;div className=&quot;max-w-7xl mx-auto px-4 sm:px-6 lg:px-8&quot;&gt;
          &#123; children ? children : &lt;Outlet /&gt; &#125;
        &lt;/div&gt;
      &lt;/main&gt;
    &lt;/div&gt;
  );
&#125;;

export default MainLayout;</code></pre>
<h1 id="2-实现登录表单组件"><a class="markdownIt-Anchor" href="#2-实现登录表单组件"></a> 2. 实现登录表单组件</h1>
<p>在电商平台中，我们需要一个用户友好的登录界面，让用户能够：</p>
<ul>
<li>输入用户名和密码进行登录</li>
<li>在输入过程中获得适当的表单验证反馈</li>
<li>看到登录状态的加载提示</li>
<li>收到登陆成功或者失败的明确提示</li>
</ul>
<ol>
<li>
<p>让我们先在 <code>src/pages</code> 目录下创建 <code>Login.tsx</code>：</p>
 <pre><code class="language-tsx">import React from &#x27;react&#x27;; 
import &#123; useFormik &#125; from &#x27;formik&#x27;; 
import * as Yup from &#x27;yup&#x27;; 
import &#123; useNavigate &#125; from &#x27;react-router-dom&#x27;; 
import &#123; useUserStore &#125; from &#x27;../stores&#x27;; 
import AuthLayout from &#x27;../layouts/AuthLayout&#x27;; 
import logo from &#x27;../assets/ShoppingNest.png&#x27;; 

const Login = () =&gt; &#123; 
  const navigate = useNavigate(); 
  const login = useUserStore(state =&gt; state.login); 
  const isLoading = useUserStore(state =&gt; state.isLoading); 
  const error = useUserStore(state =&gt; state.error); 

  return (
    // ...
  )
&#125;
export default Login;</code></pre>
</li>
<li>
<p>使用 Formik 管理表单状态和处理提交：</p>
 <pre><code class="language-tsx">const formik = useFormik(&#123; 
  initialValues: &#123; 
    username: &#x27;&#x27;, 
    password: &#x27;&#x27; 
  &#125;, 
  validationSchema, 
  onSubmit: async (values) =&gt; &#123; 
    try &#123; 
      const &#123; username, password &#125; = values; 
      await login(&#123; username, password &#125;); 
      navigate(&#x27;/&#x27;, &#123; 
        state: &#123; 
          message: &#x27;登陆成功！&#x27; 
        &#125; 
      &#125;) 
    &#125; catch (error) &#123; 
      console.error(&#x27;登录失败：&#x27;, error); 
    &#125; 
  &#125; 
&#125;); </code></pre>
</li>
<li>
<p>使用 Yup 进行表单验证，确保用户名和密码不为空：</p>
 <pre><code class="language-tsx">const validationSchema = Yup.object().shape(&#123;
  username: Yup.string().required(&#x27;请输入用户名！&#x27;),
  password: Yup.string().required(&#x27;请输入密码！&#x27;)
&#125;);</code></pre>
</li>
<li>
<p>以下是页面的基本结构：</p>
 <pre><code class="language-tsx">return ( 
  &lt;AuthLayout&gt; 
    &lt;img src=&#123;logo&#125; className=&quot;w-1/4 mx-auto&quot; alt=&quot;Shopping Nest的Logo&quot; /&gt; 
    &lt;h2 className=&quot;text-2xl font-bold text-center m-6 text-neutral-content&quot;&gt; 
      登录用户 
    &lt;/h2&gt; 

    &#123;error &amp;&amp; ( 
      &lt;div className=&quot;mb-4 p-3 text-sm text-error-content bg-error rounded-lg&quot;&gt; 
        &#123;error&#125; 
      &lt;/div&gt; 
    )&#125; 

    &lt;form onSubmit=&#123;formik.handleSubmit&#125;&gt; 
      &lt;div className=&quot;mb-4&quot;&gt; 
        &lt;label className=&quot;block text-sm font-semibold text-neutral-content&quot; htmlFor=&quot;username&quot;&gt; 
          用户名 
        &lt;/label&gt; 
        &lt;input 
          type=&quot;text&quot; 
          id=&quot;username&quot; 
          name=&quot;username&quot; 
          className=&#123;`w-full mt-2 p-2 border rounded-lg bg-base-300 $&#123; 
            formik.touched.username &amp;&amp; formik.errors.username 
              ? &quot;border-error&quot; 
              : &quot;border-neutral-600&quot; 
          &#125; text-base-content`&#125; 
          value=&#123;formik.values.username&#125; 
          onChange=&#123;formik.handleChange&#125; 
          onBlur=&#123;formik.handleBlur&#125; 
          disabled=&#123;isLoading&#125; 
        /&gt; 
        &#123;formik.touched.username &amp;&amp; formik.errors.username &amp;&amp; ( 
          &lt;p className=&quot;text-sm text-error mt-1&quot;&gt;&#123;formik.errors.username&#125;&lt;/p&gt; 
        )&#125; 
      &lt;/div&gt; 

      &lt;div className=&quot;mb-4&quot;&gt; 
        &lt;label className=&quot;block text-sm font-semibold text-neutral-content&quot; htmlFor=&quot;password&quot;&gt; 
          密码 
        &lt;/label&gt; 
        &lt;input 
          type=&quot;password&quot; 
          id=&quot;password&quot; 
          name=&quot;password&quot; 
          className=&#123;`w-full mt-2 p-2 border rounded-lg bg-base-300 $&#123; 
            formik.touched.password &amp;&amp; formik.errors.password 
              ? &quot;border-error&quot; 
              : &quot;border-neutral-600&quot; 
          &#125; text-base-content`&#125; 
          value=&#123;formik.values.password&#125; 
          onChange=&#123;formik.handleChange&#125; 
          onBlur=&#123;formik.handleBlur&#125; 
          disabled=&#123;isLoading&#125; 
        /&gt; 
        &#123;formik.touched.password &amp;&amp; formik.errors.password &amp;&amp; ( 
          &lt;p className=&quot;text-sm text-error mt-1&quot;&gt;&#123;formik.errors.password&#125;&lt;/p&gt; 
        )&#125; 
      &lt;/div&gt; 

      &lt;button 
        type=&quot;submit&quot; 
        className=&quot;w-full bg-primary text-primary-content py-2 rounded-lg mt-4 hover:brightness-90 disabled:opacity-50&quot; 
        disabled=&#123;isLoading&#125; 
      &gt; 
        &#123;isLoading ? &quot;登录中…&quot; : &quot;登录&quot;&#125; 
      &lt;/button&gt; 
    &lt;/form&gt; 
  &lt;/AuthLayout&gt; 
) </code></pre>
</li>
<li>
<p>在 <code>src/router.tsx</code> 中添加 <code>/login</code> 路由：</p>
 <pre><code class="language-tsx">import Login from &#x27;./pages/Login&#x27;;

const router = createBrowserRouter([ 
  &#123; 
    path: &#x27;/login&#x27;, 
    element: &lt;Login /&gt; 
  &#125;
]); </code></pre>
</li>
</ol>
<h1 id="3-配置-jwt-认证"><a class="markdownIt-Anchor" href="#3-配置-jwt-认证"></a> 3. 配置 JWT 认证</h1>
<p>在实现用户登录功能时，我们需要一个安全可靠的身份验证机制，以确保用户身份的真实性并保护系统的安全。</p>
<p>JWT（JSON Web Token）是一个开放标准，它提供了一种紧凑且自包含的方式，在各方之间安全地传输信息。</p>
<p>通过 JWT，我们可以生成安全的访问令牌、验证用户的身份和权限、保护需要认证的 API 端点，并在服务端对令牌的有效性进行校验。</p>
<p>要实现 JWT 认证机制，我们需要从多个方面入手：</p>
<ol>
<li>配置认证模块、JWT 模块的签名密钥以及相关选项</li>
<li>集成用户模块，以便进行用户身份验证</li>
<li>实现认证服务，该服务需要负责验证用户凭据、生成 JWT 令牌、处理令牌刷新以及检查令牌的有效性，确保认证流程的完整性和安全性</li>
<li>创建一个认证控制器，专门处理用户的登录请求，并返回认证结果和 JWT 令牌，确保前端能够正确接收和使用身份验证信息</li>
<li>实现 JWT 策略和守卫：从请求中提取 JWT 令牌，并验证其有效性，以此来保护系统中需要认证的路由，确保只有经过身份经验的用户才能访问受保护的资源</li>
</ol>
<h2 id="31-安装依赖"><a class="markdownIt-Anchor" href="#31-安装依赖"></a> 3.1. 安装依赖</h2>
<pre><code class="language-bash">yarn add @nestjs/jwt @nestjs/passport passport passport-jwt
yarn add -D @types/passport-jwt</code></pre>
<h2 id="32-认证模块"><a class="markdownIt-Anchor" href="#32-认证模块"></a> 3.2. 认证模块</h2>
<p>在 <code>src</code> 目录下创建 <code>auth</code> 目录，并创建 <code>auth.module.ts</code>：</p>
<pre><code class="language-ts">import &#123; Module &#125; from &#x27;@nestjs/common&#x27;;
import &#123; PassportModule &#125; from &#x27;@nestjs/passport&#x27;;
import &#123; JwtModule &#125; from &#x27;@nestjs/jwt&#x27;;
import &#123; ConfigService &#125; from &#x27;@nestjs/config&#x27;;
import &#123; AuthController &#125; from &#x27;./auth.controller&#x27;;
import &#123; AuthService &#125; from &#x27;./auth.service&#x27;;
import &#123; JwtStrategy &#125; from &#x27;./jwt.strategy&#x27;;
import &#123; UsersModule &#125; from &#x27;../users/users.module&#x27;;

@Module(&#123;
  imports: [
    PassportModule.register(&#123;
      defaultStrategy: &#x27;jwt&#x27;
    &#125;),
    JwtModule.registerAsync(&#123;
      inject: [ConfigService],
      useFactory: async (configService: ConfigService) =&gt; (&#123;
        secret: configService.get&lt;string&gt;(&#x27;JWT_SECRET&#x27;),
        signOptions: &#123;
          audience: configService.get&lt;string&gt;(&#x27;JWT_TOKEN_AUDIENCE&#x27;),
          issuer: configService.get&lt;string&gt;(&#x27;JWT_TOKEN_ISSUER&#x27;),
          expiresIn: configService.get&lt;number&gt;(&#x27;JWT_ACCESS_TOKEN_TTL&#x27;)
        &#125;
      &#125;)
    &#125;),
    UsersModule
  ],
  controllers: [AuthController],
  providers: [AuthService, JwtStrategy],
  exports: [AuthService]
&#125;)
export class AuthModule &#123;&#125;</code></pre>
<h2 id="33-用户验证和令牌生成"><a class="markdownIt-Anchor" href="#33-用户验证和令牌生成"></a> 3.3. 用户验证和令牌生成</h2>
<p>创建 <code>auth.service.ts</code>：</p>
<pre><code class="language-ts">import &#123; Injectable, UnauthorizedException &#125; from &#x27;@nestjs/common&#x27;;
import &#123; JwtService &#125; from &#x27;@nestjs/jwt&#x27;;
import &#123; ConfigService &#125; from &#x27;@nestjs/config&#x27;;
import * as bcrypt from &#x27;bcrypt&#x27;;
import &#123; UsersService &#125; from &#x27;../users/users.service&#x27;;
import &#123; JWTPayload &#125; from &#x27;./interfaces/jwt-payload.interface&#x27;;

@Injectable()
export class AuthService &#123;
  constructor(
    private jwtService: JwtService,
    private usersService: UsersService,
    private configService: ConfigService
  ) &#123;&#125;

  // ...
&#125;</code></pre>
<ol>
<li>
<p>验证用户：</p>
 <pre><code class="language-ts">async validateUser(username: string, password: string) &#123;
  const user = await this.usersService.findUser(&#123; username: username &#125;);
  if (!user) &#123;
    throw new UnauthorizedException(&#x27;用户名或密码错误&#x27;);
  &#125;

  if (!user.verified) &#123;
    throw new UnauthorizedException(&#x27;请先验证邮箱后再登录&#x27;);
  &#125;

  const isPasswordValid = await bcrypt.compare(password, user.password);
  if (!isPasswordValid) &#123;
    throw new UnauthorizedException(&#x27;用户名或密码错误&#x27;);
  &#125;

  return user;
&#125;</code></pre>
</li>
<li>
<p>用户登录：</p>
 <pre><code class="language-ts">async login(user: any) &#123;
  const payload: JWTPayload = &#123;
    sub: user.sub,
    username: user.username,
    email: user.email,
    role: user.role
  &#125;;</code></pre>
<p>首先构建 JWT 载荷。</p>
<blockquote>
<p>JWT 基本上由三个部分组成，使用 <code>.</code> 分割：</p>
<pre><code class="language-plaintext">头.载荷.签名</code></pre>
<ol>
<li>
<p>头包含了令牌类型和使用的签名算法：</p>
 <pre><code class="language-json">&#123;
  &quot;alg&quot;: &quot;HS256&quot;,  // 使用的算法
  &quot;typ&quot;: &quot;JWT&quot;
&#125;</code></pre>
</li>
<li>
<p>载荷包含了我们存储的实际数据：</p>
 <pre><code class="language-json">&#123;
  &quot;sub&quot;: &quot;1234567890&quot;,  // 用户 ID
  &quot;username&quot;: &quot;john_doe&quot;,  // 用户名
  &quot;email&quot;: &quot;john@doe.com&quot;,  // 邮箱
  &quot;role&quot;: &quot;user&quot;,  // 角色
  &quot;iat&quot;: 1516239022,       // 签发时间
  &quot;exp&quot;: 1516242622        // 过期时间
&#125;</code></pre>
</li>
<li>
<p>签名则使用密钥、对头和载荷进行签名：</p>
 <pre><code class="language-javascript">HMACSHA256(
  base64UrlEncode(header) + &quot;.&quot; +
  base64UrlEncode(payload),
  secret  
)</code></pre>
</li>
</ol>
</blockquote>
 <pre><code class="language-ts">const accessToken = this.jwtService.sign(payload, &#123;
  // 令牌接收方
  audience: this.configService.get&lt;string&gt;(&#x27;JWT_TOKEN_AUDIENCE&#x27;),
  // 令牌发行方
  issuer: this.configService.get&lt;string&gt;(&#x27;JWT_TOKEN_ISSUER&#x27;),
  // 令牌有效期
  expiresIn: this.configService.get&lt;number&gt;(&#x27;JWT_ACCESS_TOKEN_TTL&#x27;),
&#125;);</code></pre>
<p>使用 <code>JwtService</code> 生成签名令牌。</p>
 <pre><code class="language-ts">  return &#123;
    access_token: accessToken,
    token_type: &#x27;Bearer&#x27;,
    expires_in: this.configService.get&lt;number&gt;(&#x27;JWT_ACCESS_TOKEN_TTL&#x27;),
    user: &#123;
      id: user.id,
      username: user.username,
      email: user.email,
      role: user.role,
      verified: user.verified
    &#125;
  &#125;;
&#125;</code></pre>
<p>这里说一下令牌类型 <code>Bearer</code>，它是 OAuth 2.0 的标准组成部分。</p>
</li>
<li>
<p>在令牌过期前更新令牌：</p>
 <pre><code class="language-ts">async refreshToken(user: any) &#123;
  const payload: JWTPayload = &#123;
    sub: user.id,
    username: user.username,
    email: user.email,
    role: user.role
  &#125;;

  return &#123;
    access_token: this.jwtService.sign(payload)
  &#125;;
&#125;</code></pre>
<p>当现有访问令牌即将过期时，服务器会生成一个新的访问令牌。</p>
<p>使用与原始登录相同的用户信息构建新的载荷，这样用户就不需要重新登陆，可以无缝继续使用系统。</p>
</li>
<li>
<p>验证令牌：</p>
 <pre><code class="language-ts">verifyToken(token: string) &#123;
  try &#123;
    return this.jwtService.verify(token);
  &#125; catch (error) &#123;
    throw new UnauthorizedException(&#x27;无效的令牌，错误：&#x27;, error);
  &#125;
&#125;</code></pre>
<p>这个方法负责验证传入的 JWT 令牌的有效性。</p>
<p><code>JwtService.verify()</code> 方法会检查令牌是否：</p>
<ul>
<li>签名有效（未被篡改）</li>
<li>未过期</li>
<li>是由我们的系统签发的</li>
</ul>
</li>
</ol>
<p>在 <code>auth</code> 目录下创建 <code>interfaces/jwt-payload.interface.ts</code> 文件，定义 JWT 载荷的 TypeScript 接口：</p>
<pre><code class="language-ts">export interface JWTPayload &#123;
  sub: number;
  username: string;
  email: string;
  role: string;
  iat?: number;
  exp?: number;
  aud?: string;
  iss?: string;
&#125;</code></pre>
<h2 id="34-认证控制器"><a class="markdownIt-Anchor" href="#34-认证控制器"></a> 3.4. 认证控制器</h2>
<p>我们先来写一下登录所需要的 DTO。</p>
<ol>
<li>
<p>定义登录请求的数据结构：</p>
 <pre><code class="language-ts">import &#123; ApiProperty &#125; from &#x27;@nestjs/swagger&#x27;;
import &#123; IsNotEmpty, IsString, MinLength &#125; from &#x27;class-validator&#x27;;

export class LoginDto &#123;
  @ApiProperty(&#123; example: &#x27;johndoe&#x27;, description: &#x27;用户名&#x27; &#125;)
  @IsString()
  @IsNotEmpty(&#123; message: &#x27;用户名不能为空&#x27; &#125;)
  username: string;

  @ApiProperty(&#123; example: &#x27;password123&#x27;, description: &#x27;密码&#x27; &#125;)
  @IsString()
  @IsNotEmpty(&#123; message: &#x27;密码不能为空&#x27; &#125;)
  @MinLength(6, &#123; message: &#x27;密码长度不能小于6位&#x27; &#125;)
  password: string;
&#125;</code></pre>
</li>
<li>
<p>登录响应 DTO：</p>
 <pre><code class="language-ts">import &#123; ApiProperty &#125; from &#x27;@nestjs/swagger&#x27;;

export class LoginResponseDto &#123;
  @ApiProperty(&#123; description: &#x27;访问令牌&#x27; &#125;)
  access_token: string;

  @ApiProperty(&#123; description: &#x27;令牌类型&#x27;, example: &#x27;Bearer&#x27; &#125;)
  token_type: string;

  @ApiProperty(&#123; description: &#x27;过期时间（秒）&#x27;, example: 3600 &#125;)
  expires_in: number;

  @ApiProperty(&#123;
    description: &#x27;用户信息&#x27;,
    example: &#123;
      id: &#x27;1&#x27;,
      username: &#x27;johndoe&#x27;,
      email: &#x27;john@example.com&#x27;,
      role: &#x27;user&#x27;,
      verified: true
    &#125;
  &#125;)
  user: &#123;
    id: string;
    username: string;
    email: string;
    role: string;
    verified: boolean;
  &#125;;
&#125;</code></pre>
</li>
</ol>
<p>创建 <code>auth.controller.ts</code>：</p>
<pre><code class="language-ts">import &#123; Controller, Post, Body, HttpCode, HttpStatus, UnauthorizedException &#125; from &#x27;@nestjs/common&#x27;;
import &#123; ApiTags, ApiOperation, ApiResponse &#125; from &#x27;@nestjs/swagger&#x27;;
import &#123; AuthService &#125; from &#x27;./auth.service&#x27;;
import &#123; LoginDto &#125; from &#x27;./dto/login.dto&#x27;;
import &#123; LoginResponseDto &#125; from &#x27;./dto/login-response.dto&#x27;;
import winstonLogger from &#x27;../loggers/winston.logger&#x27;;

@ApiTags(&#x27;认证&#x27;)
@Controller(&#x27;auth&#x27;)
export class AuthController &#123;
  private readonly logger = winstonLogger;

  constructor(private readonly authService: AuthService) &#123;&#125;

  @ApiOperation(&#123; summary: &#x27;用户登录&#x27; &#125;)
  @ApiResponse(&#123;
    status: HttpStatus.OK,
    description: &#x27;登录成功&#x27;,
    type: LoginResponseDto
  &#125;)
  @ApiResponse(&#123;
    status: HttpStatus.UNAUTHORIZED,
    description: &#x27;登录失败&#x27;
  &#125;)
  @HttpCode(HttpStatus.OK)
  @Post(&#x27;login&#x27;)
  async login(@Body() loginDto: LoginDto): Promise&lt;LoginResponseDto&gt; &#123;
    try &#123;
      const user = await this.authService.validateUser(loginDto.username, loginDto.password);

      this.logger.debug(`用户 $&#123;loginDto.username&#125; 验证通过，正在生成令牌`);
      const loginResult = await this.authService.login(user);
      this.logger.info(`用户 $&#123;loginDto.username&#125; 登录成功`);
      return loginResult;
    &#125; catch (error) &#123;
      this.logger.error(`用户 $&#123;loginDto.username&#125; 登录失败: $&#123;error.message&#125;`);
      throw error;
    &#125;
  &#125;
&#125;</code></pre>
<h2 id="35-策略实现"><a class="markdownIt-Anchor" href="#35-策略实现"></a> 3.5. 策略实现</h2>
<p><code>AuthService.validateUser()</code> 方法仅是用于登录时的用户验证，以及生成初始的 JWT 令牌。</p>
<p>那后续请求该由谁来验证呢？</p>
<blockquote>
<p>可以想象成有这么一个商场。</p>
<p>你在前台登记（登录），工作人员会验证你的身份（<code>AuthService.validateUser()</code>），验证成功后给了你一个特殊的通行证（JWT 令牌）。</p>
<p>你在商场里遛弯，发现有一个 VIP 区域（访问受保护的 API），门口站一保安。你说你想进去，保安说别急先看看你的通行证（JWT 令牌）。</p>
<p>保安需要看到的是：</p>
<ul>
<li>这个通行证是不是商场发的（JWT 签名验证）</li>
<li>通行证有没有过期（JWT 过期检查）</li>
<li>你的会员资格是否还有效（接下来要写的方法）</li>
</ul>
<p>JWT 策略实现就是这个保安。</p>
</blockquote>
<p>创建 <code>jwt.strategy.ts</code>：</p>
<pre><code class="language-ts">import &#123; Injectable, UnauthorizedException &#125; from &#x27;@nestjs/common&#x27;;
import &#123; PassportStrategy &#125; from &#x27;@nestjs/passport&#x27;;
import &#123; ConfigService &#125; from &#x27;@nestjs/config&#x27;;
import &#123; Strategy, ExtractJwt &#125; from &#x27;passport-jwt&#x27;;
import &#123; UsersService &#125; from &#x27;../users/users.service&#x27;;

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) &#123;
  constructor(
    private configService: ConfigService,
    private usersService: UsersService
  ) &#123;
    super(&#123;
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: configService.get&lt;string&gt;(&#x27;JWT_SECRET&#x27;),
      audience: configService.get&lt;string&gt;(&#x27;JWT_TOKEN_AUDIENCE&#x27;),
      issuer: configService.get&lt;string&gt;(&#x27;JWT_TOKEN_ISSUER&#x27;)
    &#125;);
  &#125;</code></pre>
<p>检查用户是否还是“有效会员”：</p>
<pre><code class="language-ts">  async validate(payload: any) &#123;
    const user = await this.usersService.findUser(&#123; id: payload.sub &#125;);
    if (!user) &#123;
      throw new UnauthorizedException(&#x27;用户不存在&#x27;);
    &#125;
    if (!user.verified) &#123;
      throw new UnauthorizedException(&#x27;用户未验证&#x27;);
    &#125;

    return &#123;
      id: user.id,
      username: user.username,
      email: user.email,
      role: user.role
    &#125;;
  &#125;
&#125;</code></pre>
<h2 id="36-jwt-守卫"><a class="markdownIt-Anchor" href="#36-jwt-守卫"></a> 3.6. JWT 守卫</h2>
<blockquote>
<p>先前的商场例子里，提到了“受保护的 API”。</p>
<p>那么要如何创建这么个“VIP 区域”呢？我们就需要用到 JWT 守卫。</p>
</blockquote>
<p>创建 <code>jwt-auth.guard.ts</code>：</p>
<pre><code class="language-ts">@Injectable()
export class JwtAuthGuard extends AuthGuard(&#x27;jwt&#x27;) &#123;
  handleRequest(error: any, user: any, info: any) &#123;
    if (error || !user) &#123;
      throw new UnauthorizedException(&#x27;验证失败&#x27;);
    &#125;
    return user;
  &#125;
&#125;</code></pre>
<p>守卫的工作流程：</p>
<ol>
<li>收到请求时，检查 <code>Authorization</code> 头部是否包含 JWT 令牌</li>
<li>如果没有令牌或令牌无效，直接拦截请求并返回 <code>401</code> 错误</li>
<li>如果令牌有效，让请求通过并继续处理</li>
</ol>
<p>使用方式也很简单：</p>
<pre><code class="language-ts">@Controller(&#x27;orders&#x27;)
export class OrdersController &#123;
  constructor(private ordersService: OrdersService) &#123;&#125;

  // 无需登录即可访问的公开 API
  // 例如获取热门商品
  @Get(&#x27;popular&#x27;)
  getPopularOrders() &#123;
    return this.ordersService.getPopularOrders();
  &#125;

  // 需要登录才能访问的 API
  // 例如用户的订单
  @UseGuards(JwtAuthGuard)
  @Get(&#x27;my-orders&#x27;)
  getMyOrders(@CurrentUser() user: any) &#123;
    return this.ordersService.getOrdersByUserId(user.id);
  &#125;

  // 用户下单
  @UseGuards(JwtAuthGuard)
  @Post(&#x27;create&#x27;)
  createOrder(@CurrentUser() user: any, @Body() orderData: any) &#123;
    return this.ordersService.createOrder(user.id, orderData);
  &#125;
&#125;</code></pre>
<p>也可以直接保护控制器的所有路由：</p>
<pre><code class="language-ts">@UseGuards(JwtAuthGuard)  // 保护个人信息路由
@Controller(&#x27;profile&#x27;)
export class ProfileController &#123;
  @Get()
  getProfile(@CurrentUser() user: any) &#123;
    return user;
  &#125;

  @Put()
  updateProfile(@CurrentUser() user: any, @Body() updateData: any) &#123;
    return this.profileService.update(user.id, updateData);
  &#125;
&#125;</code></pre>
<h2 id="37-用户装饰器"><a class="markdownIt-Anchor" href="#37-用户装饰器"></a> 3.7. 用户装饰器</h2>
<p>假设我们有一个购物车的 API，需要获取当前用户的购物车信息：</p>
<pre><code class="language-ts">@Controller(&#x27;cart&#x27;)
export class CartController &#123;
  constructor(private cartService: CartService) &#123;&#125;

  @UseGuards(JwtAuthGuard)
  @Get(&#x27;my-cart&#x27;)
  async getMyCart(@CurrentUser() user: any) &#123;
    // user 对象包含了 JWT 令牌中的用户信息
    return this.cartService.getCartByUserId(user.id);
  &#125;
&#125;</code></pre>
<p>如果没有 <code>CurrentUser</code> 装饰器，我们需要：</p>
<pre><code class="language-ts">@Get(&#x27;my-cart&#x27;)
async getMyCart(@Request() req: any) &#123;
  const user = req.user;  // 从 request 对象中手动获取用户信息
  return this.cartService.getCartByUserId(user.id);
&#125;</code></pre>
<p><code>CurrentUser</code> 装饰器的实现：</p>
<pre><code class="language-ts">import &#123; createParamDecorator, ExecutionContext &#125; from &#x27;@nestjs/common&#x27;;

export const CurrentUser = createParamDecorator((data: unknown, ctx: ExecutionContext) =&gt; &#123;
  const request = ctx.switchToHttp().getRequest();
  return request.user;
&#125;);</code></pre>
<p>它的好处在于：</p>
<ul>
<li>简化代码：不需要手动从 <code>request</code> 中提取用户信息</li>
<li>类型安全：可以明确知道返回的是用户对象</li>
<li>可重用性：在任何需要当前用户信息的地方都可以使用</li>
<li>关注点分离：控制器方法只需要关心用户信息，不需要关心它是如何获取的</li>
</ul>
<p>像是还可以有这样的使用场景：</p>
<pre><code class="language-ts">@Controller(&#x27;users&#x27;)
export class UsersController &#123;
  @UseGuards(JwtAuthGuard)
  @Get(&#x27;profile&#x27;)
  getProfile(@CurrentUser() user: any) &#123;
    return user;  // 直接返回用户信息
  &#125;
&#125;</code></pre>
<h1 id="4-添加记住我功能"><a class="markdownIt-Anchor" href="#4-添加记住我功能"></a> 4. 添加记住我功能</h1>
<p>在现代电商平台中，用户体验是至关重要的。用户希望能够快速、便捷地访问他们的账户，而不需要每次都重新输入用户名和密码。这就是“记住我”功能的用武之地。</p>
<p>通过“记住我”功能，用户可以选择在登录时保持一段时间的登录状态，即使关闭浏览器或重新打开应用，用户仍然可以自动登录，无需再次输入凭证。</p>
<h2 id="41-技术方案设计"><a class="markdownIt-Anchor" href="#41-技术方案设计"></a> 4.1. 技术方案设计</h2>
<p>我们采用 <code>RefreshToken</code> + <code>AccessToken</code> 的双令牌认证方案：</p>
<ul>
<li><code>AccessToken</code>：短期令牌，用于访问 API</li>
<li><code>RefreshToken</code>：长期令牌，用于刷新 <code>AccessToken</code></li>
</ul>
<p>这种方案的优势在于：</p>
<ul>
<li>安全性高：<code>AccessToken</code> 短期有效，即使泄露风险也较小</li>
<li>用户体验好：<code>RefreshToken</code> 可以静默刷新 <code>AccessToken</code>，用户无感知</li>
<li>可控性强：可以随时注销 <code>RefreshToken</code>，确保账户安全</li>
</ul>
<svg aria-roledescription="flowchart-v2" role="graphics-document document" viewbox="-8 -8 466.64453125 879.421875" style="max-width: 466.64453125px;" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" width="100%" id="mermaid-1757905075593"><style>#mermaid-1757905075593{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mermaid-1757905075593 .error-icon{fill:#552222;}#mermaid-1757905075593 .error-text{fill:#552222;stroke:#552222;}#mermaid-1757905075593 .edge-thickness-normal{stroke-width:2px;}#mermaid-1757905075593 .edge-thickness-thick{stroke-width:3.5px;}#mermaid-1757905075593 .edge-pattern-solid{stroke-dasharray:0;}#mermaid-1757905075593 .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-1757905075593 .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-1757905075593 .marker{fill:#333333;stroke:#333333;}#mermaid-1757905075593 .marker.cross{stroke:#333333;}#mermaid-1757905075593 svg{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;}#mermaid-1757905075593 .label{font-family:"trebuchet ms",verdana,arial,sans-serif;color:#333;}#mermaid-1757905075593 .cluster-label text{fill:#333;}#mermaid-1757905075593 .cluster-label span,#mermaid-1757905075593 p{color:#333;}#mermaid-1757905075593 .label text,#mermaid-1757905075593 span,#mermaid-1757905075593 p{fill:#333;color:#333;}#mermaid-1757905075593 .node rect,#mermaid-1757905075593 .node circle,#mermaid-1757905075593 .node ellipse,#mermaid-1757905075593 .node polygon,#mermaid-1757905075593 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mermaid-1757905075593 .flowchart-label text{text-anchor:middle;}#mermaid-1757905075593 .node .katex path{fill:#000;stroke:#000;stroke-width:1px;}#mermaid-1757905075593 .node .label{text-align:center;}#mermaid-1757905075593 .node.clickable{cursor:pointer;}#mermaid-1757905075593 .arrowheadPath{fill:#333333;}#mermaid-1757905075593 .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mermaid-1757905075593 .flowchart-link{stroke:#333333;fill:none;}#mermaid-1757905075593 .edgeLabel{background-color:#e8e8e8;text-align:center;}#mermaid-1757905075593 .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mermaid-1757905075593 .labelBkg{background-color:rgba(232, 232, 232, 0.5);}#mermaid-1757905075593 .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mermaid-1757905075593 .cluster text{fill:#333;}#mermaid-1757905075593 .cluster span,#mermaid-1757905075593 p{color:#333;}#mermaid-1757905075593 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mermaid-1757905075593 .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mermaid-1757905075593 :root{--mermaid-font-family:"trebuchet ms",verdana,arial,sans-serif;}</style><g><marker orient="auto" markerheight="12" markerwidth="12" markerunits="userSpaceOnUse" refy="5" refx="6" viewbox="0 0 10 10" class="marker flowchart" id="mermaid-1757905075593_flowchart-pointEnd"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 0 L 10 5 L 0 10 z"/></marker><marker orient="auto" markerheight="12" markerwidth="12" markerunits="userSpaceOnUse" refy="5" refx="4.5" viewbox="0 0 10 10" class="marker flowchart" id="mermaid-1757905075593_flowchart-pointStart"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 5 L 10 10 L 10 0 z"/></marker><marker orient="auto" markerheight="11" markerwidth="11" markerunits="userSpaceOnUse" refy="5" refx="11" viewbox="0 0 10 10" class="marker flowchart" id="mermaid-1757905075593_flowchart-circleEnd"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"/></marker><marker orient="auto" markerheight="11" markerwidth="11" markerunits="userSpaceOnUse" refy="5" refx="-1" viewbox="0 0 10 10" class="marker flowchart" id="mermaid-1757905075593_flowchart-circleStart"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"/></marker><marker orient="auto" markerheight="11" markerwidth="11" markerunits="userSpaceOnUse" refy="5.2" refx="12" viewbox="0 0 11 11" class="marker cross flowchart" id="mermaid-1757905075593_flowchart-crossEnd"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"/></marker><marker orient="auto" markerheight="11" markerwidth="11" markerunits="userSpaceOnUse" refy="5.2" refx="-1" viewbox="0 0 11 11" class="marker cross flowchart" id="mermaid-1757905075593_flowchart-crossStart"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"/></marker><g class="root"><g class="clusters"><g class="edgePaths"><path marker-end="url(#mermaid-1757905075593_flowchart-pointEnd)" style="fill:none;" class="edge-thickness-normal edge-pattern-solid flowchart-link LS-A LE-B" id="L-A-B-0" d="M197.184,36L197.184,40.167C197.184,44.333,197.184,52.667,197.25,60.2C197.316,67.734,197.448,74.467,197.514,77.834L197.58,81.201"/><path marker-end="url(#mermaid-1757905075593_flowchart-pointEnd)" style="fill:none;" class="edge-thickness-normal edge-pattern-solid flowchart-link LS-B LE-C" id="L-B-C-0" d="M166.012,169.828L152.2,180.94C138.388,192.052,110.764,214.276,96.952,230.421C83.141,246.567,83.141,256.633,83.141,261.667L83.141,266.7"/><path marker-end="url(#mermaid-1757905075593_flowchart-pointEnd)" style="fill:none;" class="edge-thickness-normal edge-pattern-solid flowchart-link LS-B LE-D" id="L-B-D-0" d="M229.356,169.828L243.001,180.94C256.646,192.052,283.936,214.276,297.581,230.421C311.227,246.567,311.227,256.633,311.227,261.667L311.227,266.7"/><path marker-end="url(#mermaid-1757905075593_flowchart-pointEnd)" style="fill:none;" class="edge-thickness-normal edge-pattern-solid flowchart-link LS-C LE-E" id="L-C-E-0" d="M83.141,308L83.141,312.167C83.141,316.333,83.141,324.667,93.365,332.688C103.589,340.71,124.037,348.42,134.261,352.275L144.485,356.13"/><path marker-end="url(#mermaid-1757905075593_flowchart-pointEnd)" style="fill:none;" class="edge-thickness-normal edge-pattern-solid flowchart-link LS-D LE-E" id="L-D-E-0" d="M311.227,308L311.227,312.167C311.227,316.333,311.227,324.667,301.002,332.688C290.778,340.71,270.33,348.42,260.106,352.275L249.882,356.13"/><path marker-end="url(#mermaid-1757905075593_flowchart-pointEnd)" style="fill:none;" class="edge-thickness-normal edge-pattern-solid flowchart-link LS-E LE-F" id="L-E-F-0" d="M197.184,394L197.184,398.167C197.184,402.333,197.184,410.667,197.184,418.117C197.184,425.567,197.184,432.133,197.184,435.417L197.184,438.7"/><path marker-end="url(#mermaid-1757905075593_flowchart-pointEnd)" style="fill:none;" class="edge-thickness-normal edge-pattern-solid flowchart-link LS-F LE-G" id="L-F-G-0" d="M197.184,480L197.184,484.167C197.184,488.333,197.184,496.667,197.25,504.2C197.316,511.734,197.448,518.467,197.514,521.834L197.58,525.201"/><path marker-end="url(#mermaid-1757905075593_flowchart-pointEnd)" style="fill:none;" class="edge-thickness-normal edge-pattern-solid flowchart-link LS-G LE-H" id="L-G-H-0" d="M161.205,634.443L148.148,646.356C135.091,658.269,108.977,682.096,95.92,699.042C82.863,715.989,82.863,726.055,82.863,731.089L82.863,736.122"/><path marker-end="url(#mermaid-1757905075593_flowchart-pointEnd)" style="fill:none;" class="edge-thickness-normal edge-pattern-solid flowchart-link LS-G LE-I" id="L-G-I-0" d="M234.163,634.443L247.053,646.356C259.943,658.269,285.723,682.096,298.614,699.042C311.504,715.989,311.504,726.055,311.504,731.089L311.504,736.122"/><path marker-end="url(#mermaid-1757905075593_flowchart-pointEnd)" style="fill:none;" class="edge-thickness-normal edge-pattern-solid flowchart-link LS-I LE-J" id="L-I-J-0" d="M311.504,777.422L311.504,781.589C311.504,785.755,311.504,794.089,311.504,801.539C311.504,808.989,311.504,815.555,311.504,818.839L311.504,822.122"/></g><g class="edgeLabels"><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"/></div></foreignobject></g></g><g transform="translate(83.140625, 236.5)" class="edgeLabel"><g transform="translate(-8, -10.5)" class="label"><foreignobject height="21" width="16"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel">是</span></div></foreignobject></g></g><g transform="translate(311.2265625, 236.5)" class="edgeLabel"><g transform="translate(-8, -10.5)" class="label"><foreignobject height="21" width="16"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel">否</span></div></foreignobject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"/></div></foreignobject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"/></div></foreignobject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"/></div></foreignobject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"/></div></foreignobject></g></g><g transform="translate(82.86328125, 705.921875)" class="edgeLabel"><g transform="translate(-16, -10.5)" class="label"><foreignobject height="21" width="32"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel">有效</span></div></foreignobject></g></g><g transform="translate(311.50390625, 705.921875)" class="edgeLabel"><g transform="translate(-16, -10.5)" class="label"><foreignobject height="21" width="32"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel">无效</span></div></foreignobject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"/></div></foreignobject></g></g></g><g class="nodes"><g transform="translate(197.18359375, 18)" data-id="A" data-node="true" id="flowchart-A-0" class="node default default flowchart-label"><rect height="36" width="79" y="-18" x="-39.5" ry="0" rx="0" style="" class="basic label-container"/><g transform="translate(-32, -10.5)" style="" class="label"><rect/><foreignobject height="21" width="64"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel">用户登录</span></div></foreignobject></g></g><g transform="translate(197.18359375, 143.5)" data-id="B" data-node="true" id="flowchart-B-1" class="node default default flowchart-label"><polygon style="" transform="translate(-57.5,57.5)" class="label-container" points="57.5,0 115,-57.5 57.5,-115 0,-57.5"/><g transform="translate(-32, -10.5)" style="" class="label"><rect/><foreignobject height="21" width="64"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel">记住我？</span></div></foreignobject></g></g><g transform="translate(83.140625, 290)" data-id="C" data-node="true" id="flowchart-C-3" class="node default default flowchart-label"><rect height="36" width="166.28125" y="-18" x="-83.140625" ry="0" rx="0" style="" class="basic label-container"/><g transform="translate(-75.640625, -10.5)" style="" class="label"><rect/><foreignobject height="21" width="151.28125"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel">生成7天RefreshToken</span></div></foreignobject></g></g><g transform="translate(311.2265625, 290)" data-id="D" data-node="true" id="flowchart-D-5" class="node default default flowchart-label"><rect height="36" width="189.890625" y="-18" x="-94.9453125" ry="0" rx="0" style="" class="basic label-container"/><g transform="translate(-87.4453125, -10.5)" style="" class="label"><rect/><foreignobject height="21" width="174.890625"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel">生成会话级RefreshToken</span></div></foreignobject></g></g><g transform="translate(197.18359375, 376)" data-id="E" data-node="true" id="flowchart-E-7" class="node default default flowchart-label"><rect height="36" width="238.671875" y="-18" x="-119.3359375" ry="0" rx="0" style="" class="basic label-container"/><g transform="translate(-111.8359375, -10.5)" style="" class="label"><rect/><foreignobject height="21" width="223.671875"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel">返回AccessToken+RefreshToken</span></div></foreignobject></g></g><g transform="translate(197.18359375, 462)" data-id="F" data-node="true" id="flowchart-F-11" class="node default default flowchart-label"><rect height="36" width="190.203125" y="-18" x="-95.1015625" ry="0" rx="0" style="" class="basic label-container"/><g transform="translate(-87.6015625, -10.5)" style="" class="label"><rect/><foreignobject height="21" width="175.203125"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel">访问API携带AccessToken</span></div></foreignobject></g></g><g transform="translate(197.18359375, 600.2109375)" data-id="G" data-node="true" id="flowchart-G-13" class="node default default flowchart-label"><polygon style="" transform="translate(-70.2109375,70.2109375)" class="label-container" points="70.2109375,0 140.421875,-70.2109375 70.2109375,-140.421875 0,-70.2109375"/><g transform="translate(-44.7109375, -10.5)" style="" class="label"><rect/><foreignobject height="21" width="89.421875"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel">Token有效？</span></div></foreignobject></g></g><g transform="translate(82.86328125, 759.421875)" data-id="H" data-node="true" id="flowchart-H-15" class="node default default flowchart-label"><rect height="36" width="79" y="-18" x="-39.5" ry="0" rx="0" style="" class="basic label-container"/><g transform="translate(-32, -10.5)" style="" class="label"><rect/><foreignobject height="21" width="64"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel">正常访问</span></div></foreignobject></g></g><g transform="translate(311.50390625, 759.421875)" data-id="I" data-node="true" id="flowchart-I-17" class="node default default flowchart-label"><rect height="36" width="278.28125" y="-18" x="-139.140625" ry="0" rx="0" style="" class="basic label-container"/><g transform="translate(-131.640625, -10.5)" style="" class="label"><rect/><foreignobject height="21" width="263.28125"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel">使用RefreshToken获取新AccessToken</span></div></foreignobject></g></g><g transform="translate(311.50390625, 845.421875)" data-id="J" data-node="true" id="flowchart-J-19" class="node default default flowchart-label"><rect height="36" width="133.8125" y="-18" x="-66.90625" ry="0" rx="0" style="" class="basic label-container"/><g transform="translate(-59.40625, -10.5)" style="" class="label"><rect/><foreignobject height="21" width="118.8125"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel">重新尝试API请求</span></div></foreignobject></g></g></g></g></g></g></svg>
<h2 id="42-环境配置"><a class="markdownIt-Anchor" href="#42-环境配置"></a> 4.2. 环境配置</h2>
<h4 id="421-修改环境变量"><a class="markdownIt-Anchor" href="#421-修改环境变量"></a> 4.2.1. 修改环境变量</h4>
<p>首先需要在 <code>.env</code> 文件中添加新的配置项：</p>
<pre><code class="language-plaintext"># JWT 
JWT_ACCESS_SECRET=access_secret 
JWT_REFRESH_SECRET=refresh_secret 
JWT_TOKEN_AUDIENCE=localhost:4000 
JWT_TOKEN_ISSUER=localhost:4000 
JWT_ACCESS_TOKEN_TTL=3600 
JWT_REFRESH_TOKEN_TTL=604800</code></pre>
<p>配置说明：</p>
<ul>
<li><code>JWT_ACCESS_SECRET</code>：访问令牌密钥</li>
<li><code>JWT_REFRESH_SECRET</code>：刷新令牌密钥</li>
<li><code>JWT_ACCESS_TOKEN_TTL</code>：访问令牌有效期（1 小时）</li>
<li><code>JWT_REFRESH_TOKEN_TTL</code>：刷新令牌有效期（7 天）</li>
</ul>
<h4 id="422-更新配置验证"><a class="markdownIt-Anchor" href="#422-更新配置验证"></a> 4.2.2. 更新配置验证</h4>
<p>在 <code>AppModule</code> 中更新 <code>ConfigModule</code> 的配置验证：</p>
<pre><code class="language-ts">@Module(&#123;
  imports: [
    ConfigModule.forRoot(&#123;
      validationSchema: Joi.object(&#123;
        // ... 其他配置项 ...
        
        // JWT 配置
        JWT_ACCESS_SECRET: Joi.string().required(),
        JWT_REFRESH_SECRET: Joi.string().required(),
        JWT_TOKEN_AUDIENCE: Joi.string().required(),
        JWT_TOKEN_ISSUER: Joi.string().required(),
        JWT_ACCESS_TOKEN_TTL: Joi.number().default(3600),
        JWT_REFRESH_TOKEN_TTL: Joi.number().default(604800)
      &#125;)
    &#125;)
  ]
&#125;)</code></pre>
<h4 id="423-更新认证模块"><a class="markdownIt-Anchor" href="#423-更新认证模块"></a> 4.2.3. 更新认证模块</h4>
<p>在 <code>AuthModule</code> 中更新 <code>JwtModule</code> 的配置：</p>
<pre><code class="language-ts">@Module(&#123;
  imports: [
    JwtModule.registerAsync(&#123;
      inject: [ConfigService],
      useFactory: async (configService: ConfigService) =&gt; (&#123;
        secret: configService.get&lt;string&gt;(&#x27;JWT_ACCESS_SECRET&#x27;),
        signOptions: &#123;
          audience: configService.get&lt;string&gt;(&#x27;JWT_TOKEN_AUDIENCE&#x27;),
          issuer: configService.get&lt;string&gt;(&#x27;JWT_TOKEN_ISSUER&#x27;),
          expiresIn: configService.get&lt;number&gt;(&#x27;JWT_ACCESS_TOKEN_TTL&#x27;)
        &#125;
      &#125;)
    &#125;)
  ]
&#125;)</code></pre>
<h4 id="424-更新-jwt-策略"><a class="markdownIt-Anchor" href="#424-更新-jwt-策略"></a> 4.2.4. 更新 JWT 策略</h4>
<p>修改 <code>JwtStrategy</code> 的配置：</p>
<pre><code class="language-ts">@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) &#123;
  constructor(private configService: ConfigService) &#123;
    super(&#123;
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: configService.get&lt;string&gt;(&#x27;JWT_ACCESS_SECRET&#x27;),
      audience: configService.get&lt;string&gt;(&#x27;JWT_TOKEN_AUDIENCE&#x27;),
      issuer: configService.get&lt;string&gt;(&#x27;JWT_TOKEN_ISSUER&#x27;)
    &#125;);
  &#125;
&#125;</code></pre>
<h2 id="43-令牌生成与签名实现"><a class="markdownIt-Anchor" href="#43-令牌生成与签名实现"></a> 4.3. 令牌生成与签名实现</h2>
<h4 id="431-jwt-配置抽离"><a class="markdownIt-Anchor" href="#431-jwt-配置抽离"></a> 4.3.1. JWT 配置抽离</h4>
<p>为了更好地管理 JWT 相关的配置，我们首先创建了一个专门的配置文件 <code>jwt.config.ts</code>：</p>
<pre><code class="language-ts">import &#123; ConfigService &#125; from &#x27;@nestjs/config&#x27;;

export const getJWTVerifyOptions = (configService: ConfigService) =&gt; (&#123;
  accessToken: &#123;
    secret: configService.get(&#x27;JWT_ACCESS_SECRET&#x27;),
    audience: configService.get(&#x27;JWT_TOKEN_AUDIENCE&#x27;),
    issuer: configService.get(&#x27;JWT_TOKEN_ISSUER&#x27;),
    expiresIn: configService.get(&#x27;JWT_ACCESS_TOKEN_TTL&#x27;)
  &#125;,
  refreshToken: &#123;
    secret: configService.get(&#x27;JWT_REFRESH_SECRET&#x27;),
    audience: configService.get(&#x27;JWT_TOKEN_AUDIENCE&#x27;),
    issuer: configService.get(&#x27;JWT_TOKEN_ISSUER&#x27;),
    expiresIn: configService.get(&#x27;JWT_REFRESH_TOKEN_TTL&#x27;)
  &#125;
&#125;);</code></pre>
<p>这样做的好处是：</p>
<ul>
<li>集中管理 JWT 配置</li>
<li>方便在不同地方复用配置</li>
<li>确保配置的一致性</li>
</ul>
<h4 id="432-数据结构调整"><a class="markdownIt-Anchor" href="#432-数据结构调整"></a> 4.3.2. 数据结构调整</h4>
<ol>
<li>
<p>在 <code>Users</code> 实体中添加 <code>refreshToken</code> 字段，用于存储刷新令牌：</p>
 <pre><code class="language-ts">@Column(&#123; nullable: true &#125;)
refreshToken?: string;</code></pre>
</li>
<li>
<p>在 <code>LoginDto</code> 中添加“记住我”选项：</p>
 <pre><code class="language-ts">@ApiProperty(&#123; example: false, required: false, description: &#x27;是否记住我&#x27; &#125;)
@IsBoolean()
@IsOptional()
rememberMe?: boolean;</code></pre>
</li>
<li>
<p>在 <code>LoginResponseDto</code> 中新增刷新令牌字段：</p>
 <pre><code class="language-ts">@ApiProperty(&#123; description: &#x27;刷新令牌&#x27; &#125;)
refresh_token: string;</code></pre>
</li>
</ol>
<h4 id="433-认证服务实现"><a class="markdownIt-Anchor" href="#433-认证服务实现"></a> 4.3.3. 认证服务实现</h4>
<p>在 <code>AuthService</code> 中，我们需要进行以下主要改动：</p>
<ol>
<li>
<p>为了支持“记住我”功能，需要在用户登录时生成两种令牌：访问令牌（<code>accessToken</code>）和刷新令牌（<code>refreshToken</code>）。</p>
<ol>
<li>
<p>将原有的令牌生成逻辑修改为：</p>
 <pre><code class="language-ts">// 之前的代码
const accessToken = this.jwtService.sign(payload, &#123;
  audience: this.configService.get&lt;string&gt;(&#x27;JWT_TOKEN_AUDIENCE&#x27;),
  issuer: this.configService.get&lt;string&gt;(&#x27;JWT_TOKEN_ISSUER&#x27;),
  expiresIn: this.configService.get&lt;number&gt;(&#x27;JWT_ACCESS_TOKEN_TTL&#x27;)
&#125;);

// 修改后的代码
const accessToken = this.jwtService.sign(payload);
const refreshToken = this.jwtService.sign(
  payload, 
  getJWTVerifyOptions(this.configService).refreshToken
);</code></pre>
</li>
<li>
<p>在登录响应中添加刷新令牌：</p>
 <pre><code class="language-ts">// 之前的返回结果
return &#123;
  access_token: accessToken,
  token_type: &#x27;Bearer&#x27;,
  expires_in: this.configService.get&lt;number&gt;(&#x27;JWT_ACCESS_TOKEN_TTL&#x27;),
  user: &#123; ... &#125;
&#125;;

// 修改后的返回结果
return &#123;
  access_token: accessToken,
  refresh_token: refreshToken,  // 新增
  token_type: &#x27;Bearer&#x27;,
  expires_in: this.configService.get&lt;number&gt;(&#x27;JWT_ACCESS_TOKEN_TTL&#x27;),
  user: &#123; ... &#125;
&#125;;</code></pre>
</li>
</ol>
</li>
<li>
<p>新增令牌刷新功能，用于在访问令牌过期后获取新的访问令牌：</p>
 <pre><code class="language-ts">async refresh(refreshToken: string) &#123;
  this.logger.debug(`刷新访问令牌`);

  // 验证刷新令牌
  const refreshPayload = this.jwtService.verify(
    refreshToken, 
    getJWTVerifyOptions(this.configService).refreshToken
  );
  
  // 查找用户
  const user = await this.usersService.findUser(&#123; id: refreshPayload.sub &#125;);
  if (!user) &#123;
    this.logger.warn(`刷新失败，未找到用户：$&#123;user.username&#125;`);
    throw new UnauthorizedException(&#x27;用户不存在&#x27;);
  &#125;

  // 生成新的访问令牌
  const newAccessToken = this.jwtService.sign(
    &#123;
      sub: user.id,
      username: user.username,
      email: user.email,
      role: user.role
    &#125;,
    getJWTVerifyOptions(this.configService).accessToken
  );

  this.logger.info(`已为用户刷新访问令牌：$&#123;user.username&#125;`);

  return &#123;
    access_token: newAccessToken,
    token_type: &#x27;Bearer&#x27;,
    expires_in: this.configService.get&lt;number&gt;(&#x27;JWT_REFRESH_TOKEN_TTL&#x27;)
  &#125;;
&#125;</code></pre>
</li>
<li>
<p>添加登出功能，用于清除用户的刷新令牌：</p>
 <pre><code class="language-ts">async logout(userId: string): Promise&lt;void&gt; &#123;
  await this.usersService.update(userId, &#123; refreshToken: null &#125;);
&#125;</code></pre>
</li>
</ol>
<h4 id="434-控制器层改造"><a class="markdownIt-Anchor" href="#434-控制器层改造"></a> 4.3.4. 控制器层改造</h4>
<p>在 <code>AuthController</code> 中，我们需要添加新的接口来支持“记住我”功能：</p>
<pre><code class="language-ts">@ApiOperation(&#123; summary: &#x27;刷新访问令牌&#x27; &#125;)
@UseGuards(JwtRefreshGuard)
@HttpCode(HttpStatus.OK)
@Post(&#x27;refresh&#x27;)
async refresh(@Body() body: &#123; refreshToken: string &#125;) &#123;
  try &#123;
    return await this.authService.refresh(body.refreshToken);
  &#125; catch (error) &#123;
    this.logger.error(`刷新 Token 失败：$&#123;error.message&#125;`);
    throw new UnauthorizedException(&#x27;刷新 Token 失败&#x27;);
  &#125;
&#125;</code></pre>
<p>同时添加获取当前用户信息和登出的接口：</p>
<pre><code class="language-ts">@ApiOperation(&#123; summary: &#x27;获取当前用户信息&#x27; &#125;)
@HttpCode(HttpStatus.OK)
@Get(&#x27;me&#x27;)
async getCurrentUser(@CurrentUser() user: JWTPayload) &#123;
  return this.authService.getCurrentUser(user.sub);
&#125;

@ApiOperation(&#123; summary: &#x27;登出用户&#x27; &#125;)
@HttpCode(HttpStatus.OK)
@UseGuards(JwtAuthGuard)
@Post(&#x27;logout&#x27;)
async logout(@Req() req: Request) &#123;
  const user = req.user as JWTPayload;
  await this.authService.logout(user.sub);
  return &#123; message: &#x27;已登出&#x27; &#125;;
&#125;</code></pre>
<h4 id="435-守卫机制完善"><a class="markdownIt-Anchor" href="#435-守卫机制完善"></a> 4.3.5. 守卫机制完善</h4>
<ol>
<li>
<p>访问令牌守卫</p>
<p>原来的 <code>JwtAuthGuard</code> 实现存在几个问题：</p>
<ul>
<li>没有直接验证 <code>token</code> 的有效性</li>
<li>没有正确处理 <code>audience</code> 和 <code>issuer</code> 的验证</li>
</ul>
<p>看一眼原本的代码：</p>
 <pre><code class="language-ts">@Injectable()
export class JwtAuthGuard extends AuthGuard(&#x27;jwt&#x27;) &#123;
  handleRequest(error: any, user: any, info: any) &#123;
    if (error || !user) &#123;
      throw new UnauthorizedException(&#x27;验证失败&#x27;);
    &#125;
    return user;
  &#125;
&#125;</code></pre>
<p>现在，我们重新实现了这个守卫，提供了更严格的验证和更好的错误处理：</p>
 <pre><code class="language-ts">import &#123; CanActivate, ExecutionContext, Injectable, UnauthorizedException &#125; from &#x27;@nestjs/common&#x27;;
import &#123; JwtService &#125; from &#x27;@nestjs/jwt&#x27;;
import &#123; ConfigService &#125; from &#x27;@nestjs/config&#x27;;
import &#123; TokenUtils &#125; from &#x27;../utils/token.utils&#x27;;
import winstonLogger from &#x27;../../loggers/winston.logger&#x27;;

@Injectable()
export class JwtAuthGuard implements CanActivate &#123;
  private logger = winstonLogger;

  constructor(
    private jwtService: JwtService,
    private configService: ConfigService
  ) &#123;&#125;

  async canActivate(context: ExecutionContext): Promise&lt;boolean&gt; &#123;
    const token = TokenUtils.extractTokenFromContext(context);

    if (!token) &#123;
      this.logger.warn(`未提供访问令牌：$&#123;context&#125;`);
      throw new UnauthorizedException(&#x27;未提供访问令牌&#x27;);
    &#125;

    try &#123;
      const request = context.switchToHttp().getRequest();
      request.user = await this.jwtService.verifyAsync(token, &#123;
        audience: this.configService.get&lt;string&gt;(&#x27;JWT_TOKEN_AUDIENCE&#x27;),
        issuer: this.configService.get&lt;string&gt;(&#x27;JWT_TOKEN_ISSUER&#x27;)
      &#125;);
      return true;
    &#125; catch (error) &#123;
      this.logger.error(`验证访问令牌失败：$&#123;error.message&#125;`, error.stack);
      throw new UnauthorizedException(&#x27;无效的访问令牌&#x27;);
    &#125;
  &#125;
&#125;</code></pre>
</li>
<li>
<p>刷新令牌守卫</p>
<p>新增 <code>JwtRefreshGuard</code> 专门用于处理刷新令牌的验证：</p>
 <pre><code class="language-ts">import &#123; ExecutionContext, Injectable, UnauthorizedException &#125; from &#x27;@nestjs/common&#x27;;
import &#123; ConfigService &#125; from &#x27;@nestjs/config&#x27;;
import &#123; JwtService &#125; from &#x27;@nestjs/jwt&#x27;;
import &#123; TokenUtils &#125; from &#x27;../utils/token.utils&#x27;;
import &#123; getJWTVerifyOptions &#125; from &#x27;../../config/jwt.config&#x27;;
import winstonLogger from &#x27;../../loggers/winston.logger&#x27;;

@Injectable()
export class JwtRefreshGuard &#123;
  private logger = winstonLogger;

  constructor(
    private jwtService: JwtService,
    private configService: ConfigService
  ) &#123;&#125;

  async canActivate(context: ExecutionContext) &#123;
    const token = TokenUtils.extractTokenFromContext(context);
    const options = getJWTVerifyOptions(this.configService).refreshToken;

    try &#123;
      this.jwtService.verify(token, options);
      return true;
    &#125; catch (error) &#123;
      this.logger.error(`验证刷新令牌失败：$&#123;error.message&#125;`, error.stack);
      throw new UnauthorizedException(&#x27;无效的刷新令牌&#x27;);
    &#125;
  &#125;
&#125;</code></pre>
</li>
</ol>
<h4 id="436-工具类支持"><a class="markdownIt-Anchor" href="#436-工具类支持"></a> 4.3.6. 工具类支持</h4>
<p>在之前的实现中，令牌提取的逻辑分散在各处，容易导致处理不一致。为了统一处理令牌的提取逻辑，新增 <code>TokenUtils</code> 工具类：</p>
<pre><code class="language-ts">import &#123; ExecutionContext &#125; from &#x27;@nestjs/common&#x27;;
import &#123; Request &#125; from &#x27;express&#x27;;

export class TokenUtils &#123;
  static extractToken(request: Request): string | undefined &#123;
    const [type, token] = request.headers.authorization?.split(&#x27; &#x27;) ?? [];
    return type === &#x27;Bearer&#x27; ? token : undefined;
  &#125;

  static extractTokenFromContext(context: ExecutionContext): string | undefined &#123;
    const request = context.switchToHttp().getRequest&lt;Request&gt;();
    return this.extractToken(request);
  &#125;
&#125;</code></pre>
<h2 id="44-客户端功能实现"><a class="markdownIt-Anchor" href="#44-客户端功能实现"></a> 4.4. 客户端功能实现</h2>
<h4 id="441-api-请求封装"><a class="markdownIt-Anchor" href="#441-api-请求封装"></a> 4.4.1. API 请求封装</h4>
<p>在用户登录后，我们需要确保所有 API 请求都能正确携带身份验证信息。然而，<code>accessToken</code> 可能会过期，如果没有自动刷新机制，用户将频繁被登出，影响体验。我们希望实现一个自动处理令牌的方案，使得：</p>
<ul>
<li>每个请求都自动携带 <code>accessToken</code> 进行身份验证。</li>
<li>当 <code>accessToken</code> 过期时，自动使用 <code>refreshToken</code> 获取新的 <code>accessToken</code>，并重试原请求。</li>
<li>如果 <code>refreshToken</code> 也失效，则清除令牌并让用户重新登录。</li>
</ul>
<p>我们使用 Axios 拦截器 来实现这一机制，主要分为两部分：</p>
<ol>
<li>
<p>请求拦截器：</p>
<ul>
<li>在每个请求发送前，自动读取 <code>accessToken</code>，并将其添加到请求头。</li>
<li>如果 <code>accessToken</code> 不存在，则直接发送请求。</li>
</ul>
</li>
<li>
<p>响应拦截器：</p>
<ul>
<li>监听 API 响应，如果返回 <code>401 Unauthorized</code>，说明 <code>accessToken</code> 可能已过期。</li>
<li>如果 <code>refreshToken</code> 仍然有效，则使用它请求新的 <code>accessToken</code>，然后重试原始请求。</li>
<li>如果 <code>refreshToken</code> 失效，则清除所有令牌，并要求用户重新登录。</li>
</ul>
</li>
</ol>
<p>这是客户端请求与响应拦截逻辑的流程：</p>
<svg aria-roledescription="flowchart-v2" role="graphics-document document" viewbox="-7.5 -8 597.109375 278.1171875" style="max-width: 597.109375px;" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" width="100%" id="mermaid-1757905077409"><style>#mermaid-1757905077409{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mermaid-1757905077409 .error-icon{fill:#552222;}#mermaid-1757905077409 .error-text{fill:#552222;stroke:#552222;}#mermaid-1757905077409 .edge-thickness-normal{stroke-width:2px;}#mermaid-1757905077409 .edge-thickness-thick{stroke-width:3.5px;}#mermaid-1757905077409 .edge-pattern-solid{stroke-dasharray:0;}#mermaid-1757905077409 .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-1757905077409 .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-1757905077409 .marker{fill:#333333;stroke:#333333;}#mermaid-1757905077409 .marker.cross{stroke:#333333;}#mermaid-1757905077409 svg{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;}#mermaid-1757905077409 .label{font-family:"trebuchet ms",verdana,arial,sans-serif;color:#333;}#mermaid-1757905077409 .cluster-label text{fill:#333;}#mermaid-1757905077409 .cluster-label span,#mermaid-1757905077409 p{color:#333;}#mermaid-1757905077409 .label text,#mermaid-1757905077409 span,#mermaid-1757905077409 p{fill:#333;color:#333;}#mermaid-1757905077409 .node rect,#mermaid-1757905077409 .node circle,#mermaid-1757905077409 .node ellipse,#mermaid-1757905077409 .node polygon,#mermaid-1757905077409 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mermaid-1757905077409 .flowchart-label text{text-anchor:middle;}#mermaid-1757905077409 .node .katex path{fill:#000;stroke:#000;stroke-width:1px;}#mermaid-1757905077409 .node .label{text-align:center;}#mermaid-1757905077409 .node.clickable{cursor:pointer;}#mermaid-1757905077409 .arrowheadPath{fill:#333333;}#mermaid-1757905077409 .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mermaid-1757905077409 .flowchart-link{stroke:#333333;fill:none;}#mermaid-1757905077409 .edgeLabel{background-color:#e8e8e8;text-align:center;}#mermaid-1757905077409 .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mermaid-1757905077409 .labelBkg{background-color:rgba(232, 232, 232, 0.5);}#mermaid-1757905077409 .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mermaid-1757905077409 .cluster text{fill:#333;}#mermaid-1757905077409 .cluster span,#mermaid-1757905077409 p{color:#333;}#mermaid-1757905077409 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mermaid-1757905077409 .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mermaid-1757905077409 :root{--mermaid-font-family:"trebuchet ms",verdana,arial,sans-serif;}</style><g><marker orient="auto" markerheight="12" markerwidth="12" markerunits="userSpaceOnUse" refy="5" refx="6" viewbox="0 0 10 10" class="marker flowchart" id="mermaid-1757905077409_flowchart-pointEnd"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 0 L 10 5 L 0 10 z"/></marker><marker orient="auto" markerheight="12" markerwidth="12" markerunits="userSpaceOnUse" refy="5" refx="4.5" viewbox="0 0 10 10" class="marker flowchart" id="mermaid-1757905077409_flowchart-pointStart"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 5 L 10 10 L 10 0 z"/></marker><marker orient="auto" markerheight="11" markerwidth="11" markerunits="userSpaceOnUse" refy="5" refx="11" viewbox="0 0 10 10" class="marker flowchart" id="mermaid-1757905077409_flowchart-circleEnd"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"/></marker><marker orient="auto" markerheight="11" markerwidth="11" markerunits="userSpaceOnUse" refy="5" refx="-1" viewbox="0 0 10 10" class="marker flowchart" id="mermaid-1757905077409_flowchart-circleStart"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"/></marker><marker orient="auto" markerheight="11" markerwidth="11" markerunits="userSpaceOnUse" refy="5.2" refx="12" viewbox="0 0 11 11" class="marker cross flowchart" id="mermaid-1757905077409_flowchart-crossEnd"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"/></marker><marker orient="auto" markerheight="11" markerwidth="11" markerunits="userSpaceOnUse" refy="5.2" refx="-1" viewbox="0 0 11 11" class="marker cross flowchart" id="mermaid-1757905077409_flowchart-crossStart"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"/></marker><g class="root"><g class="clusters"><g class="edgePaths"><g class="edgeLabels"><g class="nodes"><g transform="translate(-7.5, -8)" class="root"><g class="clusters"><g id="请求拦截" class="cluster default flowchart-label"><rect height="262.1171875" width="581.109375" y="8" x="8" ry="0" rx="0" style=""/><g transform="translate(266.5546875, 8)" class="cluster-label"><foreignobject height="21" width="64"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel">请求拦截</span></div></foreignobject></g></g></g><g class="edgePaths"><path marker-end="url(#mermaid-1757905077409_flowchart-pointEnd)" style="fill:none;" class="edge-thickness-normal edge-pattern-solid flowchart-link LS-A LE-B" id="L-A-B-0" d="M112,139.059L116.167,139.059C120.333,139.059,128.667,139.059,136.2,139.125C143.734,139.191,150.467,139.323,153.834,139.389L157.201,139.455"/><path marker-end="url(#mermaid-1757905077409_flowchart-pointEnd)" style="fill:none;" class="edge-thickness-normal edge-pattern-solid flowchart-link LS-B LE-C" id="L-B-C-0" d="M315.647,116.471L324.912,113.069C334.176,109.667,352.705,102.863,366.586,99.461C380.468,96.059,389.701,96.059,394.318,96.059L398.934,96.059"/><path marker-end="url(#mermaid-1757905077409_flowchart-pointEnd)" style="fill:none;" class="edge-thickness-normal edge-pattern-solid flowchart-link LS-B LE-D" id="L-B-D-0" d="M315.647,162.646L324.912,165.881C334.176,169.117,352.705,175.588,373.326,178.823C393.947,182.059,416.659,182.059,428.016,182.059L439.372,182.059"/></g><g class="edgeLabels"><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"/></div></foreignobject></g></g><g transform="translate(371.234375, 96.05859375)" class="edgeLabel"><g transform="translate(-8, -10.5)" class="label"><foreignobject height="21" width="16"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel">是</span></div></foreignobject></g></g><g transform="translate(371.234375, 182.05859375)" class="edgeLabel"><g transform="translate(-8, -10.5)" class="label"><foreignobject height="21" width="16"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel">否</span></div></foreignobject></g></g></g><g class="nodes"><g transform="translate(250.1171875, 139.05859375)" data-id="B" data-node="true" id="flowchart-B-1" class="node default default flowchart-label"><polygon style="" transform="translate(-88.1171875,88.1171875)" class="label-container" points="88.1171875,0 176.234375,-88.1171875 88.1171875,-176.234375 0,-88.1171875"/><g transform="translate(-62.6171875, -10.5)" style="" class="label"><rect/><foreignobject height="21" width="125.234375"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel">存在accessToken?</span></div></foreignobject></g></g><g transform="translate(72.5, 139.05859375)" data-id="A" data-node="true" id="flowchart-A-0" class="node default default flowchart-label"><rect height="36" width="79" y="-18" x="-39.5" ry="0" rx="0" style="" class="basic label-container"/><g transform="translate(-32, -10.5)" style="" class="label"><rect/><foreignobject height="21" width="64"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel">发起请求</span></div></foreignobject></g></g><g transform="translate(484.171875, 96.05859375)" data-id="C" data-node="true" id="flowchart-C-3" class="node default default flowchart-label"><rect height="36" width="159.875" y="-18" x="-79.9375" ry="0" rx="0" style="" class="basic label-container"/><g transform="translate(-72.4375, -10.5)" style="" class="label"><rect/><foreignobject height="21" width="144.875"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel">添加Authorization头</span></div></foreignobject></g></g><g transform="translate(484.171875, 182.05859375)" data-id="D" data-node="true" id="flowchart-D-5" class="node default default flowchart-label"><rect height="36" width="79" y="-18" x="-39.5" ry="0" rx="0" style="" class="basic label-container"/><g transform="translate(-32, -10.5)" style="" class="label"><rect/><foreignobject height="21" width="64"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel">直接发送</span></div></foreignobject></g></g></g></g></g></g></g></g></g></g></svg>
<svg aria-roledescription="flowchart-v2" role="graphics-document document" viewbox="-7.5 -8 1177 399.54296875" style="max-width: 1177px;" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" width="100%" id="mermaid-1757905078943"><style>#mermaid-1757905078943{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mermaid-1757905078943 .error-icon{fill:#552222;}#mermaid-1757905078943 .error-text{fill:#552222;stroke:#552222;}#mermaid-1757905078943 .edge-thickness-normal{stroke-width:2px;}#mermaid-1757905078943 .edge-thickness-thick{stroke-width:3.5px;}#mermaid-1757905078943 .edge-pattern-solid{stroke-dasharray:0;}#mermaid-1757905078943 .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-1757905078943 .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-1757905078943 .marker{fill:#333333;stroke:#333333;}#mermaid-1757905078943 .marker.cross{stroke:#333333;}#mermaid-1757905078943 svg{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;}#mermaid-1757905078943 .label{font-family:"trebuchet ms",verdana,arial,sans-serif;color:#333;}#mermaid-1757905078943 .cluster-label text{fill:#333;}#mermaid-1757905078943 .cluster-label span,#mermaid-1757905078943 p{color:#333;}#mermaid-1757905078943 .label text,#mermaid-1757905078943 span,#mermaid-1757905078943 p{fill:#333;color:#333;}#mermaid-1757905078943 .node rect,#mermaid-1757905078943 .node circle,#mermaid-1757905078943 .node ellipse,#mermaid-1757905078943 .node polygon,#mermaid-1757905078943 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mermaid-1757905078943 .flowchart-label text{text-anchor:middle;}#mermaid-1757905078943 .node .katex path{fill:#000;stroke:#000;stroke-width:1px;}#mermaid-1757905078943 .node .label{text-align:center;}#mermaid-1757905078943 .node.clickable{cursor:pointer;}#mermaid-1757905078943 .arrowheadPath{fill:#333333;}#mermaid-1757905078943 .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mermaid-1757905078943 .flowchart-link{stroke:#333333;fill:none;}#mermaid-1757905078943 .edgeLabel{background-color:#e8e8e8;text-align:center;}#mermaid-1757905078943 .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mermaid-1757905078943 .labelBkg{background-color:rgba(232, 232, 232, 0.5);}#mermaid-1757905078943 .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mermaid-1757905078943 .cluster text{fill:#333;}#mermaid-1757905078943 .cluster span,#mermaid-1757905078943 p{color:#333;}#mermaid-1757905078943 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mermaid-1757905078943 .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mermaid-1757905078943 :root{--mermaid-font-family:"trebuchet ms",verdana,arial,sans-serif;}</style><g><marker orient="auto" markerheight="12" markerwidth="12" markerunits="userSpaceOnUse" refy="5" refx="6" viewbox="0 0 10 10" class="marker flowchart" id="mermaid-1757905078943_flowchart-pointEnd"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 0 L 10 5 L 0 10 z"/></marker><marker orient="auto" markerheight="12" markerwidth="12" markerunits="userSpaceOnUse" refy="5" refx="4.5" viewbox="0 0 10 10" class="marker flowchart" id="mermaid-1757905078943_flowchart-pointStart"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 5 L 10 10 L 10 0 z"/></marker><marker orient="auto" markerheight="11" markerwidth="11" markerunits="userSpaceOnUse" refy="5" refx="11" viewbox="0 0 10 10" class="marker flowchart" id="mermaid-1757905078943_flowchart-circleEnd"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"/></marker><marker orient="auto" markerheight="11" markerwidth="11" markerunits="userSpaceOnUse" refy="5" refx="-1" viewbox="0 0 10 10" class="marker flowchart" id="mermaid-1757905078943_flowchart-circleStart"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"/></marker><marker orient="auto" markerheight="11" markerwidth="11" markerunits="userSpaceOnUse" refy="5.2" refx="12" viewbox="0 0 11 11" class="marker cross flowchart" id="mermaid-1757905078943_flowchart-crossEnd"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"/></marker><marker orient="auto" markerheight="11" markerwidth="11" markerunits="userSpaceOnUse" refy="5.2" refx="-1" viewbox="0 0 11 11" class="marker cross flowchart" id="mermaid-1757905078943_flowchart-crossStart"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"/></marker><g class="root"><g class="clusters"><g class="edgePaths"><g class="edgeLabels"><g class="nodes"><g transform="translate(-7.5, -8)" class="root"><g class="clusters"><g id="响应拦截" class="cluster default flowchart-label"><rect height="383.54296875" width="1161" y="8" x="8" ry="0" rx="0" style=""/><g transform="translate(556.5, 8)" class="cluster-label"><foreignobject height="21" width="64"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel">响应拦截</span></div></foreignobject></g></g></g><g class="edgePaths"><path marker-end="url(#mermaid-1757905078943_flowchart-pointEnd)" style="fill:none;" class="edge-thickness-normal edge-pattern-solid flowchart-link LS-E LE-F" id="L-E-F-0" d="M112,237.602L116.167,237.602C120.333,237.602,128.667,237.602,136.2,237.668C143.734,237.734,150.467,237.866,153.834,237.932L157.201,237.998"/><path marker-end="url(#mermaid-1757905078943_flowchart-pointEnd)" style="fill:none;" class="edge-thickness-normal edge-pattern-solid flowchart-link LS-F LE-G" id="L-F-G-0" d="M271.569,208.733L281.88,200.989C292.192,193.245,312.815,177.757,327.826,170.084C342.838,162.41,352.238,162.55,356.938,162.62L361.638,162.69"/><path marker-end="url(#mermaid-1757905078943_flowchart-pointEnd)" style="fill:none;" class="edge-thickness-normal edge-pattern-solid flowchart-link LS-G LE-H" id="L-G-H-0" d="M508.122,138.626L517.563,134.614C527.003,130.601,545.884,122.576,559.942,118.563C573.999,114.551,583.232,114.551,587.849,114.551L592.466,114.551"/><path marker-end="url(#mermaid-1757905078943_flowchart-pointEnd)" style="fill:none;" class="edge-thickness-normal edge-pattern-solid flowchart-link LS-H LE-I" id="L-H-I-0" d="M708.766,114.551L714.266,114.551C719.766,114.551,730.766,114.551,740.966,114.621C751.166,114.691,760.566,114.831,765.266,114.902L769.966,114.972"/><path marker-end="url(#mermaid-1757905078943_flowchart-pointEnd)" style="fill:none;" class="edge-thickness-normal edge-pattern-solid flowchart-link LS-I LE-J" id="L-I-J-0" d="M884.956,103.866L892.237,102.11C899.517,100.355,914.079,96.843,925.976,95.088C937.874,93.332,947.107,93.332,951.724,93.332L956.341,93.332"/><path marker-end="url(#mermaid-1757905078943_flowchart-pointEnd)" style="fill:none;" class="edge-thickness-normal edge-pattern-solid flowchart-link LS-I LE-K" id="L-I-K-0" d="M869.976,141.215L879.753,148.66C889.531,156.105,909.086,170.994,930.928,183.075C952.771,195.155,976.901,204.428,988.966,209.064L1001.031,213.7"/><path marker-end="url(#mermaid-1757905078943_flowchart-pointEnd)" style="fill:none;" class="edge-thickness-normal edge-pattern-solid flowchart-link LS-G LE-K" id="L-G-K-0" d="M496.877,198.158L508.192,206.607C519.507,215.056,542.136,231.954,568.201,240.403C594.266,248.852,623.766,248.852,653.266,248.852C682.766,248.852,712.266,248.852,742.589,248.852C772.911,248.852,804.057,248.852,835.203,248.852C866.349,248.852,897.495,248.852,924.971,247.39C952.447,245.928,976.253,243.004,988.157,241.543L1000.06,240.081"/><path marker-end="url(#mermaid-1757905078943_flowchart-pointEnd)" style="fill:none;" class="edge-thickness-normal edge-pattern-solid flowchart-link LS-F LE-L" id="L-F-L-0" d="M271.569,267.47L281.88,275.047C292.192,282.625,312.815,297.779,334.937,305.356C357.059,312.934,380.68,312.934,392.491,312.934L404.302,312.934"/></g><g class="edgeLabels"><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"/></div></foreignobject></g></g><g transform="translate(333.4375, 162.26953125)" class="edgeLabel"><g transform="translate(-8, -10.5)" class="label"><foreignobject height="21" width="16"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel">是</span></div></foreignobject></g></g><g transform="translate(564.765625, 114.55078125)" class="edgeLabel"><g transform="translate(-8, -10.5)" class="label"><foreignobject height="21" width="16"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel">是</span></div></foreignobject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"/></div></foreignobject></g></g><g transform="translate(928.640625, 93.33203125)" class="edgeLabel"><g transform="translate(-8, -10.5)" class="label"><foreignobject height="21" width="16"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel">是</span></div></foreignobject></g></g><g transform="translate(928.640625, 185.8828125)" class="edgeLabel"><g transform="translate(-8, -10.5)" class="label"><foreignobject height="21" width="16"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel">否</span></div></foreignobject></g></g><g transform="translate(741.765625, 248.8515625)" class="edgeLabel"><g transform="translate(-8, -10.5)" class="label"><foreignobject height="21" width="16"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel">否</span></div></foreignobject></g></g><g transform="translate(333.4375, 312.93359375)" class="edgeLabel"><g transform="translate(-8, -10.5)" class="label"><foreignobject height="21" width="16"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel">否</span></div></foreignobject></g></g></g><g class="nodes"><g transform="translate(231.21875, 237.6015625)" data-id="F" data-node="true" id="flowchart-F-1" class="node default default flowchart-label"><polygon style="" transform="translate(-69.21875,69.21875)" class="label-container" points="69.21875,0 138.4375,-69.21875 69.21875,-138.4375 0,-69.21875"/><g transform="translate(-43.71875, -10.5)" style="" class="label"><rect/><foreignobject height="21" width="87.4375"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel">状态码=401?</span></div></foreignobject></g></g><g transform="translate(72.5, 237.6015625)" data-id="E" data-node="true" id="flowchart-E-0" class="node default default flowchart-label"><rect height="36" width="79" y="-18" x="-39.5" ry="0" rx="0" style="" class="basic label-container"/><g transform="translate(-32, -10.5)" style="" class="label"><rect/><foreignobject height="21" width="64"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel">接收响应</span></div></foreignobject></g></g><g transform="translate(449.1015625, 162.26953125)" data-id="G" data-node="true" id="flowchart-G-3" class="node default default flowchart-label"><polygon style="" transform="translate(-82.6640625,82.6640625)" class="label-container" points="82.6640625,0 165.328125,-82.6640625 82.6640625,-165.328125 0,-82.6640625"/><g transform="translate(-57.1640625, -10.5)" style="" class="label"><rect/><foreignobject height="21" width="114.328125"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel">有refreshToken?</span></div></foreignobject></g></g><g transform="translate(653.265625, 114.55078125)" data-id="H" data-node="true" id="flowchart-H-5" class="node default default flowchart-label"><rect height="36" width="111" y="-18" x="-55.5" ry="0" rx="0" style="" class="basic label-container"/><g transform="translate(-48, -10.5)" style="" class="label"><rect/><foreignobject height="21" width="96"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel">发起刷新请求</span></div></foreignobject></g></g><g transform="translate(835.203125, 114.55078125)" data-id="I" data-node="true" id="flowchart-I-7" class="node default default flowchart-label"><polygon style="" transform="translate(-60.4375,60.4375)" class="label-container" points="60.4375,0 120.875,-60.4375 60.4375,-120.875 0,-60.4375"/><g transform="translate(-34.9375, -10.5)" style="" class="label"><rect/><foreignobject height="21" width="69.875"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel">刷新成功?</span></div></foreignobject></g></g><g transform="translate(1052.8203125, 93.33203125)" data-id="J" data-node="true" id="flowchart-J-9" class="node default default flowchart-label"><rect height="36" width="182.359375" y="-18" x="-91.1796875" ry="0" rx="0" style="" class="basic label-container"/><g transform="translate(-83.6796875, -10.5)" style="" class="label"><rect/><foreignobject height="21" width="167.359375"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel">更新accessToken并重试</span></div></foreignobject></g></g><g transform="translate(1052.8203125, 233.6015625)" data-id="K" data-node="true" id="flowchart-K-11" class="node default default flowchart-label"><rect height="36" width="95" y="-18" x="-47.5" ry="0" rx="0" style="" class="basic label-container"/><g transform="translate(-40, -10.5)" style="" class="label"><rect/><foreignobject height="21" width="80"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel">跳转登录页</span></div></foreignobject></g></g><g transform="translate(449.1015625, 312.93359375)" data-id="L" data-node="true" id="flowchart-L-15" class="node default default flowchart-label"><rect height="36" width="79" y="-18" x="-39.5" ry="0" rx="0" style="" class="basic label-container"/><g transform="translate(-32, -10.5)" style="" class="label"><rect/><foreignobject height="21" width="64"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel">正常处理</span></div></foreignobject></g></g></g></g></g></g></g></g></g></g></svg>
<pre><code class="language-ts">const api = axios.create(&#123;
  baseURL: process.env.REACT_APP_API_URL,
  withCredentials: true,
  timeout: 10000
&#125;);

// 请求拦截器：添加令牌
api.interceptors.request.use(
  (config) =&gt; &#123;
    const token = localStorage.getItem(&#x27;accessToken&#x27;);
    if (token) &#123;
      config.headers = AxiosHeaders.from(config.headers);
      config.headers.set(&#x27;Authorization&#x27;, `Bearer $&#123;token&#125;`);
    &#125;
    return config;
  &#125;,
  (error) =&gt; Promise.reject(error)
);

// 响应拦截器：处理令牌刷新
api.interceptors.response.use(
  (response) =&gt; response,
  async (error) =&gt; &#123;
    const originalRequest = error.config;

    // 处理 401 错误和令牌刷新
    if (error.response?.status === 401 &amp;&amp; !originalRequest._retry) &#123;
      originalRequest._retry = true;
      const refreshToken = localStorage.getItem(&#x27;refreshToken&#x27;);
      
      if (refreshToken) &#123;
        try &#123;
          const &#123; data &#125; = await axios.post(
            `$&#123;process.env.REACT_APP_API_URL&#125;/auth/refresh`,
            &#123; refreshToken &#125;
          );
          const newAccessToken = data.access_token;
          localStorage.setItem(&#x27;accessToken&#x27;, newAccessToken);
          originalRequest.headers.Authorization = `Bearer $&#123;newAccessToken&#125;`;
          return api(originalRequest);
        &#125; catch (error) &#123;
          // 刷新失败时清除所有令牌
          localStorage.removeItem(&#x27;accessToken&#x27;);
          localStorage.removeItem(&#x27;refreshToken&#x27;);
          return Promise.reject(error);
        &#125;
      &#125;
    &#125;
    return Promise.reject(error);
  &#125;
);</code></pre>
<p>这个改造实现了对身份验证流程的优化和自动化：</p>
<ol>
<li>能够自动为请求添加访问令牌，确保每次请求都具备正确的身份验证信息。</li>
<li>能够检测令牌是否过期，并在必要时进行处理，防止因过期导致请求失败。</li>
<li>支持自动刷新令牌，并在刷新成功后重新尝试原始请求，从而提高用户体验，减少因身份验证失效带来的干扰。</li>
</ol>
<h4 id="442-状态管理优化"><a class="markdownIt-Anchor" href="#442-状态管理优化"></a> 4.4.2. 状态管理优化</h4>
<p>首先先介绍一下身份验证流程中整个认证状态的流转：</p>
<svg aria-roledescription="stateDiagram" role="graphics-document document" viewbox="0 0 460.1953125 437" style="max-width: 460.1953125px;" class="statediagram" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" width="100%" id="mermaid-1757905080395"><style>#mermaid-1757905080395{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mermaid-1757905080395 .error-icon{fill:#552222;}#mermaid-1757905080395 .error-text{fill:#552222;stroke:#552222;}#mermaid-1757905080395 .edge-thickness-normal{stroke-width:2px;}#mermaid-1757905080395 .edge-thickness-thick{stroke-width:3.5px;}#mermaid-1757905080395 .edge-pattern-solid{stroke-dasharray:0;}#mermaid-1757905080395 .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-1757905080395 .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-1757905080395 .marker{fill:#333333;stroke:#333333;}#mermaid-1757905080395 .marker.cross{stroke:#333333;}#mermaid-1757905080395 svg{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;}#mermaid-1757905080395 defs #statediagram-barbEnd{fill:#333333;stroke:#333333;}#mermaid-1757905080395 g.stateGroup text{fill:#9370DB;stroke:none;font-size:10px;}#mermaid-1757905080395 g.stateGroup text{fill:#333;stroke:none;font-size:10px;}#mermaid-1757905080395 g.stateGroup .state-title{font-weight:bolder;fill:#131300;}#mermaid-1757905080395 g.stateGroup rect{fill:#ECECFF;stroke:#9370DB;}#mermaid-1757905080395 g.stateGroup line{stroke:#333333;stroke-width:1;}#mermaid-1757905080395 .transition{stroke:#333333;stroke-width:1;fill:none;}#mermaid-1757905080395 .stateGroup .composit{fill:white;border-bottom:1px;}#mermaid-1757905080395 .stateGroup .alt-composit{fill:#e0e0e0;border-bottom:1px;}#mermaid-1757905080395 .state-note{stroke:#aaaa33;fill:#fff5ad;}#mermaid-1757905080395 .state-note text{fill:black;stroke:none;font-size:10px;}#mermaid-1757905080395 .stateLabel .box{stroke:none;stroke-width:0;fill:#ECECFF;opacity:0.5;}#mermaid-1757905080395 .edgeLabel .label rect{fill:#ECECFF;opacity:0.5;}#mermaid-1757905080395 .edgeLabel .label text{fill:#333;}#mermaid-1757905080395 .label div .edgeLabel{color:#333;}#mermaid-1757905080395 .stateLabel text{fill:#131300;font-size:10px;font-weight:bold;}#mermaid-1757905080395 .node circle.state-start{fill:#333333;stroke:#333333;}#mermaid-1757905080395 .node .fork-join{fill:#333333;stroke:#333333;}#mermaid-1757905080395 .node circle.state-end{fill:#9370DB;stroke:white;stroke-width:1.5;}#mermaid-1757905080395 .end-state-inner{fill:white;stroke-width:1.5;}#mermaid-1757905080395 .node rect{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mermaid-1757905080395 .node polygon{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mermaid-1757905080395 #statediagram-barbEnd{fill:#333333;}#mermaid-1757905080395 .statediagram-cluster rect{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mermaid-1757905080395 .cluster-label,#mermaid-1757905080395 .nodeLabel{color:#131300;}#mermaid-1757905080395 .statediagram-cluster rect.outer{rx:5px;ry:5px;}#mermaid-1757905080395 .statediagram-state .divider{stroke:#9370DB;}#mermaid-1757905080395 .statediagram-state .title-state{rx:5px;ry:5px;}#mermaid-1757905080395 .statediagram-cluster.statediagram-cluster .inner{fill:white;}#mermaid-1757905080395 .statediagram-cluster.statediagram-cluster-alt .inner{fill:#f0f0f0;}#mermaid-1757905080395 .statediagram-cluster .inner{rx:0;ry:0;}#mermaid-1757905080395 .statediagram-state rect.basic{rx:5px;ry:5px;}#mermaid-1757905080395 .statediagram-state rect.divider{stroke-dasharray:10,10;fill:#f0f0f0;}#mermaid-1757905080395 .note-edge{stroke-dasharray:5;}#mermaid-1757905080395 .statediagram-note rect{fill:#fff5ad;stroke:#aaaa33;stroke-width:1px;rx:0;ry:0;}#mermaid-1757905080395 .statediagram-note rect{fill:#fff5ad;stroke:#aaaa33;stroke-width:1px;rx:0;ry:0;}#mermaid-1757905080395 .statediagram-note text{fill:black;}#mermaid-1757905080395 .statediagram-note .nodeLabel{color:black;}#mermaid-1757905080395 .statediagram .edgeLabel{color:red;}#mermaid-1757905080395 #dependencyStart,#mermaid-1757905080395 #dependencyEnd{fill:#333333;stroke:#333333;stroke-width:1;}#mermaid-1757905080395 .statediagramTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mermaid-1757905080395 :root{--mermaid-font-family:"trebuchet ms",verdana,arial,sans-serif;}</style><g><defs><marker orient="auto" markerunits="strokeWidth" markerheight="14" markerwidth="20" refy="7" refx="19" id="mermaid-1757905080395_statediagram-barbEnd"><path d="M 19,7 L9,13 L14,7 L9,1 Z"/></marker></defs><g class="root"><g class="clusters"><g class="edgePaths"><path marker-end="url(#mermaid-1757905080395_statediagram-barbEnd)" style="fill:none" class="edge-thickness-normal transition" id="edge0" d="M246.098,22L246.098,26.167C246.098,30.333,246.098,38.667,246.098,47C246.098,55.333,246.098,63.667,246.098,67.833L246.098,72"/><path marker-end="url(#mermaid-1757905080395_statediagram-barbEnd)" style="fill:none" class="edge-thickness-normal transition" id="edge1" d="M235.971,108L232.643,113.917C229.314,119.833,222.657,131.667,222.657,143.5C222.657,155.333,229.314,167.167,232.643,173.083L235.971,179"/><path marker-end="url(#mermaid-1757905080395_statediagram-barbEnd)" style="fill:none" class="edge-thickness-normal transition" id="edge2" d="M246.098,215L246.098,220.917C246.098,226.833,246.098,238.667,246.098,250.5C246.098,262.333,246.098,274.167,246.098,280.083L246.098,286"/><path marker-end="url(#mermaid-1757905080395_statediagram-barbEnd)" style="fill:none" class="edge-thickness-normal transition" id="edge3" d="M276.411,179L286.375,173.083C296.339,167.167,316.267,155.333,316.267,143.5C316.267,131.667,296.339,119.833,286.375,113.917L276.411,108"/><path marker-end="url(#mermaid-1757905080395_statediagram-barbEnd)" style="fill:none" class="edge-thickness-normal transition" id="edge4" d="M214.598,312.865L188.165,320.304C161.732,327.743,108.866,342.622,83.107,355.978C57.349,369.333,58.697,381.167,59.372,387.083L60.046,393"/><path marker-end="url(#mermaid-1757905080395_statediagram-barbEnd)" style="fill:none" class="edge-thickness-normal transition" id="edge5" d="M244.046,322L243.372,327.917C242.697,333.833,241.349,345.667,252.198,357.5C263.046,369.333,286.093,381.167,297.616,387.083L309.139,393"/><path marker-end="url(#mermaid-1757905080395_statediagram-barbEnd)" style="fill:none" class="edge-thickness-normal transition" id="edge6" d="M352.27,393L354.924,387.083C357.578,381.167,362.887,369.333,350.441,356.8C337.996,344.267,307.797,331.035,292.697,324.419L277.598,317.802"/><path marker-end="url(#mermaid-1757905080395_statediagram-barbEnd)" style="fill:none" class="edge-thickness-normal transition" id="edge7" d="M369.765,393L378.17,387.083C386.575,381.167,403.385,369.333,411.79,354.5C420.195,339.667,420.195,321.833,420.195,304C420.195,286.167,420.195,268.333,420.195,250.5C420.195,232.667,420.195,214.833,420.195,197C420.195,179.167,420.195,161.333,396.429,145.113C372.663,128.893,325.13,114.287,301.364,106.983L277.598,99.68"/><path marker-end="url(#mermaid-1757905080395_statediagram-barbEnd)" style="fill:none" class="edge-thickness-normal transition" id="edge8" d="M82.925,393L89.771,387.083C96.616,381.167,110.308,369.333,117.154,354.5C124,339.667,124,321.833,124,304C124,286.167,124,268.333,124,250.5C124,232.667,124,214.833,124,197C124,179.167,124,161.333,139.1,145.8C154.199,130.267,184.398,117.035,199.498,110.419L214.598,103.802"/></g><g class="edgeLabels"><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><rect height="0" width="0" ry="0" rx="0"/><foreignobject height="0" width="0"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"/></div></foreignobject></g></g><g transform="translate(216, 143.5)" class="edgeLabel"><g transform="translate(-48, -10.5)" class="label"><rect height="21" width="96" ry="0" rx="0"/><foreignobject height="21" width="96"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel">自动登录检查</span></div></foreignobject></g></g><g transform="translate(246.09765625, 250.5)" class="edgeLabel"><g transform="translate(-48, -10.5)" class="label"><rect height="21" width="96" ry="0" rx="0"/><foreignobject height="21" width="96"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel">自动登录成功</span></div></foreignobject></g></g><g transform="translate(336.1953125, 143.5)" class="edgeLabel"><g transform="translate(-48, -10.5)" class="label"><rect height="21" width="96" ry="0" rx="0"/><foreignobject height="21" width="96"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel">自动登录失败</span></div></foreignobject></g></g><g transform="translate(56, 357.5)" class="edgeLabel"><g transform="translate(-48, -10.5)" class="label"><rect height="21" width="96" ry="0" rx="0"/><foreignobject height="21" width="96"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel">用户主动登出</span></div></foreignobject></g></g><g transform="translate(240, 357.5)" class="edgeLabel"><g transform="translate(-60.1953125, -10.5)" class="label"><rect height="21" width="120.390625" ry="0" rx="0"/><foreignobject height="21" width="120.390625"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel">AccessToken过期</span></div></foreignobject></g></g><g transform="translate(368.1953125, 357.5)" class="edgeLabel"><g transform="translate(-32, -10.5)" class="label"><rect height="21" width="64" ry="0" rx="0"/><foreignobject height="21" width="64"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel">刷新成功</span></div></foreignobject></g></g><g transform="translate(420.1953125, 250.5)" class="edgeLabel"><g transform="translate(-32, -10.5)" class="label"><rect height="21" width="64" ry="0" rx="0"/><foreignobject height="21" width="64"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel">刷新失败</span></div></foreignobject></g></g><g transform="translate(124, 250.5)" class="edgeLabel"><g transform="translate(-48, -10.5)" class="label"><rect height="21" width="96" ry="0" rx="0"/><foreignobject height="21" width="96"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel">清除本地存储</span></div></foreignobject></g></g></g><g class="nodes"><g transform="translate(246.09765625, 15)" data-id="root_start" data-node="true" id="state-root_start-0" class="node default"><circle height="14" width="14" r="7" class="state-start"/></g><g transform="translate(246.09765625, 90)" data-id="未认证" data-node="true" id="state-未认证-8" class="node  statediagram-state undefined"><rect height="36" width="63" y="-18" x="-31.5" style="" class="basic label-container"/><g transform="translate(-24, -10.5)" style="" class="label"><rect/><foreignobject height="21" width="48"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel">未认证</span></div></foreignobject></g></g><g transform="translate(246.09765625, 197)" data-id="认证中" data-node="true" id="state-认证中-3" class="node  statediagram-state undefined"><rect height="36" width="63" y="-18" x="-31.5" style="" class="basic label-container"/><g transform="translate(-24, -10.5)" style="" class="label"><rect/><foreignobject height="21" width="48"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel">认证中</span></div></foreignobject></g></g><g transform="translate(246.09765625, 304)" data-id="已认证" data-node="true" id="state-已认证-6" class="node  statediagram-state undefined"><rect height="36" width="63" y="-18" x="-31.5" style="" class="basic label-container"/><g transform="translate(-24, -10.5)" style="" class="label"><rect/><foreignobject height="21" width="48"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel">已认证</span></div></foreignobject></g></g><g transform="translate(62.09765625, 411)" data-id="已注销" data-node="true" id="state-已注销-8" class="node  statediagram-state undefined"><rect height="36" width="63" y="-18" x="-31.5" style="" class="basic label-container"/><g transform="translate(-24, -10.5)" style="" class="label"><rect/><foreignobject height="21" width="48"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel">已注销</span></div></foreignobject></g></g><g transform="translate(344.1953125, 411)" data-id="令牌刷新中" data-node="true" id="state-令牌刷新中-7" class="node  statediagram-state undefined"><rect height="36" width="95" y="-18" x="-47.5" style="" class="basic label-container"/><g transform="translate(-40, -10.5)" style="" class="label"><rect/><foreignobject height="21" width="80"><div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel">令牌刷新中</span></div></foreignobject></g></g></g></g></g></g></svg>
<ol>
<li>用户在首次访问时可能处于 <strong>未认证</strong> 状态，系统会自动检查用户的登录状态。</li>
<li>认证过程中可能会发生令牌过期的情况，需要进行 <strong>令牌刷新</strong>。</li>
<li>而在用户注销时，系统会清除本地存储数据。</li>
</ol>
<p>为了有效管理用户的认证状态和流程，我们引入了一个状态机，覆盖以下几种主要状态和转变：</p>
<ol>
<li>
<p>未认证</p>
<p>初始状态，表示用户尚未通过认证。系统会自动检查是否有有效的认证信息（如 <code>accessToken</code> 或 <code>refreshToken</code>）。如果没有，用户将无法访问受保护的资源。</p>
</li>
<li>
<p>认证中</p>
<p>系统正在验证用户的认证信息，可能是通过自动登录检查（例如检查本地存储的 <code>accessToken</code> 或 <code>refreshToken</code>）来恢复用户的会话。若检查成功，用户进入 已认证 状态；若失败，进入 <strong>未认证</strong> 状态。</p>
</li>
<li>
<p>已认证</p>
<p>认证成功后，用户的身份验证信息有效，允许访问受保护的资源。如果在该状态下，用户的 <code>accessToken</code> 过期，系统会自动尝试通过刷新令牌（<code>refreshToken</code>）来更新 <code>accessToken</code>，进入 <strong>令牌刷新中</strong> 状态。</p>
</li>
<li>
<p>令牌刷新中</p>
<p>当 <code>accessToken</code> 过期且用户依然处于已认证状态时，系统会通过 <code>refreshToken</code> 尝试获取新的 <code>accessToken</code>。如果刷新成功，系统返回 <strong>已认证</strong> 状态；如果刷新失败，用户会被迫重新认证（进入 <strong>未认证</strong> 状态）。</p>
</li>
<li>
<p>已注销</p>
<p>用户主动退出时，系统会清除本地存储的认证信息，返回到 <strong>未认证</strong> 状态，确保用户的会话被完全销毁。</p>
</li>
<li>
<p>状态转换</p>
<p>通过自动登录检查、令牌刷新等机制，我们确保用户认证状态的持续性和稳定性。系统根据认证状态的变化自动调整访问权限和用户会话管理。</p>
</li>
</ol>
<p>在用户状态管理中，我们先添加了自动登录相关的功能：</p>
<pre><code class="language-ts">const createUserSlice: StateCreator&lt;UserState&gt; = (set, get) =&gt; (&#123;
  // ... 其他状态
  isAutoLoading: false,  // 新增自动登录状态

  // 清除用户信息
  clearUser: () =&gt; &#123;
    localStorage.removeItem(&#x27;accessToken&#x27;);
    localStorage.removeItem(&#x27;refreshToken&#x27;);
    set(&#123; user: null, isAutoLoading: false &#125;);
  &#125;,

  // 自动登录功能
  autoLogin: async () =&gt; &#123;
    const state = get();
    if (state.isAutoLoading || state.user) return;

    const accessToken = localStorage.getItem(&#x27;accessToken&#x27;);
    const refreshToken = localStorage.getItem(&#x27;refreshToken&#x27;);

    if (!accessToken &amp;&amp; !refreshToken) return;

    set(&#123; isAutoLoading: true &#125;);

    try &#123;
      let token = accessToken;

      // 如果没有访问令牌但有刷新令牌，尝试刷新
      if (!token &amp;&amp; refreshToken) &#123;
        const response = await api.post(&#x27;/auth/refresh&#x27;, &#123; refreshToken &#125;);
        token = response.data.access_token;
        if (token) &#123;
          localStorage.setItem(&#x27;accessToken&#x27;, token);
        &#125;
      &#125;

      // 获取用户信息
      const response = await api.get(&#x27;/auth/me&#x27;, &#123;
        headers: &#123; Authorization: `Bearer $&#123;token&#125;` &#125;
      &#125;);

      set(&#123; user: response.data, isAutoLoading: false &#125;);
    &#125; catch (error) &#123;
      localStorage.removeItem(&#x27;accessToken&#x27;);
      localStorage.removeItem(&#x27;refreshToken&#x27;);
      set(&#123; user: null, isAutoLoading: false &#125;);
      throw error;
    &#125;
  &#125;,

  // 登出功能增强
  logout: async () =&gt; &#123;
    try &#123;
      await api.post(&#x27;/auth/logout&#x27;);
    &#125; finally &#123;
      localStorage.removeItem(&#x27;accessToken&#x27;);
      localStorage.removeItem(&#x27;refreshToken&#x27;);
      set(&#123; user: null &#125;);
    &#125;
  &#125;
&#125;);</code></pre>
<h4 id="443-状态管理范式转变"><a class="markdownIt-Anchor" href="#443-状态管理范式转变"></a> 4.4.3. 状态管理范式转变</h4>
<p>在登录功能中，我们需要处理用户的身份验证，同时提供“记住我”功能。然而，使用传统的状态管理（也就是我们的 Zustand）来存储 <code>error</code> 和 <code>isLoading</code> 状态可能会带来一些问题：</p>
<ul>
<li>全局状态污染：<code>error</code> 和 <code>isLoading</code> 这些状态只是登录相关，不需要在整个应用范围内存储。</li>
<li>手动管理状态：需要在 <code>try/catch</code> 中手动更新 <code>isLoading</code>，并在发生错误时手动存储 <code>error</code>，代码较为冗长。</li>
<li>状态同步问题：如果多个组件依赖相同的登录逻辑，手动管理状态可能会导致数据不同步。</li>
</ul>
<p>为了解决这些问题，我们决定使用 React Query 提供的 <code>useMutation</code>，将登录请求的状态管理完全交由 React Query 处理。</p>
<p>安装 React Query：</p>
<pre><code class="language-bash">yarn add @tanstack/react-query</code></pre>
<p>让我们以注册组件为例，来看看这次改造。</p>
<p>在之前的实现中，我们使用全局状态来管理加载状态和错误信息：</p>
<pre><code class="language-tsx">const Register = () =&gt; &#123;
  const register = useUserStore(state =&gt; state.register);
  const isLoading = useUserStore(state =&gt; state.isLoading);
  const error = useUserStore(state =&gt; state.error);

  const formik = useFormik(&#123;
    // ...
    onSubmit: async (values) =&gt; &#123;
      try &#123;
        const &#123; username, email, password &#125; = values;
        await register(&#123; username, email, password &#125;);
        navigate(&#x27;/login&#x27;, &#123;
          state: &#123;
            message: &#x27;注册成功！请登录您的账号。&#x27;,
            email: values.email
          &#125;
        &#125;);
      &#125; catch (error) &#123;
        console.error(&#x27;注册失败：&#x27;, error);
      &#125;
    &#125;
  &#125;);
&#125;;</code></pre>
<p>这种方式存在以下问题：</p>
<ul>
<li>状态管理过于集中，不同组件的加载状态和错误状态混杂在一起</li>
<li>需要手动管理状态的清理和重置</li>
<li>错误处理不够优雅</li>
<li>缺乏对请求生命周期的完整控制</li>
</ul>
<p>在开始实现具体功能之前，我们需要先配置 React Query。首先修改应用的入口文件 <code>index.tsx</code>：</p>
<pre><code class="language-tsx">import &#123; QueryClient, QueryClientProvider &#125; from &#x27;@tanstack/react-query&#x27;;

const queryClient = new QueryClient();

const root = ReactDOM.createRoot(document.getElementById(&#x27;root&#x27;) as HTMLElement);
root.render(
  &lt;React.StrictMode&gt;
    &lt;QueryClientProvider client=&#123;queryClient&#125;&gt;
      &lt;App /&gt;
    &lt;/QueryClientProvider&gt;
  &lt;/React.StrictMode&gt;
);</code></pre>
<p>使用 React Query 的 <code>useMutation</code> 后，代码变得更加清晰和强大：</p>
<pre><code class="language-tsx">const Register = () =&gt; &#123;
  const setUser = useUserStore(state =&gt; state.setUser);

  const &#123; mutate: register, isPending, error &#125; = useMutation(&#123;
    mutationFn: async (values: &#123;
      username: string;
      email: string;
      password: string;
    &#125;) =&gt; &#123;
      const response = await api.post(&#x27;/users/create&#x27;, values);
      return response.data;
    &#125;,
    onSuccess: (data) =&gt; &#123;
      setUser(data.user);
      navigate(&#x27;/login&#x27;, &#123;
        state: &#123;
          message: &#x27;注册成功！请检查邮箱完成验证&#x27;,
          email: data.user.email
        &#125;,
        replace: true
      &#125;);
    &#125;
  &#125;);

  const formik = useFormik(&#123;
    // ...
    onSubmit: async (values) =&gt; &#123;
      register(&#123;
        username: values.username,
        email: values.email,
        password: values.password
      &#125;);
    &#125;
  &#125;);
&#125;;</code></pre>
<p>这种改进带来了多个显著的好处，使得代码更加清晰、组件更加独立，且状态管理更加高效：</p>
<ol>
<li>
<p>实现了状态隔离。每个组件都有自己独立的加载和错误状态，不同的请求不会相互影响，从而避免了状态混乱的问题。同时，当组件卸载时，状态会自动清理，确保资源的合理释放。</p>
</li>
<li>
<p>得益于生命周期钩子的引入，异步操作的管理更加灵活。<code>mutationFn</code> 负责定义实际的异步操作，<code>onSuccess</code> 处理成功场景，而 <code>onError</code> 则用于错误处理。这些钩子让我们能够更精准地控制请求的执行过程。</p>
<p>在错误处理方面，这种改进也带来了增强。错误信息会被自动捕获并保存，同时错误状态与组件绑定，使得错误管理更加直观。此外，还能够提供更详细的错误类型信息，方便开发者调试和优化。</p>
</li>
<li>
<p>大幅简化了使用方式。开发者不需要手动处理 <code>try/catch</code> 逻辑，也不需要手动管理 <code>loading</code> 状态，只需直接调用 <code>mutate</code> 函数，即可完成异步操作，提高了开发效率和代码可读性。</p>
</li>
</ol>
<blockquote>
<p>使用 <code>useMutation</code> 的基本步骤：</p>
<ol>
<li>定义 <code>mutation</code> 函数：</li>
</ol>
<pre><code class="language-ts">mutationFn: async (values) =&gt; &#123;
  const response = await api.post(&#x27;/users/create&#x27;, values);
  return response.data;
&#125;</code></pre>
<ol start="2">
<li>配置生命周期钩子：</li>
</ol>
<pre><code class="language-ts">onSuccess: (data) =&gt; &#123;
  // 处理成功场景
&#125;,
onError: (error) =&gt; &#123;
  // 处理错误场景
&#125;</code></pre>
<ol start="3">
<li>在组件中使用：</li>
</ol>
<pre><code class="language-ts">const &#123; mutate, isPending, error &#125; = useMutation(&#123; ... &#125;);

// 触发 mutation
mutate(values);

// 使用状态
&#123;isPending &amp;&amp; &lt;LoadingSpinner /&gt;&#125;
&#123;error &amp;&amp; &lt;ErrorMessage error=&#123;error&#125; /&gt;&#125;</code></pre>
</blockquote>
<p>同样的，修改 <code>VerifyEmail</code> 组件：</p>
<pre><code class="language-tsx">import React, &#123;useEffect&#125; from &#x27;react&#x27;; 
import &#123;useLocation, useNavigate&#125; from &#x27;react-router-dom&#x27;; 
import &#123;useMutation&#125; from &#x27;@tanstack/react-query&#x27;; 
import &#123;useUserStore&#125; from &#x27;../stores&#x27;; 
import api from &#x27;../stores/common/api&#x27;; 
 
const VerifyEmail = () =&gt; &#123; 
  const location = useLocation(); 
  const navigate = useNavigate(); 
  const token = new URLSearchParams(location.search).get(&#x27;token&#x27;); 
 
  const &#123; 
    emailVerified, 
    verificationError, 
    verificationToken, 
    verificationUserId, 
    clearVerificationState 
  &#125; = useUserStore(state =&gt; (&#123; 
    emailVerified: state.emailVerified, 
    verificationError: state.verificationError, 
    verificationToken: state.verificationToken, 
    verificationUserId: state.verificationUserId, 
    clearVerificationState: state.clearVerificationState 
  &#125;)); 
 
  const &#123; mutate: verifyEmail, isPending &#125; = useMutation(&#123; 
    mutationFn: async (token: string) =&gt; &#123; 
      const response = await api.get(`/users/verify-email?token=$&#123;token&#125;`); 
      return response.data; 
    &#125;, 
    onSuccess: (data) =&gt; &#123; 
      if (data.success) &#123; 
        useUserStore.setState(&#123; 
          emailVerified: true, 
          verificationUserId: data.userId 
        &#125;); 
        navigate(&#x27;/login&#x27;, &#123; replace: true &#125;) 
      &#125; else &#123; 
        useUserStore.setState(&#123; 
          verificationError: data.error, 
          verificationUserId: data.userId 
        &#125;); 
      &#125; 
    &#125;, 
    onError: (error) =&gt; &#123; 
      useUserStore.setState(&#123; verificationError: error.message || &#x27;验证过程中发生未知错误&#x27; &#125;); 
    &#125; 
  &#125;); 
 
  useEffect(() =&gt; &#123; 
    if (token) verifyEmail(token); 
  &#125;, [token]); 
 
  useEffect(() =&gt; &#123; 
    return () =&gt; &#123; 
      clearVerificationState(); 
      window.history.replaceState(&#123;&#125;, &#x27;&#x27;, window.location.pathname); 
    &#125; 
  &#125;, []); 
 
  const handleResend = async () =&gt; &#123; 
    if (verificationUserId) &#123; 
      try &#123; 
        await api.post(`/users/resend-verification/$&#123;verificationUserId&#125;`); 
        navigate(&#x27;/login&#x27;, &#123; 
          state: &#123; message: &#x27;新的验证邮件已发送，请查收邮箱&#x27; &#125; 
        &#125;); 
      &#125; catch (error) &#123; 
        useUserStore.setState(&#123; verificationError: &#x27;重新发送验证邮件失败&#x27; &#125;); 
        throw error instanceof Error 
          ? error.message 
          : &#x27;重新发送验证邮件失败&#x27;; 
      &#125; 
    &#125; 
  &#125; 
 
  return ( 
    &lt;div className=&quot;min-h-screen flex items-center justify-center bg-base-200&quot;&gt; 
      &lt;div className=&quot;card w-96 bg-base-100 shadow-xl&quot;&gt; 
        &lt;div className=&quot;card-body items-center text-center&quot;&gt; 
          &lt;h2 className=&quot;card-title mb-4&quot;&gt; 
            验证电子邮件 
          &lt;/h2&gt; 
 
          &#123;isPending &amp;&amp; ( 
            &lt;div className=&quot;flex flex-col items-center gap-4&quot;&gt; 
              &lt;span className=&quot;loading loading-spinner loading-lg&quot; /&gt; 
              &lt;p&gt;正在验证您的邮箱...&lt;/p&gt; 
            &lt;/div&gt; 
          )&#125; 
 
          &#123;emailVerified &amp;&amp; ( 
            &lt;div className=&quot;alert alert-success&quot;&gt; 
              &lt;span&gt;邮箱验证成功！正在跳转至登录页面……&lt;/span&gt; 
            &lt;/div&gt; 
          )&#125; 
 
          &#123;verificationError &amp;&amp; ( 
            &lt;div className=&quot;alert alert-error flex flex-col gap-3&quot;&gt; 
              &lt;span&gt;&#123;verificationError&#125;&lt;/span&gt; 
              &#123;verificationUserId &amp;&amp; ( 
                &lt;button 
                  className=&quot;btn btn-sm btn-outline&quot; 
                  onClick=&#123;handleResend&#125; 
                &gt; 
                  重新发送验证邮件 
                &lt;/button&gt; 
              )&#125; 
            &lt;/div&gt; 
          )&#125; 
 
          &#123;!isPending &amp;&amp; !emailVerified &amp;&amp; !verificationError &amp;&amp; verificationToken &amp;&amp; ( 
            &lt;div className=&quot;flex flex-col gap-3&quot;&gt; 
              &lt;p&gt;验证链接已失效&lt;/p&gt; 
              &lt;button 
                className=&quot;btn btn-outline&quot; 
                onClick=&#123;() =&gt; verifyEmail(verificationToken)&#125; 
              &gt; 
                重新尝试验证 
              &lt;/button&gt; 
            &lt;/div&gt; 
          )&#125; 
        &lt;/div&gt; 
      &lt;/div&gt; 
    &lt;/div&gt; 
  ); 
&#125;; 
 
export default VerifyEmail; </code></pre>
<h4 id="444-登录组件改造"><a class="markdownIt-Anchor" href="#444-登录组件改造"></a> 4.4.4. 登录组件改造</h4>
<p>我们需要对登录组件（<code>Login.tsx</code>）进行改造，以支持“记住我”功能。</p>
<ol>
<li>
<p>在表单验证模式中增加“记住我”选项：</p>
 <pre><code class="language-tsx">const validationSchema = Yup.object().shape(&#123; 
  username: Yup.string().required(&#x27;请输入用户名！&#x27;), 
  password: Yup.string().required(&#x27;请输入密码！&#x27;),
  rememberMe: Yup.boolean()  // 新增
&#125;); 

const formik = useFormik(&#123; 
  initialValues: &#123; 
    username: &#x27;&#x27;, 
    password: &#x27;&#x27;, 
    rememberMe: false  // 新增
  &#125;, 
  validationSchema,
  onSubmit: async (values) =&gt; &#123;
    login(values);
  &#125;
&#125;);</code></pre>
</li>
<li>
<p>使用 <code>useMutation</code> 重构登录逻辑：</p>
 <pre><code class="language-tsx">const &#123; mutate: login, isPending, error &#125; = useMutation(&#123; 
  mutationFn: async (credentials: &#123; 
    username: string, 
    password: string, 
    rememberMe: boolean, 
  &#125;) =&gt; &#123; 
    const response = await api.post(&#x27;/auth/login&#x27;, credentials); 
    return response.data; 
  &#125;, 
  onSuccess: async (data) =&gt; &#123; 
    localStorage.setItem(&#x27;accessToken&#x27;, data.access_token); 
    // 只有在用户选择“记住我”时才保存刷新令牌
    if (formik.values.rememberMe) &#123;
      localStorage.setItem(&#x27;refreshToken&#x27;, data.refresh_token); 
    &#125;
    setUser(data.user); 
    navigate(&#x27;/&#x27;, &#123; 
      state: &#123; message: &#x27;登陆成功！&#x27; &#125;, 
      replace: true 
    &#125;) 
  &#125;, 
  onError: (error) =&gt; &#123; 
    // 登录失败时清除所有令牌
    localStorage.removeItem(&#x27;accessToken&#x27;); 
    localStorage.removeItem(&#x27;refreshToken&#x27;); 
    clearUser(); 
    console.log(&#x27;登录失败：&#x27;, error); 
  &#125; 
&#125;);</code></pre>
</li>
<li>
<p>添加自动登录检查逻辑：</p>
 <pre><code class="language-tsx">useEffect(() =&gt; &#123; 
  const checkAutoLogin = async () =&gt; &#123; 
    const accessToken = localStorage.getItem(&#x27;accessToken&#x27;); 
    const refreshToken = localStorage.getItem(&#x27;refreshToken&#x27;); 

    if (accessToken || refreshToken) &#123; 
      try &#123; 
        await autoLogin(); 
      &#125; catch (error) &#123; 
        clearUser(); 
        localStorage.removeItem(&#x27;accessToken&#x27;); 
        localStorage.removeItem(&#x27;refreshToken&#x27;); 
        console.log(&#x27;检查自动登录失败：&#x27;, error); 
      &#125; 
    &#125; 
  &#125; 

  checkAutoLogin().then(r =&gt; console.log(&#x27;检查自动登录成功：&#x27;, r)); 
&#125;, []);</code></pre>
</li>
<li>
<p>登录后自动跳转：</p>
 <pre><code class="language-tsx">useEffect(() =&gt; &#123; 
  if (user &amp;&amp; !isAutoLoading) &#123; 
    navigate(&#x27;/&#x27;, &#123; replace: true &#125;); 
  &#125; 
&#125;, [user, isAutoLoading, navigate]);</code></pre>
</li>
<li>
<p>添加“记住我”选项的界面元素：</p>
 <pre><code class="language-tsx">&lt;div className=&quot;mb-4 flex items-center&quot;&gt; 
  &lt;input 
    type=&quot;checkbox&quot; 
    id=&quot;rememberMe&quot; 
    name=&quot;rememberMe&quot; 
    className=&quot;w-4 h-4 text-primary bg-base-300 border-neutral-600 rounded&quot; 
    checked=&#123;formik.values.rememberMe&#125; 
    onChange=&#123;formik.handleChange&#125; 
    disabled=&#123;isPending&#125; 
  /&gt; 
  &lt;label 
    htmlFor=&quot;rememberMe&quot; 
    className=&quot;ml-2 text-sm text-neutral-content cursor-pointer&quot; 
  &gt; 
    记住我 
  &lt;/label&gt; 
&lt;/div&gt;</code></pre>
</li>
</ol>
<h2 id="45-邮箱验证提示"><a class="markdownIt-Anchor" href="#45-邮箱验证提示"></a> 4.5. 邮箱验证提示</h2>
<p>为了提升用户体验，我们需要在用户未验证邮箱时给出明显的提示。这个功能包含两个部分：提示组件和布局改造。</p>
<p>创建 <code>UnverifiedBanner</code> 组件来显示验证提示：</p>
<pre><code class="language-tsx">import React from &#x27;react&#x27;;
import &#123; useUserStore &#125; from &#x27;../stores&#x27;;

const UnverifiedBanner = () =&gt; &#123;
  const user = useUserStore(state =&gt; state.user);
  if (user &amp;&amp; !user.verified) &#123;
    return (
      &lt;div className=&quot;p-4 mb-4 text-sm text-warning-content bg-warning rounded&quot;&gt;
        您的邮箱尚未验证，请尽快验证。您可以修改邮箱地址或&lt;a href=&quot;/resend-verification&quot; className=&quot;underline ml-1&quot;&gt;重新发送验证邮件&lt;/a&gt;。
      &lt;/div&gt;
    );
  &#125;
  return null;
&#125;;

export default UnverifiedBanner;</code></pre>
<p>这个组件具有几个重要特点。它通过全局状态获取用户信息，确保始终使用最新的用户数据。同时，它只会在用户尚未完成验证时显示，避免对已验证用户造成干扰。此外，组件还提供了快捷的邮箱验证操作，使用户能够方便地完成身份确认，提高使用体验。</p>
<p>将验证提示集成到 <code>AuthLayout</code> 中：</p>
<pre><code class="language-tsx">import React from &#x27;react&#x27;; 
import UnverifiedBanner from &#x27;../components/UnverifiedBanner&#x27;; 
 
type AuthLayoutProps = &#123; 
  children: React.ReactNode; 
&#125;; 
 
const AuthLayout = (&#123; children &#125;: AuthLayoutProps) =&gt; &#123; 
  return ( 
    &lt;div className=&quot;flex flex-col min-h-screen items-center justify-center bg-base-200&quot;&gt; 
      &lt;UnverifiedBanner /&gt; 
      &lt;div className=&quot;w-full max-w-md bg-base-100 p-8 rounded-lg shadow-xl&quot;&gt; 
        &#123;children&#125; 
      &lt;/div&gt; 
    &lt;/div&gt; 
  ); 
&#125;; 
 
export default AuthLayout; </code></pre>
<p>这种改进带来了多方面的好处。用户可以及时了解自己的邮箱验证状态，避免因未验证而影响正常使用。同时，组件提供了直接的验证操作入口，使用户能够快速完成身份确认。此外，它保持了统一的视觉风格，与整体界面设计相协调，并且不会影响原有的布局结构，确保页面的整洁与一致性。</p>
<p>为了解决用户可能未收到验证邮件或验证邮件过期的问题，我们需要实现验证邮件重发功能：</p>
<pre><code class="language-tsx">import React, &#123;useCallback, useEffect&#125; from &#x27;react&#x27;;
import &#123; useNavigate &#125; from &#x27;react-router-dom&#x27;;
import &#123;useMutation&#125; from &#x27;@tanstack/react-query&#x27;;
import &#123; useUserStore &#125; from &#x27;../stores&#x27;;
import api from &#x27;../stores/common/api&#x27;;

const ResendVerification = () =&gt; &#123;
  const navigate = useNavigate();

  const &#123;
    user,
    verificationUserId,
    clearVerificationState
  &#125; = useUserStore(state =&gt; (&#123;
    user: state.user,
    verificationUserId: state.verificationUserId,
    clearVerificationState: state.clearVerificationState
  &#125;));

  const &#123; mutate: resendEmail, isPending, error &#125; = useMutation(&#123;
    mutationFn: async (userId: string) =&gt; &#123;
      const response = await api.post(`/users/resend-verification/$&#123;userId&#125;`);
      return response.data;
    &#125;,
    onSuccess: () =&gt; &#123;
      navigate(&#x27;/login&#x27;, &#123;
        state: &#123; message: &#x27;新的验证邮件已发送至你的注册邮箱&#x27; &#125;,
        replace: true
      &#125;);
    &#125;
  &#125;)

  const handleResend = useCallback(() =&gt; &#123;
    if (!verificationUserId) &#123;
      console.error(&#x27;缺少用户 ID&#x27;);
      return;
    &#125;
    resendEmail(verificationUserId);
  &#125;, [verificationUserId, resendEmail]);

  useEffect(() =&gt; &#123;
    return () =&gt; &#123;
      clearVerificationState();
    &#125;;
  &#125;, [clearVerificationState]);

  return (
    &lt;div className=&quot;min-h-screen flex items-center justify-center bg-base-200&quot;&gt;
      &lt;div className=&quot;card w-96 bg-base-100 shadow-xl&quot;&gt;
        &lt;div className=&quot;card-body items-center text-center&quot;&gt;
          &lt;h2 className=&quot;card-title mb-4&quot;&gt;
            邮箱验证
          &lt;/h2&gt;

          &lt;div className=&quot;flex flex-col items-center gap-4&quot;&gt;
            &lt;p className=&quot;text-sm&quot;&gt;
              你的邮箱 &lt;strong className=&quot;text-primary&quot;&gt;&#123;user?.email&#125;&lt;/strong&gt; 还未验证
            &lt;/p&gt;

            &#123;error &amp;&amp; (
              &lt;div className=&quot;alert alert-error shadow-lg&quot;&gt;
                &lt;div&gt;
                  &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; className=&quot;stroke-current flex-shrink-0 h-6 w-6&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot;&gt;
                    &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth=&quot;2&quot; d=&quot;M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z&quot; /&gt;
                  &lt;/svg&gt;
                  &lt;span&gt;&#123;error.message&#125;&lt;/span&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            )&#125;

            &lt;button
              onClick=&#123;handleResend&#125;
              disabled=&#123;isPending&#125;
              className=&#123;`btn btn-primary w-full $&#123;isPending ? &#x27;loading&#x27; : &#x27;&#x27;&#125;`&#125;
            &gt;
              &#123;isPending ? &#x27;发送中...&#x27; : &#x27;重新发送验证邮件&#x27;&#125;
            &lt;/button&gt;

            &lt;div className=&quot;text-sm mt-4&quot;&gt;
              &lt;p className=&quot;text-gray-500&quot;&gt;
                没有收到邮件？请检查垃圾邮件文件夹
              &lt;/p&gt;
              &lt;p className=&quot;text-gray-500 mt-2&quot;&gt;
                需要修改邮箱？前往&#123;&#x27; &#x27;&#125;
                &lt;a
                  href=&quot;/settings&quot;
                  className=&quot;link link-primary&quot;
                  onClick=&#123;(e) =&gt; &#123;
                    e.preventDefault();
                    navigate(&#x27;/settings&#x27;);
                  &#125;&#125;
                &gt;
                  账户设置
                &lt;/a&gt;
              &lt;/p&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
&#125;

export default ResendVerification;</code></pre>
<p>通过这个功能，我们为用户提供了一个完整的邮箱验证补救方案，帮助他们顺利完成账号验证过程。</p>
<h2 id="46-错误边界处理"><a class="markdownIt-Anchor" href="#46-错误边界处理"></a> 4.6. 错误边界处理</h2>
<p>在复杂的单页应用中，错误处理是一个非常重要的环节。为了防止应用因为某个组件的错误而完全崩溃，我们引入了错误边界（Error Boundary）机制。</p>
<p>安装 <code>react-error-boundary</code>：</p>
<pre><code class="language-bash">yarn add react-error-boundary</code></pre>
<h4 id="461-应用入口改造"><a class="markdownIt-Anchor" href="#461-应用入口改造"></a> 4.6.1. 应用入口改造</h4>
<p>首先，我们在应用的最顶层添加错误边界保护。修改 <code>App.tsx</code>：</p>
<pre><code class="language-tsx">import React from &#x27;react&#x27;;
import &#123; RouterProvider &#125; from &#x27;react-router-dom&#x27;;
import &#123; ErrorBoundary &#125; from &#x27;react-error-boundary&#x27;;
import router from &#x27;./router&#x27;;
import ErrorFallback from &#x27;./components/ErrorFallback&#x27;;

const App = () =&gt; &#123;
  return (
    &lt;ErrorBoundary FallbackComponent=&#123;ErrorFallback&#125;&gt;
      &lt;RouterProvider router=&#123; router &#125; /&gt;
    &lt;/ErrorBoundary&gt;
  );
&#125;

export default App;</code></pre>
<p>这样做可以捕获整个应用中的 React 组件错误，防止应用崩溃。</p>
<h4 id="462-错误回退组件"><a class="markdownIt-Anchor" href="#462-错误回退组件"></a> 4.6.2. 错误回退组件</h4>
<p>我们创建了一个专门的错误回退组件 <code>ErrorFallback.tsx</code>，用于显示错误信息并提供重试功能：</p>
<pre><code class="language-tsx">import React from &#x27;react&#x27;;
import &#123; FallbackProps &#125; from &#x27;react-error-boundary&#x27;;

const ErrorFallback = (&#123; error, resetErrorBoundary &#125;: FallbackProps) =&gt; &#123;
  return (
    &lt;div className=&quot;alert alert-error shadow-lg&quot;&gt;
      &lt;div&gt;
        &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; className=&quot;stroke-current flex-shrink-0 h-6 w-6&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot;&gt;
          &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth=&quot;2&quot; d=&quot;M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z&quot; /&gt;
        &lt;/svg&gt;
        &lt;div&gt;
          &lt;h3 className=&quot;font-bold&quot;&gt;发生错误！&lt;/h3&gt;
          &lt;pre className=&quot;whitespace-pre-wrap&quot;&gt;&#123;error.message&#125;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;button
        className=&quot;btn btn-sm btn-primary&quot;
        onClick=&#123;resetErrorBoundary&#125;
      &gt;
        重试
      &lt;/button&gt;
    &lt;/div&gt;
  );
&#125;

export default ErrorFallback;</code></pre>
<p>错误回退组件具备以下核心功能，旨在提升错误处理的可读性和用户体验：</p>
<ol>
<li>提供清晰的错误信息展示。组件能够显示友好的错误提示，同时呈现具体的错误详情，并保持错误信息的格式化显示，以便用户理解问题所在。</li>
<li>支持错误恢复功能。用户可以通过重试按钮尝试重新执行操作，同时，<code>resetErrorBoundary</code> 方法允许重置错误状态，使应用能够正常运行，让用户得以从错误中恢复。</li>
<li>在用户体验方面，组件采用统一的错误提示样式，确保与应用的整体设计风格保持一致。同时，它提供清晰的操作指引，帮助用户快速做出合适的应对操作，从而减少因错误导致的使用困扰。</li>
</ol>
<h2 id="47-路由访问控制"><a class="markdownIt-Anchor" href="#47-路由访问控制"></a> 4.7. 路由访问控制</h2>
<p>为了确保用户只能访问其权限内的页面，我们需要实现路由保护机制。这包括对私有路由的保护和对公共路由的控制。</p>
<h4 id="471-受保护路由组件"><a class="markdownIt-Anchor" href="#471-受保护路由组件"></a> 4.7.1. 受保护路由组件</h4>
<p>创建 <code>ProtectedRoute</code> 组件用于保护需要登录才能访问的页面：</p>
<pre><code class="language-tsx">import React from &#x27;react&#x27;;
import &#123;useLocation, Navigate&#125; from &#x27;react-router-dom&#x27;;
import &#123;useUserStore&#125; from &#x27;../stores&#x27;;


const ProtectedRoute = (&#123; children &#125;: &#123; children: React.ReactNode &#125;) =&gt; &#123;
  const user = useUserStore(state =&gt; state.user);
  const isAutoLoading = useUserStore(state =&gt; state.isAutoLoading);
  const location = useLocation();

  // TODO: 返回一个加载动画
  if (isAutoLoading) return &lt;div&gt;加载中……&lt;/div&gt;;

  if (!user) return &lt;Navigate to=&quot;/login&quot; state=&#123;&#123;from: location&#125;&#125; replace /&gt;;

  return &lt;&gt;&#123;children&#125;&lt;/&gt;;
&#125;

export default ProtectedRoute;</code></pre>
<h4 id="472-公共路由组件"><a class="markdownIt-Anchor" href="#472-公共路由组件"></a> 4.7.2. 公共路由组件</h4>
<p>创建 <code>PublicRoute</code> 组件用于处理登录、注册等公共页面：</p>
<pre><code class="language-tsx">import React from &#x27;react&#x27;;
import &#123;useUserStore&#125; from &#x27;../stores&#x27;;
import &#123;Navigate, useLocation&#125; from &#x27;react-router-dom&#x27;;

const PublicRoute = (&#123;children&#125; : &#123;children: React.ReactNode&#125;) =&gt; &#123;
  const user = useUserStore(state =&gt; state.user);
  const isAutoLoading = useUserStore(state =&gt; state.isAutoLoading);
  const location = useLocation();

  if (isAutoLoading) return &lt;div&gt;加载中……&lt;/div&gt;;

  if (user) &#123;
    const from = location.state?.from?.pathname || &#x27;/&#x27;;
    return &lt;Navigate to=&#123;from&#125; replace /&gt;;
  &#125;

  return &lt;&gt;&#123;children&#125;&lt;/&gt;;
&#125;

export default PublicRoute;</code></pre>
<h4 id="473-路由配置优化"><a class="markdownIt-Anchor" href="#473-路由配置优化"></a> 4.7.3. 路由配置优化</h4>
<p>使用这些保护组件来包装路由：</p>
<pre><code class="language-tsx">const router = createBrowserRouter([ 
  &#123; 
    path: &#x27;/&#x27;, 
    element: &lt;ProtectedRoute&gt;&lt;MainPage /&gt;&lt;/ProtectedRoute&gt; 
  &#125;, 
  &#123; 
    path: &#x27;/register&#x27;, 
    element: &lt;PublicRoute&gt;&lt;Register /&gt;&lt;/PublicRoute&gt; 
  &#125;, 
  &#123; 
    path: &#x27;/login&#x27;, 
    element: &lt;PublicRoute&gt;&lt;Login /&gt;&lt;/PublicRoute&gt; 
  &#125;, 
  &#123; 
    path: &#x27;/verify-email&#x27;, 
    element: &lt;VerifyEmail /&gt; 
  &#125;, 
  &#123; 
    path: &#x27;/resend-verification&#x27;, 
    element: &lt;ResendVerification /&gt; 
  &#125; 
]);</code></pre>
<blockquote>
<p>可以写一个简单的 <code>MainPage</code> 组件来测试登出功能：</p>
<pre><code class="language-tsx">import React from &#x27;react&#x27;;
import &#123; useUserStore &#125; from &#x27;../stores&#x27;;
import MainLayout from &#x27;../layouts/MainLayout&#x27;;

const MainPage = () =&gt; &#123;
  const logout = useUserStore(state =&gt; state.logout);

  return (
    &lt;MainLayout&gt;
      &lt;button onClick=&#123;logout&#125;&gt;登出&lt;/button&gt;
    &lt;/MainLayout&gt;
  )
&#125;;

export default MainPage;</code></pre>
</blockquote>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="6976.html">上一篇</a><a class="next" href="567.html">下一篇</a></div><div class="copyright"><p>© 2022 - 2025 <a href="https://cytrogen.icu">Cytrogen</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/cytrogen/hexo-theme-ares" target="_blank">hexo-theme-ares</a>.</p></div></footer></div></div><a class="back-to-top" href="#top" aria-label="返回顶部"><svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path d="M3.293 9.707a1 1 0 010-1.414L9.586 2a2 2 0 012.828 0l6.293 6.293a1 1 0 01-1.414 1.414L11 3.414V17a1 1 0 11-2 0V3.414L2.707 9.707a1 1 0 01-1.414 0z"></path></svg></a><script>document.addEventListener('DOMContentLoaded', function() {
  const codeBlocks = document.querySelectorAll('figure.highlight');
  
  codeBlocks.forEach(block => {
    let caption = block.querySelector('figcaption');
    if (!caption) {
      caption = document.createElement('figcaption');
      block.insertBefore(caption, block.firstChild);
    }

    const info = document.createElement('div');
    info.className = 'info';
    
    const filename = caption.querySelector('span');
    if (filename) {
      filename.className = 'filename';
      info.appendChild(filename);
    }
    
    const lang = block.className.split(' ')[1];
    if (lang) {
      const langSpan = document.createElement('span');
      langSpan.className = 'lang-name';
      langSpan.textContent = lang;
      info.appendChild(langSpan);
    }

    const sourceLink = caption.querySelector('a');
    if (sourceLink) {
      sourceLink.className = 'source-link';
      info.appendChild(sourceLink);
    }

    const actions = document.createElement('div');
    actions.className = 'actions';

    const codeHeight = block.scrollHeight;
    const threshold = 300;

    if (codeHeight > threshold) {
      block.classList.add('folded');
      
      const toggleBtn = document.createElement('button');
      toggleBtn.textContent = '展开';
      toggleBtn.addEventListener('click', () => {
        block.classList.toggle('folded');
        toggleBtn.textContent = block.classList.contains('folded') ? '展开' : '折叠';
      });
      actions.appendChild(toggleBtn);
    }

    const copyBtn = document.createElement('button');
    copyBtn.textContent = '复制';
    copyBtn.addEventListener('click', async () => {
      const codeLines = block.querySelectorAll('.code .line');
      const code = Array.from(codeLines)
        .map(line => line.textContent)
        .join('\n')
        .replace(/\n\n/g, '\n');
      
      try {
        await navigator.clipboard.writeText(code);
        copyBtn.textContent = '已复制';
        copyBtn.classList.add('copied');
        
        setTimeout(() => {
          copyBtn.textContent = '复制';
          copyBtn.classList.remove('copied');
        }, 3000);
      } catch (err) {
        console.error('复制失败:', err);
        copyBtn.textContent = '复制失败';
        
        setTimeout(() => {
          copyBtn.textContent = '复制';
        }, 3000);
      }
    });
    actions.appendChild(copyBtn);

    caption.innerHTML = '';
    caption.appendChild(info);
    caption.appendChild(actions);

    const markedLines = block.getAttribute('data-marked-lines');
    if (markedLines) {
      const lines = markedLines.split(',');
      lines.forEach(range => {
        if (range.includes('-')) {
          const [start, end] = range.split('-').map(Number);
          for (let i = start; i <= end; i++) {
            const line = block.querySelector(`.line-${i}`);
            if (line) line.classList.add('marked');
          }
        } else {
          const line = block.querySelector(`.line-${range}`);
          if (line) line.classList.add('marked');
        }
      });
    }
  });
});</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=G-4PVPZXE0QQ"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-4PVPZXE0QQ');</script><script>(function() {
  // Wait for DOM to be ready
  document.addEventListener('DOMContentLoaded', function() {
    const themeToggle = document.querySelector('.theme-toggle');
    
    if (!themeToggle) return;
    
    // Get current theme
    const getCurrentTheme = () => {
      return document.documentElement.getAttribute('data-theme') || 'light';
    };
    
    // Update UI to match current theme
    const updateUI = (theme) => {
      const isDark = theme === 'dark';
      themeToggle.setAttribute('aria-pressed', isDark.toString());
    };
    
    // Simplified theme setter - CSS handles all animations
    const setTheme = (theme) => {
      document.documentElement.setAttribute('data-theme', theme);
      document.documentElement.style.colorScheme = theme; // Update native UI elements
      
      // Also update page-wrapper for animation support
      const pageWrapper = document.getElementById('page-wrapper');
      if (pageWrapper) {
        pageWrapper.setAttribute('data-theme', theme);
      }
      
      // Find and remove the temporary anti-flicker style tag if it exists.
      // This ensures the main stylesheet takes full control after the initial load.
      const antiFlickerStyle = document.getElementById('anti-flicker-style');
      if (antiFlickerStyle) {
        antiFlickerStyle.remove();
      }
      
      localStorage.setItem('theme', theme);
      updateUI(theme);
    };
    
    // Simple theme toggle - letting CSS handle the smooth transitions
    const toggleTheme = () => {
      const current = getCurrentTheme();
      const newTheme = current === 'light' ? 'dark' : 'light';
      setTheme(newTheme);
    };
    
    // Initialize UI on page load
    updateUI(getCurrentTheme());
    
    // Add click event listener
    themeToggle.addEventListener('click', toggleTheme);
    
    // Listen for system theme changes
    if (window.matchMedia) {
      const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
      mediaQuery.addEventListener('change', function(e) {
        // Only update if no manual preference is saved
        if (!localStorage.getItem('theme')) {
          const theme = e.matches ? 'dark' : 'light';
          setTheme(theme);
        }
      });
    }
  });
})();
</script><script>(function() {
  document.addEventListener('DOMContentLoaded', function() {
    const backToTopBtn = document.querySelector('.back-to-top');
    
    if (!backToTopBtn) return;
    
    // Show/hide button based on scroll position
    const toggleButtonVisibility = () => {
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      const shouldShow = scrollTop > 200; // Show after scrolling 200px
      
      if (shouldShow) {
        backToTopBtn.classList.add('is-visible');
      } else {
        backToTopBtn.classList.remove('is-visible');
      }
    };
    
    // Throttle scroll events for better performance
    let ticking = false;
    const handleScroll = () => {
      if (!ticking) {
        requestAnimationFrame(() => {
          toggleButtonVisibility();
          ticking = false;
        });
        ticking = true;
      }
    };
    
    // Smooth scroll to top when clicked
    const scrollToTop = (event) => {
      event.preventDefault();
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    };
    
    // Add event listeners
    window.addEventListener('scroll', handleScroll);
    backToTopBtn.addEventListener('click', scrollToTop);
    
    // Check initial scroll position
    toggleButtonVisibility();
  });
})();</script></body></html>